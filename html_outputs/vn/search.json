[
  {
    "objectID": "index.vn.html",
    "href": "index.vn.html",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "",
    "text": "Chào mừng",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "index.vn.html#phân-tích-dữ-liệu-dịch-tễ-học-và-y-tế-công-cộng-với-r",
    "href": "index.vn.html#phân-tích-dữ-liệu-dịch-tễ-học-và-y-tế-công-cộng-với-r",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "Phân tích dữ liệu dịch tễ học và y tế công cộng với R",
    "text": "Phân tích dữ liệu dịch tễ học và y tế công cộng với R\nSử dụng: Sổ tay này đã được sử dụng trên 3 triệu lần bởi 850,000 người trên toàn thế giới.\nMục tiêu: Là một tài liệu tham khảo R một cách nhanh chóng (trực tuyến và ngoại tuyến), cung cấp các ví dụ tập trung vào nhiệm vụ giải quyết các vấn đề dịch tễ học phổ biến.\nBạn mới bắt đầu học R? Thử trải nghiệm các học phần tương tác miễn phí hoặc khóa học trực tuyến nền tảng về R của chúng tôi, đã được sử dụng bởi US CDC, WHO, 400+ tổ chức y tế khác, và các Chương trình đào tạo dịch tễ học thực địa (FETP) trên toàn thế giới.\nAdd a new line here\nNgôn ngữ: Tiếng Anh (English), Tiếng Việt, Tiếng Pháp (Français), Tiếng Tây Ban Nha (Español), Tiếng Nhật (日本), Tiếng Thổ Nhĩ Kỳ (Türkçe), Tiếng Bồ Đào Nha (Português), Tiếng Nga (Русский)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\nĐược viết bởi các nhà dịch tễ học, dành cho các nhà dịch tễ học\nApplied Epi là một tổ chức phi lợi nhuận của các nhà dịch tễ học thực địa từ khắp mọi nơi trên thế giới. Chúng tôi dành thời gian rảnh rỗi của mình để viết và cung cấp tài liệu này cho cộng đồng. Mọi lời động viên khuyến khích và phản hồi của bạn đều được chúng tôi chào đón:\n\nTruy cập website của chúng tôi và ghi danh vào danh sách liên lạc\n\ncontact@appliedepi.org, tweet @appliedepi, hoặc LinkedIn\n\nGửi các vấn đề cho chúng tôi tại Github repository\nCác góp ý liên quan tới bản dịch, vui lòng liên hệ Trưởng nhóm dịch\n\nChúng tôi cũng cung cấp các khóa học trực tuyến với đội ngũ giảng viên giàu kinh nghiệm đến từ khắp mọi nơi trên thế giới. Liên hệ tại www.appliedepi.org/live.",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "index.vn.html#sổ-tay-này-được-sử-dụng-như-thế-nào",
    "href": "index.vn.html#sổ-tay-này-được-sử-dụng-như-thế-nào",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "Sổ tay này được sử dụng như thế nào",
    "text": "Sổ tay này được sử dụng như thế nào\n\nTruy cập các trang trong phần Mục lục, hoặc sử dụng ô tìm kiếm\nNhấn biểu tượng “copy” để sao chép code\n\nKết hợp theo dõi cùng với các bộ dữ liệu minh họa\n\nXem phần “Tài nguyên” trong từng chương để tìm thêm tài liệu\n\nPhiên bản ngoại tuyến\nXem hướng dẫn tại trang Tải sách và dữ liệu.",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "index.vn.html#lời-cảm-ơn",
    "href": "index.vn.html#lời-cảm-ơn",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "Lời cảm ơn",
    "text": "Lời cảm ơn\nSổ tay này được tạo ra bởi sự hợp tác của các nhà dịch tễ học từ khắp nơi trên thế giới, đúc kết kinh nghiệm cùng với các tổ chức khác bao gồm các cơ quan y tế địa phương, tiểu bang, tỉnh và quốc gia, Tổ chức Y tế Thế giới (WHO), Tổ chức Bác sỹ không biên giới (MSF), hệ thống các bệnh viện, và các đơn vị nghiên cứu.\nSổ tay này không phải là sản phẩm đã được phê duyệt của bất kỳ tổ chức cụ thể nào. Mặc dù chúng tôi cố gắng đảm bảo tính chính xác, nhưng chúng tôi không chịu trách nhiệm về nội dung trong cuốn sách này.\n\nNhững người đóng góp\nChủ biên: Neale Batra\nNhóm tác giả: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin\nNhóm dịch giả: Nguyễn Thanh Lương, Võ Hữu Thuận, Nguyễn Trung Thành, Vũ Thu Hà, Hồ Hoàng Dung\nNhóm phản biện: Pat Keating, Amrish Baidjoe, Annick Lenglet, Margot Charette, Danielly Xavier, Marie-Amélie Degail Chabrat, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga\nHình minh họa: Calder Fong\n\n\n\n\n\n\nTài trợ và hỗ trợ\nSổ tay này là sản phẩm chủ yếu được hình thành từ các nỗ lực tình nguyện hàng nghìn giờ để tạo ra.\nNó cũng nhận được một phần tài trợ thông qua kinh phí hỗ trợ trợ xây dựng năng lực khẩn cấp COVID-19 từ TEPHINET, mạng lưới toàn cầu của các Chương trình Đào tạo Dịch tễ học Thực địa (FETPs).\nCác hỗ trợ hành chính được cung cấp bởi mạng lưới cựu sinh EPIET (EAN), với lời cảm ơn đặc biệt tới Annika Wendland. EPIET là Chương trình đào tạo Dịch tễ học can thiệp tại Châu Âu.\nĐặc biệt gửi lời cảm ơn tới Trung tâm Điều hành Amsterdam (OCA) của Tổ chức Bác sỹ không biên giới (MSF) cho những sự hỗ trợ của họ trong quá trình phát triển cuốn sổ tay này.\nẤn phẩm này được hỗ trợ bởi Hợp đồng Hợp tác số NU2GGH001873, được tài trợ bởi Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh thông qua TEPHINET, một chương trình của Lực lượng đặc nhiệm về sức khỏe toàn cầu. Nội dung của sổ tay hoàn toàn do tác giả chịu trách nhiệm và đại diện cho quan điểm chính thức của Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh, Bộ Y tế và Dịch vụ Nhân sinh, Lực lượng Đặc nhiệm về Sức khỏe Toàn cầu, hoặc TEPHINET\n\n\nCảm hứng\nRất nhiều các hướng dẫn và tóm tắt cung cấp kiến thức sử dụng để phát triển nội dung sổ tay này được tham khảo trong các trang nội dung tương ứng.\nMột cách tổng quát hơn, các nguồn sau đây đã truyền nguồn cảm hứng cho cuốn sổ tay này:\nThe “R4Epis” project (một sự hợp tác giữa MSF và RECON)\nR Epidemics Consortium (RECON)\nR for Data Science book (R4DS)\nbookdown: Authoring Books and Technical Documents with R Markdown\nNetlify để lưu trữ trang web này",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "index.vn.html#điều-khoản-sử-dụng-và-đóng-góp",
    "href": "index.vn.html#điều-khoản-sử-dụng-và-đóng-góp",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "Điều khoản sử dụng và đóng góp",
    "text": "Điều khoản sử dụng và đóng góp\n\nGiấy phép\nSổ tay này được cấp phép theo Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\nChúng tôi khuyến khích các khóa học và các chương trình đào tạo dịch tễ sử dụng cuốn sổ tay này cho sinh viên của mình. Nếu bạn có thắc mắc về mục đích sử dụng của mình, hãy gửi email tới epiRhandbook@gmail.com.\n\n\nTrích dẫn\nNeale Batra và cộng sự, Cẩm nang Dịch tễ học với R. \n\n\nĐóng góp\nNếu bạn muốn đóng góp nội dung, vui lòng liên hệ với chúng tôi thông qua Github hoặc email. Chúng tôi đang triển khai lịch trình cập nhật cho cuốn sách cũng như xây dựng hướng dẫn dành cho cộng tác viên.\nXin lưu ý rằng dự án epiRhandbook được phát hành cùng với bộ Quy tắc ứng xử của cộng tác viên. Bằng cách đóng góp cho dự án này, bạn đồng ý tuân theo các điều khoản của nó.",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html",
    "href": "new_pages/editorial_style.vn.html",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "",
    "text": "1.1 Cách tiếp cận và phong cách\nĐộc giả tiềm năng của cuốn sách này là rất lớn, bao gồm những người hoàn toàn mới đối với R, và cả những người dùng R có kinh nghiệm đang tìm kiếm cho mình các phương pháp và mẹo hay nhất. Vì vậy, cuốn sách cần phải vừa dễ tiếp cận vừa ngắn gọn. Do đó, cách tiếp cận của chúng tôi là cung cấp lượng văn bản giải thích vừa đủ để một người mới sử dụng R cũng có thể áp dụng code và hiểu code đang làm gì.\nMột vài điểm lưu ý:",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html#cách-tiếp-cận-và-phong-cách",
    "href": "new_pages/editorial_style.vn.html#cách-tiếp-cận-và-phong-cách",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "",
    "text": "Đây là cuốn sách tham khảo về code đi kèm với những ví dụ tương đối ngắn gọn - không phải một cuốn sách giáo khoa về R hay khoa học dữ liệu\n\nĐây là một cuốn sổ tay về R sử dụng trong dịch tễ học ứng dụng - không phải là một hướng dẫn về các phương pháp của dịch tễ học ứng dụng\n\nCuốn sách dự kiến sẽ luôn được thay đổi và cập nhập do các R packages tối ưu cho một nhiệm vụ luôn được thay đổi thường xuyên, vì vậy chúng tôi hoan nghênh những thảo luận về những điều được nhấn mạnh trong cuốn sách này\n\n\nR packages\nQuá nhiều lựa chọn\nMột trong những khía cạnh thách thức nhất của việc học R là bạn biết package nào được sử dụng trong trường hợp nào. Việc vật lộn với một công việc mà chỉ sau này bạn nhận ra là có một package R giúp bạn thực hiện tất cả những điều đó trong một dòng lệnh là điều không hề hiếm gặp!\nTrong sổ tay này, chúng tôi cố gắng cung cấp cho bạn ít nhất hai cách để hoàn thành công việc: một phương pháp đã thử và đúng (có thể là base R hoặc tidyverse) và một R package đặc biệt được thiết kế riêng cho mục đích đó. Chúng tôi muốn bạn có một số tùy chọn trong trường hợp bạn không thể tải xuống một package nhất định hoặc package đó không hoạt động với bạn.\nKhi lựa chọn package để làm việc, chúng tôi ưu tiên các R package và phương pháp tiếp cận đã được cộng đồng thử nghiệm và hiệu chỉnh, giảm thiểu số lượng package được sử dụng trong một phiên làm việc điển hình, bao gồm sự ổn định (không thay đổi thường xuyên) và giúp hoàn thành nhiệm vụ một cách đơn giản và gọn gàng\nCuốn sách này ưu tiện các package và câu lệnh từ thư viện tidyverse. Tidyverse là một tuyển tập các R package được thiết kế dành riêng cho khoa học dữ liệu, trong đó các package này chia sẻ nền tảng ngữ pháp và cấu trúc dữ liệu chung. Tất cả các package từ thư viện tidyverse có thể được cài đặt hoặc gọi thông qua thư viện tidyverse. Đọc thêm tại tidyverse website.\nKhi thích hợp, chúng tôi cũng cung cấp các tùy chọn code sử dụng base R - là các packages và hàm có sẵn của R khi cài đặt. Điều này là do chúng tôi nhận thấy rằng một số độc giả của cuốn sách này có thể không có Internet tốt để tải xuống các package bổ sung.\nLiên kết các hàm và packages một cách rõ ràng\nTrong các hướng dẫn về R thường rất khó chịu khi một hàm được hiển thị trong code, nhưng bạn không biết hàm đó đến từ package nào! Chúng tôi cố gắng tránh tình trạng này.\nTrong các đoạn văn bản trần thuật, tên các package được viết in đậm (ví dụ: dplyr) và các hàm được viết như sau: mutate(). Chúng tôi cố gắng nói rõ ràng về một hàm đến từ package nào, bằng cách tham chiếu package đó trong đoạn văn bản gần đó hoặc nhấn mạnh package đó một cách rõ ràng trong đoạn code như sau: dplyr::mutate(). Điều này nhìn có vẻ thừa thãi, nhưng chúng tôi làm điều đó là có mục đích.\nTham khảo thêm chương R cơ bản để hiểu thêm về package và hàm.\n\n\nPhong cách viết code\nTrong sổ tay này, chúng tôi thường viết theo phong cách “thêm dòng mới”, điều này làm cho code trông có vẻ “dài hơn”. Chúng tôi làm vậy vì một vài lý do sau đây:\n\nChúng tôi có thể viết các giải thích bằng # bên cạnh mỗi phần nhỏ của code\n\nNhìn chung, code dài hơn (theo chiều dọc) thì dễ đọc hơn\n\nNó cũng dễ đọc hơn trong một diện tích màn hình hẹp (không cần kéo thanh điều hướng trái phải)\n\nTừ việc thụt lề, có thể dễ dàng hơn để biết arguments nào thuộc về hàm nào\n\nKết quả là, code lẽ ra sẽ được viết trông như thế này:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;%  # group rows by hospital\n  slice_max(date, n = 1, with_ties = F) # if there's a tie (of date), take the first row\n\n…bây giờ sẽ được viết như thế này:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% # group rows by hospital\n  slice_max(\n    date,                # keep row per group with maximum date value \n    n = 1,               # keep only the single highest row \n    with_ties = F)       # if there's a tie (of date), take the first row\n\nCode R thường không bị ảnh hưởng bởi thêm các dòng mới hoặc thụt lề. Khi viết code, nếu bạn xuống dòng ngay sau dấu phẩy thì R sẽ tự động thụt lề cho bạn.\nChúng tôi cũng sử dụng rất nhiều những khoảng cách (ví dụ n = 1 thay vì n=1) vì nó giúp dễ đọc hơn. Hãy văn minh với những người đang đọc code của bạn!\n\n\nDanh pháp\nTrong sổ tay này, chúng tôi thường đề cập đến “cột” và “hàng” thay vì dùng “biến” và “quan sát”. Như đã giải thích trong phần sơ lược về “tidy data”, hầu hết các bộ dữ liệu thống kê dịch tễ học bao gồm các hàng, cột và giá trị theo cấu trúc\nBiến số chứa các giá trị đo lường của cùng một thuộc tính (như nhóm tuổi, kết cục hoặc ngày khởi phát). Các quan sát bao gồm tất cả các giá trị được đo trên cùng một đơn vị (ví dụ: người, địa điểm hoặc mẫu phòng thí nghiệm). Vì vậy, những khía cạnh này có thể khó được định nghĩa một cách cụ thể.\nTrong một bộ dữ liệu “tidy”, mỗi cột là một biến số, mỗi hàng là một quan sát và mỗi ô là một giá trị duy nhất. Tuy nhiên, bạn có thể gặp một số bộ dữ liệu không phù hợp với quy luật này - bộ dữ liệu định dạng “ngang” có thể có một biến số được chia thành nhiều cột (xem ví dụ trong chương Pivoting dữ liệu). Tương tự như vậy, các quan sát có thể được trải thành nhiều hàng.\nPhần lớn cuốn sách này tập trung vào quản lý và biến đổi dữ liệu, vì vậy việc đề cập đến cấu trúc dữ liệu cụ thể của các hàng và cột sẽ liên quan hơn là đề cập tới các khái niệm trừu tượng như các quan sát và biến. Các trường hợp ngoại lệ chủ yếu xảy ra trong các chương về phân tích dữ liệu, ở đó chúng tôi đề cập nhiều hơn đến các biến số và quan sát.\n\n\nLưu ý\nDưới đây là một vài lưu ý bạn có thể gặp trong cuốn sách:\nGHI CHÚ: Đây là ghi chú\nMẸO: Đây là mẹo.\nCẨN TRỌNG: Đây là ghi chú cẩn trọng.\nNGUY HIỂM: Đây là một cảnh báo.",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html#quyết-định-biên-tập",
    "href": "new_pages/editorial_style.vn.html#quyết-định-biên-tập",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "1.2 Quyết định biên tập",
    "text": "1.2 Quyết định biên tập\nDưới đây, chúng tôi ghi lại các quyết định biên tập quan trọng về việc lựa chọn package và hàm. Nếu bạn không đồng ý hoặc muốn đưa ra một công cụ mới để xem xét, vui lòng tham gia/bắt đầu cuộc thảo luận trên Trang Github của chúng tôi.\nBảng các package, hàm, và các quyết định biên tập khác\n\n\n\n\n\n\n\n\n\n\nChủ đề\nCân nhắc\nLựa chọn\nLý do ngắn gọn\n\n\n\n\n\nPhương pháp code chung\ntidyverse, data.table, base\ntidyverse, với 1 chương về data.table, các giải pháp thay thế từ base R cho người đọc không có internet | tidyverse dễ đọc, phổ biến, được dạy nhiều nhất\n\n\nGọi Package\nlibrary(),install.packages(), require(), pacman\npacman\nRút ngắn và đơn giản hóa code cho hầu hết các trường hợp cài đặt / tải nhiều package\n\n\n\nNhập và xuất\nrio, và các package khác\nrio\nDễ dàng cho nhiều kiểu file\n\n\n\nNhóm để tổng hợp thống kê\ndplyr group_by(), stats aggregate()\ndplyr group_by()\nThống nhất với tidyverse\n\n\n\nPivoting\ntidyr (các hàm pivot), reshape2 (melt/cast), tidyr (spread/gather)\ntidyr (các hàm pivot)\nreshape2 đã nghỉ hưu tidyr sử dụng các hàm pivot ở phiên bản v1.0.0\n\n\n\nLàm sạch tên cột\nlinelist, janitor\njanitor\nHợp nhất các package được nhắc đến\n\n\n\nEpiweeks\nlubridate, aweek, tsibble, zoo\nthông thường là lubridate ,các package khác tùy trường hợp cụ thể | lubridate dễ đọc, có tính nhất quán, và triển vọng bảo trì gói |\n\n\nNhãn ggplot\nlabs(), ggtitle()/ylab()/xlab()\nlabs()\ntất cả các nhãn ở một nơi, đơn giản\n\n\n\nChuyển sang factor\nfactor(), forcats\nforcats\ncác hàm khác nhau của nó cũng chuyển đổi thành factor trong cùng một lệnh\n\n\n\nĐường cong dịch bệnh\nincidence, ggplot2, EpiCurve\nincidence2 thì nhanh, ggplot2 thì chi tiết\ntùy theo\n\n\n\nSự kết hợp\npaste(), paste0(), str_glue(), glue()\nstr_glue()\nNhiều cú pháp đơn giản hơn hàm paste; nằm bên trong stringr",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html#các-bản-sửa-đổi-chính",
    "href": "new_pages/editorial_style.vn.html#các-bản-sửa-đổi-chính",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "1.3 Các bản sửa đổi chính",
    "text": "1.3 Các bản sửa đổi chính\n\n\n\nNgày\nThay đổi chính\n\n\n\n\n10 Tháng Năm 2021\nPhát hành phiên bản 1.0.0",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html#thông-tin-phiên-làm-việc-r-rstudio-packages",
    "href": "new_pages/editorial_style.vn.html#thông-tin-phiên-làm-việc-r-rstudio-packages",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "1.4 Thông tin phiên làm việc (R, RStudio, packages)",
    "text": "1.4 Thông tin phiên làm việc (R, RStudio, packages)\nDưới đây là thông tin về các phiên bản của các R package, RStudio và R được sử dụng trong quá trình rendering cuốn sách này.\n\nsessioninfo::session_info()\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       Ubuntu 22.04.4 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  C.UTF-8\n ctype    C.UTF-8\n tz       UTC\n date     2024-06-22\n pandoc   3.1.11 @ /opt/hostedtoolcache/pandoc/3.1.11/x64/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P BiocManager   1.30.22 2023-08-08 [?] CRAN (R 4.3.2)\n P cli           3.6.2   2023-12-11 [?] CRAN (R 4.3.2)\n P digest        0.6.35  2024-03-11 [?] CRAN (R 4.3.2)\n P evaluate      0.23    2023-11-01 [?] CRAN (R 4.3.2)\n P fastmap       1.1.1   2023-02-24 [?] CRAN (R 4.3.2)\n P htmltools     0.5.8   2024-03-25 [?] CRAN (R 4.3.2)\n P htmlwidgets   1.6.4   2023-12-06 [?] CRAN (R 4.3.2)\n P jsonlite      1.8.8   2023-12-04 [?] CRAN (R 4.3.2)\n P knitr         1.45    2023-10-30 [?] CRAN (R 4.3.2)\n   renv          1.0.5   2024-02-29 [1] CRAN (R 4.3.2)\n P rlang         1.1.3   2024-01-10 [?] CRAN (R 4.3.2)\n P rmarkdown     2.26    2024-03-05 [?] CRAN (R 4.3.2)\n P sessioninfo   1.2.2   2021-12-06 [?] CRAN (R 4.3.2)\n P xfun          0.43    2024-03-25 [?] CRAN (R 4.3.2)\n P yaml          2.3.8   2023-12-11 [?] CRAN (R 4.3.2)\n\n [1] /tmp/RtmpEI3pJ7/file26bd3af0489a/renv/library/R-4.3/x86_64-pc-linux-gnu\n [2] /home/runner/.cache/R/renv/sandbox/R-4.3/x86_64-pc-linux-gnu/95f1b021\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.vn.html",
    "href": "new_pages/data_used.vn.html",
    "title": "2  Tải sách và dữ liệu",
    "section": "",
    "text": "2.1 Tải sách ngoại tuyến\nBạn có thể tải xuống phiên bản ngoại tuyến của sổ tay này dưới dạng tệp HTML để có thể xem trong trình duyệt web của mình ngay cả khi bạn không có kết nối internet. Nếu bạn đang cân nhắc việc sử dụng ngoại tuyến Sổ tay Epi R, dưới đây là một số điều bạn cần cân nhắc:\nCó hai cách bạn có thể tải xuống sổ tay:",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tải sách và dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.vn.html#tải-sách-ngoại-tuyến",
    "href": "new_pages/data_used.vn.html#tải-sách-ngoại-tuyến",
    "title": "2  Tải sách và dữ liệu",
    "section": "",
    "text": "Khi bạn mở tệp, có thể mất một đến hai phút để tải các hình ảnh và mục lục\n\nPhiên bản ngoại tuyến có bố cục hơi khác so với phiên bản trực tuyến - là một trang rất dài với Mục lục ở phía bên trái. Để tìm kiếm các cụm từ cụ thể, hãy sử dụng Ctrl + F (Cmd-f)\n\nXem chương Package đề xuất để hỗ trợ bạn cài đặt các R package thích hợp trước khi bạn mất kết nối internet\n\nCài đặt package epirhandbook của chúng tôi trong đó chứa tất cả các dữ liệu minh họa (quy trình cài đặt được mô tả bên dưới)\n\n\n\nSử dụng link download\nĐể truy cập nhanh, nháy phải chuột vào link này và lựa chọn “Save link as”.\nNếu trên máy Mac, hãy sử dụng Cmd + Nhấp chuột. Nếu trên điện thoại di động, hãy bấm và giữ liên kết và chọn “Save link”. Sổ tay sẽ tải xuống thiết bị của bạn. Nếu trên màn hình xuất hiện mã HTML gốc, hãy đảm bảo bạn đã làm đúng theo các hướng dẫn bên trên hoặc thử Phương án 2.\n\n\nSử dụng package của chúng tôi\nChúng tôi cung cấp một R package có tên là epirhandbook. Nó bao gồm một hàm có tên download_book() giúp bạn tải xuống sổ tay này từ kho Github của chúng tôi vào máy tính của bạn.\nPackage này cũng chứa hàm get_data() giúp tải xuống toàn bộ các dữ liệu minh họa vào máy tính của bạn.\nChạy dòng code sau để cài đặt package epirhandbook từ Github repository appliedepi. Đây không phải là package thuộc CRAN, do đó cần sử dụng hàm đặc biệt p_install_gh() để cài đặt nó từ Github.\n\n# install the latest version of the Epi R Handbook package\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nBây giờ, bạn gọi package để sử dụng cho phiên làm việc R hiện tại:\n\n# load the package for use\npacman::p_load(epirhandbook)\n\nTiếp theo, bạn chạy hàm download_book() (phần trong ngoặc bỏ trống) để tải sổ tay vào máy tính của bạn. Nếu bạn sử dụng RStudio, một cửa sổ sẽ xuất hiện cho phép bạn lựa chọn thư mục lưu trữ.\n\n# download the offline handbook to your computer\ndownload_book()",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tải sách và dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.vn.html#tải-dữ-liệu-xuống-để-tiện-theo-dõi",
    "href": "new_pages/data_used.vn.html#tải-dữ-liệu-xuống-để-tiện-theo-dõi",
    "title": "2  Tải sách và dữ liệu",
    "section": "2.2 Tải dữ liệu xuống để tiện theo dõi",
    "text": "2.2 Tải dữ liệu xuống để tiện theo dõi\nĐể “tiện theo dõi” cùng với sổ tay này, bạn có thể tải xuống các bộ dữ liệu minh họa và các kết quả.\n\nSử dụng package của chúng tôi\nCách dễ nhất để tải xuống tất cả dữ liệu là cài đặt package epirhandbook của chúng tôi. Nó chứa hàm get_data() giúp lưu toàn bộ dữ liệu minh họa vào một thư mục bạn chọn trên máy tính của mình.\nĐể cài đặt package epirhandbook, bạn chạy theo code dưới đây. Lưu ý là package này không từ CRAN, do đó cần sử dụng hàm p_install_gh() để cài đặt. Thông tin đầu vào sẽ được chuyển tới trang Github của chúng tôi (“appliedepi”) và package epirhandbook.\n\n# install the latest version of the Epi R Handbook package\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nBây giờ, bạn gọi package để sử dụng cho phiên làm việc hiện tại:\n\n# load the package for use\npacman::p_load(epirhandbook)\n\nTiếp theo, sử dụng hàm get_data() trong package để tải dữ liệu minh họa và máy tính của bạn. Chạy hàm get_data(\"all\") để tải toàn bộ dữ liệu minh họa, hoặc bạn có thể nêu tên một tệp cụ thể và phần mở rộng bên trong dấu ngoặc kép để tải một tệp duy nhất.\nDữ liệu sẽ được tải xuống cùng với package và bạn đơn giản chỉ cần lưu nó vào một thư mục trên máy tính của bạn. Một cửa sổ sẽ xuất hiện, cho phép bạn chọn vị trí lưu thư mục. Chúng tôi khuyên bạn nên tạo một thư mục mới tên là “data” vì có khoảng 30 tệp (bao gồm các bộ dữ liệu minh họa và kết quả).\n\n# download all the example data into a folder on your computer\nget_data(\"all\")\n\n# download only the linelist example data into a folder on your computer\nget_data(file = \"linelist_cleaned.rds\")\n\n\n# download a specific file into a folder on your computer\nget_data(\"linelist_cleaned.rds\")\n\nKhi bạn dùng hàm get_data() để lưu tệp dữ liệu vào máy tính của mình, bạn sẽ vẫn cần nhập dữ liệu vào R. Xem chương Nhập xuất dữ liệu để biết thêm chi tiết.\nNếu bạn muốn, bạn có thể xem toàn bộ dữ liệu sử dụng trong cuốn sách này ở thư mục “dữ liệu” trong kho Github của chúng tôi.\n\n\nTải từng thứ một\nTùy chọn này liên quan đến việc tải xuống từng tệp dữ liệu từ kho lưu trữ Github của chúng tôi thông qua liên kết hoặc lệnh R dành riêng cho từng tệp. Một số loại tệp cho phép nút tải xuống, trong khi những loại khác có thể được tải xuống thông qua lệnh R.\n\nDữ liệu linelist\nĐây là số liệu bùng phát Ebola giả định, được nhóm tác giả cẩm nang mở rộng từ bộ dữ liệu thực hành ebola_sim trong package outbreaks.\n\nBấm để tải xuống dữ liệu “thô” linelist (.xlsx). Bộ dữ liệu “thô” là một trang tính Excel với dữ liệu lộn xộn. Sử dụng số liệu này trong chương Làm sạch số liệu và các hàm quan trọng.\nBấm để tải xuống dữ liệu “đã làm sạch” linelist (.rds). Sử dụng tệp này cho tất cả các chương khác trong sổ tay có sử dụng bộ dữ liệu linelist. Tệp mở rộng .rds là một kiểu file của R có khả năng lưu trữ các thông tin cột. Điều này đảm bảo bạn sẽ có ít việc phải làm khi làm sạch số liệu sau khi nhập số liệu vào R.\n\nCác tệp liên quan khác:\n\nBấm để tải xuống dữ liệu “đã làm sạch” linelist dưới dạng tệp Excel\nMột phần của chương làm sạch sử dụng “từ điển làm sạch” (tệp .csv). Bạn có thể tải nó trực tiếp vào R bằng cách chạy các lệnh sau:\n\n\npacman::p_load(rio) # install/load the rio package\n\n# import the file directly from Github\ncleaning_dict &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv\")\n\n\n\nDữ liệu số trường hợp sốt rét\nĐây là số liệu giả định về số lượng trường hợp sốt rét theo nhóm tuổi, cơ sở điều trị và ngày. Tệp mở rộng .rds là một kiểu file của R có khả năng lưu trữ các thông tin cột. Điều này đảm bảo bạn sẽ có ít việc phải làm khi làm sạch số liệu sau khi nhập số liệu vào R.\n Bấm để tải file dữ liệu sốt rét (.rds file) \n\n\nDữ liệu thang đo Likert\nĐây là dữ liệu giả định từ một cuộc khảo sát sử dụng thang đo Likert, được sử dụng trong chương Tháp dân số và thang đo Likert. Bạn có thể tải những dữ liệu này trực tiếp vào R bằng cách chạy các lệnh sau:\n\npacman::p_load(rio) # install/load the rio package\n\n# import the file directly from Github\nlikert_data &lt;- import(\"https://raw.githubusercontent.com/nsbatra/Epi_R_handbook/master/data/likert_data.csv\")\n\n\n\nFlexdashboard\nDưới đây là các liên kết đến tệp được dùng trong chương Dashboards với R Markdown:\n\nĐể tải xuống R Markdown dashboard về một đợt bùng phát dịch, bấm phải chuột vào link này (Cmd+click đối với Mac) và chọn “Save link as”.\n\nĐể tải xuống HTML dashboard, bấm phải chuột vào link này (Cmd+click đối với Mac) và chọn “Save link as”.\n\n\n\nTruy vết tiếp xúc\nChương Truy vết tiếp xúc trình bày phân tích dữ liệu truy vết tiếp xúc, sử dụng dữ liệu minh họa từ Go.Data. Dữ liệu được sử dụng trong chương này có thể được tải xuống dưới dạng tệp .rds bằng cách bấm vào các liên kết sau:\n Bấm để tải xuống dữ liệu điều tra trường hợp (.rds file) \n Bấm để tải xuống dữ liệu ghi nhận tiếp xúc (.rds file) \n Bấm để tải xuống dữ liệu theo dõi liên hệ (.rds file) \nLƯU Ý: Dữ liệu truy vết tiếp xúc có cấu trúc từ phần mềm khác (ví dụ: KoBo, DHIS2 Tracker, CommCare) có thể sẽ khác. Nếu bạn muốn đóng góp dữ liệu hoặc nội dung mẫu thay thế cho trang này, vui lòng liên hệ chúng tôi.\nMẸO: Nếu bạn đang triển khai Go.Data và muốn kết nối với API phiên bản của bạn, vui lòng xem chương Nhập xuất dữ liệu (mục API) và Go.Data Cộng đồng thực hành.\n\n\nGIS\nShapefiles có nhiều tệp thành phần phụ, mỗi tệp có một phần mở rộng tệp khác nhau. Một tệp sẽ có phần mở rộng “.shp”, nhưng những tệp khác có thể là “.dbf”, “.prj”, v.v.\nChương GIS cơ bản cung cấp các liên kết đến trang web Humanitarian Data Exchange, nơi bạn có thể tải xuống trực tiếp các shapefiles dưới dạng tệp nén.\nVí dụ, dữ liệu phân bố của các cơ sở y tế có thể được tải xuống tại đây. Bạn tải tệp “hotosm_sierra_leone_health_facilities_points_shp.zip”. Sau khi được lưu vào máy tính của bạn, hãy “giải nén” thư mục. Bạn sẽ thấy một số tệp có các phần mở rộng khác nhau (ví dụ: “.shp”, “.prj”, “.shx”) - tất cả những tệp này phải được lưu vào cùng một thư mục trên máy tính của bạn. Sau đó, để nhập vào R, hãy cung cấp đường dẫn đến tệp và tên của tệp “.shp” bằng hàm st_read() từ package sf (đã được mô tả trong chương GIS cơ bản).\nNếu bạn làm theo Cách 1 để tải xuống tất cả dữ liệu minh họa (thông qua package epirhandbook của chúng tôi), tất cả các shapefiles đã được bao gồm.\nNgoài ra, bạn có thể tải xuống các shapefiles từ thư mục “data” trên trang R Handbook Github (xem thư mục con “gis”). Tuy nhiên, cần lưu ý rằng bạn sẽ phải tải từng tệp con xuống máy tính của mình. Trong Github, nhấp vào từng tệp riêng lẻ và tải chúng xuống bằng cách nhấp vào nút “Download”. Xem hình minh họa dưới đây, bạn có thể thấy shapefile “sl_adm3” bao gồm nhiều tệp con như thế nào - và mỗi tệp đều cần được tải xuống từ Github.\n\n\n\n\n\n\n\n\n\n\n\nCây phả hệ\nXem chương Cây phả hệ. Tệp có tên Newick về cây phả hệ được xây dựng từ việc giải trình tự toàn bộ bộ gen của 299 mẫu Shigella sonnei và dữ liệu mẫu tương ứng (được chuyển đổi thành tệp văn bản). Các mẫu và kết quả từ nước Bỉ được cung cấp thông qua Trung tâm tham khảo quốc gia về Salmonella và Shigella (NRC Bỉ) trong phạm vi dự án do EUPHEM Fellow của ECDC thực hiện, và cũng sẽ được xuất bản dưới dạng bản thảo. Dữ liệu quốc tế được cung cấp công khai trên cơ sở dữ liệu công cộng (ncbi) và đã được xuất bản trước đó.\n\nĐể tải xuống file cây phả hệ “Shigella_tree.txt”, nhấn chuột phải vào link này (Cmd+click đối với Mac) và chọn “Save link as”.\n\nĐể tải xuống file “sample_data_Shigella_tree.csv” với thông tin bổ sung cho từng mẫu, nhấn chuột phải vào link này (Cmd+click đối với Mac) và chọn “Save link as”.\n\nĐể xem subset-tree mới được tạo, nhấn chuột phải vào link này (Cmd+click đối với Mac) và chọn “Save link as”. Tệp .txt sẽ được tải xuống máy tính của bạn.\n\nSau đó bạn có thể nhập tệp .txt files bằng hàm read.tree() từ ape package, như đã được trình bày trong chương này.\n\nape::read.tree(\"Shigella_tree.txt\")\n\n\n\nChuẩn hóa\nXem trong chương Tỷ lệ chuẩn hóa. Bạn có thể tải dữ liệu trực tiếp từ kho lưu trữ Github của chúng tôi trên internet vào phiên làm việc R của bạn bằng các lệnh sau :\n\n# install/load the rio package\npacman::p_load(rio) \n\n##############\n# Country A\n##############\n# import demographics for country A directly from Github\nA_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# import deaths for country A directly from Github\nA_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n##############\n# Country B\n##############\n# import demographics for country B directly from Github\nB_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# import deaths for country B directly from Github\nB_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n\n###############\n# Reference Pop\n###############\n# import demographics for country B directly from Github\nstandard_pop_data &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n\n\n\nChuỗi thời gian và phát hiện ổ dịch\nXem trong chương Chuỗi thời gian và phát hiện ổ dịch. Chúng tôi sử dụng các trường hợp campylobacter được báo cáo ở Đức từ 2002-2011, có sẵn từ package surveillance của R. (lưu ý. tập dữ liệu này đã được điều chỉnh từ bản gốc, trong đó 3 tháng dữ liệu cuối năm 2011 đã bị xóa để dùng với mục đích minh họa)\n Bấm để tải xuống dữ liệu Campylobacter ở Đức (.xlsx) \nChúng tôi cũng sử dụng dữ liệu khí hậu ở Đức từ 2002-2011 (nhiệt độ tính bằng độ C và lượng mưa tính bằng milimet). Dữ liệu được tải xuống từ tập dữ liệu phân tích vệ tinh Copernicus của EU bằng cách sử dụng package ecmwfr . Bạn sẽ cần tải xuống tất cả những thứ này và nhập chúng vào R bằng hàm stars::read_stars() như đã được giải thích trong chương chuỗi thời gian.\n Bấm để tải dữ liệu thời tiết ở Đức 2002 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2003 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2004 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2005 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2006 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2007 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2008 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2009 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2010 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2011 (.nc file) \n\n\nPhân tích sống còn\nĐối với chương phân tích sống còn, chúng tôi sử dụng dữ liệu khảo sát tử vong giả định dựa trên mẫu khảo sát của MSF OCA. Dữ liệu giả định này là một phần của Dự án “R4Epis”.\n Bấm để tài xuống dữ liệu khảo sát giả định (.xlsx) \n Bấm để tài xuống từ điển dữ liệu khảo sát giả định (.xlsx) \n Bấm để tài xuống dữ liệu khảo sát quần thể giả định (.xlsx) \n\n\nShiny\nChương Dashboards với Shiny trình diễn việc xây dựng một ứng dụng đơn giản để hiển thị dữ liệu bệnh sốt rét.\nĐể tải xuống các tệp R dùng để tạo thành ứng dụng Shiny:\nBạn có thể  bấm vào đây để tải xuống tệp app.R trong đó chứa code của cả UI và Server của ứng dụng Shiny.\nBạn có thể  bấm vào đây để tải tệp facility_count_data.rds có chứa dữ liệu sốt rét cho ứng dụng Shiny. Lưu ý rằng bạn có thể cần phải lưu trữ nó trong thư mục “data” để các đường dẫn tệp here () hoạt động chính xác.\nBạn có thể  bấm vào đây để tải tệp global.R mà sẽ được chạy trước khi mở ứng dụng, như đã được giải thích trong chương.\nBạn có thể  bấm vào đây để tải tệp plot_epicurve.R có nguồn từ tệp global.R. Lưu ý rằng bạn có thể cần phải lưu trữ nó trong thư mục “funcs” để các đường dẫn tệp here () hoạt động chính xác.",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tải sách và dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html",
    "href": "new_pages/transition_to_R.vn.html",
    "title": "3  Chuyển đổi sang R",
    "section": "",
    "text": "3.1 Từ Excel\nChuyển đổi từ Excel trực tiếp sang R hoàn toàn là mục tiêu có thể đạt được. Nó dường như có vẻ khó khăn, nhưng bạn có thể làm được!\nSự thật là một người có kỹ năng Excel tốt có thể thực hiện các thao tác nâng cao chỉ trong Excel - ngay cả khi sử dụng các công cụ tạo script như VBA. Excel được sử dụng trên toàn thế giới và là một công cụ cần thiết cho một nhà dịch tễ học. Tuy nhiên, kết hợp nó với R có thể cải thiện và mở rộng đáng kể quy trình công việc của bạn.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html#từ-excel",
    "href": "new_pages/transition_to_R.vn.html#từ-excel",
    "title": "3  Chuyển đổi sang R",
    "section": "",
    "text": "Lợi ích\nBạn sẽ thấy rằng việc sử dụng R mang lại những lợi ích to lớn trong việc tiết kiệm thời gian, giúp phân tích nhất quán và chính xác hơn, có khả năng tái lập, khả năng chia sẻ và sửa lỗi nhanh hơn. Giống như bất kỳ phần mềm mới nào, bạn phải đầu tư một “đường cong” thời gian học tập để trở nên quen thuộc. Bạn sẽ được mở ra những kĩ năng mới trên một phạm vi rộng đáng kể với R.\nExcel là một phần mềm phổ biến mà người dùng mới bắt đầu có thể dễ dàng sử dụng để tạo ra các phân tích và sơ đồ hóa đơn giản với các thao tác “trỏ và nhấp”. Trong khi đó, có thể mất vài tuần để trở nên quen thuộc với các chức năng và giao diện của R. Tuy nhiên, R đã phát triển trong những năm gần đây để trở nên thân thiện hơn với người mới bắt đầu.\nNhiều quy trình làm việc của Excel phụ thuộc vào trí nhớ và sự lặp lại - do đó, có nhiều khả năng xảy ra lỗi. Hơn nữa, nhìn chung, việc làm sạch dữ liệu, phương pháp phân tích và các phương trình được sử dụng đều bị ẩn đi trong trang tính. Có thể cần đến một khoảng thời gian đáng kể để những người mới bắt đầu hiểu trang tính Excel đang làm gì và cách khắc phục sự cố. Với R, tất cả các bước được viết rõ ràng trong script và có thể dễ dàng xem, chỉnh sửa, sửa lỗi và áp dụng cho các bộ dữ liệu khác.\nĐể bắt đầu chuyển đổi từ Excel sang R, bạn phải điều chỉnh tư duy của mình theo một số hướng quan trọng:\n\n\nTidy data\nSử dụng “tidy” data để máy có thể đọc được thay vì dữ liệu lộn xộn “con người có thể đọc được”. Dưới đây là ba yêu cầu chính đối với “tidy” data”, đã được giải thích trong hướng dẫn này về “tidy” data trong R:\n\nMỗi biến số nằm trên một cột\nMỗi quan sát phải nằm trên một hàng\nMỗi giá trị phải có ô riêng\n\nĐối với người dùng Excel - hãy nghĩ đến vai trò của “bảng” Excel trong việc chuẩn hóa dữ liệu và làm cho định dạng trở nên dễ đoán hơn.\nMột ví dụ về “tidy” data là trường hợp bộ dữ liệu linelist được sử dụng trong cuốn sổ tay này - mỗi biến được chứa trong một cột, mỗi quan sát (mỗi trường hợp) có hàng riêng và mọi giá trị chỉ nằm trong một ô. Dưới đây, bạn có thể xem 50 hàng đầu tiên của bộ dữ liệu linelist:\n\n\n\n\n\n\nNguyên nhân chính khiến người dùng gặp phải tình trạng non-tidy data là do nhiều bảng tính Excel được thiết kế để ưu tiên con người dễ đọc chứ không phải máy móc/phần mềm dễ đọc.\nĐể giúp bạn thấy sự khác biệt, dưới đây là một số ví dụ mô phỏng về non-tidy data mà ưu tiên khả năng đọc của con người hơn khả năng đọc của máy:\n\n\n\n\n\n\n\n\n\nVấn đề: Trong bảng tính ở trên, một số ô đã được ghép với nhau - khiến chúng trở nên khó đọc bởi R. Hàng nào nên được coi là “tiêu đề” không rõ ràng. Từ điển dựa trên màu sắc nằm ở phía bên phải và các giá trị ô được biểu thị bằng màu sắc - điều này cũng không dễ dàng được giải thích bởi R (cũng như những người bị mù màu!). Hơn nữa, các phần thông tin khác nhau được kết hợp thành một ô (nhiều tổ chức đối tác hoạt động trong cùng một khu hoặc trạng thái “TBC” trong cùng ô với “Partner D”).\n\n\n\n\n\n\n\n\n\nVấn đề: Trong bảng tính ở trên, có rất nhiều hàng và cột trống trong bộ dữ liệu - điều này sẽ gây phiền toái khi làm sạch trong R. Hơn nữa, tọa độ GPS được trải rộng trên hai hàng cho một trung tâm điều trị nhất định. Một lưu ý nhỏ - tọa độ GPS có hai định dạng khác nhau!\nCác bộ dữ liệu “tidy” có thể không đọc được bằng mắt người, nhưng chúng giúp việc làm sạch và phân tích dữ liệu dễ dàng hơn rất nhiều! Tidy data có thể được lưu trữ ở nhiều định dạng khác nhau, chẳng hạn như dạng “dọc” hoặc “ngang”“(xem chương về Xoay trục dữ liệu), tuy nhiên các nguyên tắc trên vẫn được tuân thủ.\n\n\nHàm\nTừ “hàm (function)” trong R có thể mới, nhưng khái niệm này cũng tồn tại trong Excel dưới dạng công thức (formulas). Công thức trong Excel cũng yêu cầu cú pháp chính xác (ví dụ: vị trí của dấu chấm phẩy và dấu ngoặc đơn). Tất cả những gì bạn cần làm là tìm hiểu một vài hàm mới và cách chúng hoạt động cùng nhau trong R.\n\n\nScript\nThay vì nhấp vào các biểu tượng và kéo các ô, bạn sẽ viết mọi bước và quy trình thành một “script”. Người dùng Excel có thể quen thuộc với “VBA macros”, thứ mà cũng sử dụng cách tiếp cận script.\nR script bao gồm các hướng dẫn từng bước. Điều này cho phép bất kỳ đồng nghiệp nào cũng có thể đọc script và dễ dàng xem các bước bạn đã thực hiện. Điều này cũng giúp loại bỏ lỗi hoặc các tính toán không chính xác. Xem phần R cơ bản về script để có thêm các ví dụ.\nDưới đây là một ví dụ của một R script:\n\n\n\n\n\n\n\n\n\n\n\nTài liệu liên quan đến chuyển đổi từ Excel-sang-R\nDưới đây là một vài đường link hướng dẫn giúp bạn chuyển đổi sang R từ Excel:\n\nR vs. Excel\n\nCác khóa RStudio trong R cho người dùng Excel\n\n\n\nTương tác giữa R và Excel\nR có khả năng mạnh trong việc nhập các Excel workbook, làm việc với dữ liệu, xuất/lưu tệp Excel và làm việc với các sắc thái của các trang tính Excel.\nĐúng là một số định dạng Excel có tính thẩm mỹ hơn có thể bị mất trong quá trình chuyển đổi (ví dụ: chữ nghiêng, chữ nằm ngang, v.v.). Nếu quy trình công việc của bạn yêu cầu chuyển tài liệu qua lại giữa R và Excel trong khi vẫn giữ nguyên định dạng Excel ban đầu, hãy thử các package như openxlsx.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html#từ-stata",
    "href": "new_pages/transition_to_R.vn.html#từ-stata",
    "title": "3  Chuyển đổi sang R",
    "section": "3.2 Từ Stata",
    "text": "3.2 Từ Stata\nChuyển đến R từ Stata\nNhiều nhà dịch tễ học được dạy cách sử dụng Stata ngay từ đầu, và có vẻ khó khăn khi chuyển sang R. Tuy nhiên, nếu bạn là một người dùng quen Stata thì việc chuyển sang R chắc chắn sẽ dễ quản lý hơn bạn nghĩ. Mặc dù có một số khác biệt chính giữa Stata và R về cách tạo và sửa đổi dữ liệu, cũng như cách triển khai các chức năng phân tích – sau khi tìm hiểu những khác biệt chính này, bạn sẽ có thể chuyển đổi các kỹ năng của mình.\nDưới đây là một số cách chuyển đổi chính giữa Stata và R, điều mà có thể hữu ích khi bạn xem lại hướng dẫn này.\nNhững lưu ý chung\n\n\n\n4 STATA\nBạn chỉ có thể xem và thao tác với một bộ dữ liệu tại một thời điểm\n5 R\nBạn có thể xem và thao tác với nhiều bộ dữ liệu cùng một lúc, do đó, bạn sẽ thường xuyên phải xác định bộ dữ liệu của mình trong code\n\n\n\n\n\n\n\n\nCộng đồng trực tuyến có sẵn trên https://www.statalist.org/\nCộng đồng trực tuyến có sẵn trên RStudio, StackOverFlow và R-bloggers\n\n\n\nThao tác trỏ và nhấp chuột như một tùy chọn\nThao tác trỏ và nhấp chuột được giảm tối thiểu\n\n\n\nTrợ giúp cho các lệnh có sẵn trong help [command]\nTrợ giúp có sẵn trong [function]? hoặc tìm kiếm trong cửa sổ Help\n\n\n\nBình luận code sử dụng * hoặc /// hoặc /* VĂN BẢN */\nBình luận code sử dụng #\n\n\n\nHầu hết tất cả các lệnh đều được tích hợp sẵn trong Stata. Các lệnh mới do người dùng viết có thể được cài đặt như file ado sử dụng ssc install [package]\nR được cài đặt sẵn các lệnh cơ bản, nhưng quá trình sử dụng thông thường cần cài đặt các package khác từ CRAN (xem chương R cơ bản)\n\n\n\nPhân tích thường được viết trong do file\nPhân tích được viết trong R script ở cửa sổ chính của RStudio. Các script của R markdown là một giải pháp thay thế.\n\n\n\n\nThư mục làm việc\n\n\n\n6 STATA\nThư mục làm việc bao gồm các đường dẫn tuyệt đối (Ví dụ: “C:/usename/documents/projects/data/”)\n\nR | =============================================================================================================================================================+ Thư mục làm việc có thể là đường dẫn tuyệt đối hoặc tương đối đến thư mục gốc của dự án bằng cách sử dụng package here (xem chương Nhập xuất dữ liệu)\n\n\n\n\n\n\n\n\nXem thư mục làm việc hiện tại với pwd\nSử dụng getwd() hoặc here() (nếu sử dụng package here), với dấu ngoặc đơn trống\n\n\n\nCài đặt thư mục làm việc với cd “folder location”\nSử dụng setwd(“folder location”) hoặc set_here(\"folder location) (nếu sử dụng package here)\n\n\n\n\nNhập và xem dữ liệu\n\n\n\n7 STATA\nCác lệnh cụ thể cho mỗi loại tệp\nR | =================================================================================================================================================================================================================+ Sử dụng import() từ package rio cho hầu hết tất cả các loại tệp. Các chức năng cụ thể tồn tại dưới dạng lựa chọn thay thế (xem chương Nhập xuất dữ liệu)\n\n\n\n\n\n\n\n\nĐọc file csv được thực hiện bằng cách sử dụng import delimited “filename.csv”\nSử dụng import(\"filename.csv\")\n\n\n\nĐọc file xslx được thực hiện bằng cách sử dụng import excel “filename.xlsx”\nSử dụng import(\"filename.xlsx\")\n\n\n\nDuyệt dữ liệu của bạn trong một cửa sổ mới bằng lệnh browse\nXem bộ dữ liệu trong cửa sổ nguồn RStudio sử dụng View(dataset). Bạn cần xác định tên bộ dữ liệu của mình cho hàm trong R vì nhiều bộ dữ liệu có thể được mở cùng một lúc. Lưu ý viết hoa “V” trong hàm này\n\n\n\nCó cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng summarize, lệnh này cung cấp tên biến và các thông tin cơ bản của bộ dữ liệu\nCó cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng summary(dataset)\n\n\n\n\nThao tác dữ liệu cơ bản\n\n\n\n8 STATA\nCác cột của bộ dữ liệu thường được gọi là “các biến (variables)”\n9 R\nThường được gọi là “các cột (columns)” hoặc thỉnh thoảng là “các véctơ (vectors)” hoặc “các biến (variables)”\n\n\n\n\n\n\n\n\nKhông cần xác định bộ dữ liệu\nTrong mỗi lệnh dưới đây, bạn cần xác định bộ dữ liệu - xem ví dụ trong chương Làm sạch số liệu và các hàm quan trọng\n\n\n\nCác biến mới được tạo bằng lệnh generate varname =\nTạo các biến mới bằng cách sử dụng lệnh mutate(varname = ). Xem chương Làm sạch số liệu và các hàm quan trọng để biết tất cả chi tiết về câu lệnh dplyr bên dưới\n\n\n\nCác biến được đổi tên bằng cách sử dụng rename old_name new_name\nCác cột có thể được đổi tên bằng cách sử dụng lệnh rename(new_name = old_name)\n\n\n\nCác biến được lược bỏ sử dụng drop varname\nCó thể lược bỏ các cột bằng cách sử dụng lệnh select() với tên cột trong ngoặc đơn sau dấu trừ\n\n\n\nCác biến factor có thể được gán nhãn bằng cách sử dụng một loạt lệnh như label define\nViệc gán nhãn các giá trị có thể được thực hiện bằng cách chuyển đổi cột thành nhóm Factor và chỉ định thứ bậc. Xem chương Factors. Tên cột thường không được gán nhãn như trong Stata. |\n\n\n\n\nPhân tích mô tả\n\n\n\n10 STATA\nĐếm số lượng bảng của một biến sử dụng tab varname\nR | ======================================================================================================================================================================================================+ Cung cấp bộ dữ liệu và tên cột cho table() ví dụ như table(dataset$colname). Ngoài ra, có thể sử dụng lệnh count(varname) từ package dplyr, đã được giải thích trong chương Nhóm dữ liệu\n\n\n\n\n\n\n\n\nLập bảng chéo của hai biến trong bảng 2x2 được thực hiện bằng tab varname1 varname2\nSử dụng table(dataset$varname1, dataset$varname2 hoặc count(varname1, varname2)\n\n\n\n\nMặc dù danh sách này cung cấp một cái nhìn tổng quan về những điều cơ bản trong việc chuyển các lệnh Stata sang R, nhưng nó vẫn chưa đầy đủ. Bạn có thể quan tâm tới nhiều nguồn tài nguyên tuyệt vời khác dành cho người dùng Stata chuyển sang R:\n\nhttps://dss.princeton.edu/training/RStata.pdf\nhttps://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.html\nhttp://r4stats.com/books/r4stata/",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html#từ-sas",
    "href": "new_pages/transition_to_R.vn.html#từ-sas",
    "title": "3  Chuyển đổi sang R",
    "section": "10.1 Từ SAS",
    "text": "10.1 Từ SAS\nChuyển từ SAS sang R\nSAS thường được sử dụng tại các cơ quan y tế công cộng và các lĩnh vực nghiên cứu học thuật. Mặc dù chuyển đổi sang một ngôn ngữ mới hiếm khi là một quá trình đơn giản, nhưng hiểu được những điểm khác biệt chính giữa SAS và R có thể giúp bạn bắt đầu chuyển hướng ngôn ngữ mới bằng ngôn ngữ mẹ đẻ của mình. Dưới đây là phác thảo các bước chuyển đổi chính trong quản lý dữ liệu và phân tích mô tả giữa SAS và R.\nNhững lưu ý chung\n\n\n\n11 SAS\nCộng đồng trực tuyến có sẵn trên SAS Customer Support\n12 R\nCộng đồng trực tuyến có sẵn trên RStudio, StackOverFlow và R-bloggers\n\n\n\n\n\n\n\n\nTrợ giúp cho các lệnh có sẵn trong help [command]\nTrợ giúp có sẵn trong [function]? hoặc tìm kiếm trong cửa sổ Help\n\n\n\nBình luận code sử dụng * VĂN BẢN ; hoặc /* VĂN BẢN */\nBình luận code sử dụng #\n\n\n\nHầu hết tất cả các lệnh đều được tích hợp sẵn. Người dùng có thể viết lệnh mới bằng cách sử dụng SAS macro, SAS/IML, SAS Component Language (SCL) và mới đây nhất là, được thực hiện bằng Proc Fcmp và Proc Proto\nR được cài đặt sẵn các lệnh **cơ bản**, nhưng quá trình sử dụng thông thường cần cài đặt các package khác từ CRAN (xem chương R cơ bản)\n\n\n\nPhân tích thường được viết trong chương trình SAS ở cửa sổ Editor.\nPhân tích được viết trong R script trong cửa sổ chính của RStudio. Các script của R markdown là một giải pháp thay thế.\n\n\n\n\nThư mục làm việc\n\n\n\n13 SAS\nThư mục làm việc có thể là đường dẫn tuyệt đối hoặc tương đối đến thư mục gốc của dự án bằng cách sử dụng %let rootdir=/root path; %include “&rootdir/subfoldername/filename”\nR | =============================================================================================================================================================+ Thư mục làm việc có thể là đường dẫn tuyệt đối hoặc tương đối đến thư mục gốc của dự án bằng cách sử dụng package here (xem chương Nhập xuất dữ liệu)\n\n\n\n\n\n\n\n\nXem thư mục làm việc hiện tại với %put %sysfunc(getoption(work));\nSử dụng getwd() hoặc here() (nếu sử dụng package here), với dấu ngoặc đơn trống\n\n\n\nCài đặt thư mục làm việc với libname “folder location”\nSử dụng setwd(“folder location”) hoặc set_here(\"folder location) (nếu sử dụng package here)\n\n\n\n\nNhập và xem dữ liệu\n\n\n\n14 SAS\nSử dụng lệnh Proc Import hoặc sử dụng lệnh Data Step Infile\nR | =============================================================================================================================================================================================================+ Sử dụng import() từ package rio cho hầu hết tất cả các loại tệp. Các chức năng cụ thể tồn tại dưới dạng lựa chọn thay thế (xem chương Nhập xuất dữ liệu)\n\n\n\n\n\n\n\n\nĐọc file csv được thực hiện bằng cách sử dụng Proc Import datafile=”filename.csv” out=work.filename dbms=CSV; run; HOẶC sử dụng Data Step Infile statement\nSử dụng import(\"filename.csv\")\n\n\n\nĐọc các tệp xslx được thực hiện bằng cách sử dụng Proc Import datafile=”filename.xlsx” out=work.filename dbms=xlsx; run; HOẶC sử dụng Data Step Infile statement\nSử dụng import(\"filename.xlsx\")\n\n\n\nDuyệt bộ dữ liệu của bạn trong cửa sổ mới bằng cách mở cửa sổ Explorer và chọn thư viện và tập dữ liệu mong muốn.\nXem bộ dữ liệu trong cửa sổ nguồn RStudio sử dụng View(dataset). Bạn cần xác định tên bộ dữ liệu của mình cho hàm trong R vì nhiều bộ dữ liệu có thể được mở cùng một lúc. Lưu ý viết hóa “V” trong hàm này |\n\n\n\n\nThao tác dữ liệu cơ bản\n\n\n\n15 SAS\nCác cột của bộ dữ liệu thường được gọi là “các biến (variables)”\n16 R\nThường được gọi là “các cột (columns)” hoặc thỉnh thoảng là “các véctơ (vectors)” hoặc “các biến (variables)”\n\n\n\n\n\n\n\n\nKhông cần thao tác đặc biệt để tạo ra một biến. Các biến mới được tạo đơn giản bằng cách nhập tên biến mới, theo sau là dấu bằng, sau đó là biểu thức cho giá trị\nTạo các biến mới bằng cách sử dụng hàm mutate(varname = ). Xem chương Làm sạch số liệu và các hàm quan trọng để biết tất cả chi tiết về câu lệnh dplyr bên dưới\n\n\n\nCác biến được đổi tên bằng cách sử dụng rename *old_name=new_name*\nCác cột có thể được đổi tên bằng cách sử dụng ệnh rename(new_name = old_name)\n\n\n\nCác biến được giữ bằng cách sử dụng **keep**=varname\nCác cột có thể được chọn bằng cách sử dụng lệnh select() với tên cột trong ngoặc đơn\n\n\n\nCác biến được lược bỏ sử dụng **drop**=varname\nCó thể lược bỏ các cột bằng cách sử dụng lệnh select() với tên cột trong ngoặc đơn sau dấu trừ\n\n\n\nCác biến Factor có thể được gán nhãn trong Data Step bằng cách sử dụng lệnh Label\nViệc gán nhãn các giá trị có thể được thực hiện bằng cách chuyển đổi cột thành nhóm Factor và chỉ định thứ bậc. Xem chương Factors. Tên cột thường không được gán nhãn. |\n\n\n\nCác bản ghi được chọn bằng cách sử dụng lệnh Where hoặc If trong Data Step. Nhiều điều kiện lựa chọn được phân tách bằng lệnh “and”.\nCác bản ghi được chọn bằng cách sử dụng lệnh filter() với nhiều điều kiện lựa chọn được phân tách bằng toán tử AND (&) hoặc dấu phẩy\n\n\n\nBộ dữ liệu được hợp nhất bằng cách sử dụng lệnh Merge trong Data Step. Các bộ dữ liệu được hợp nhất cần phải được sắp xếp trước bằng cách sử dụng thao tác Proc Sort.\nPackage dplyr cung cấp một số chức năng để hợp nhất các tập dữ liệu. Xem chi tiết trong chương [Nối dữ liệu].\n\n\n\n\nPhân tích mô tả\n\n\n\n17 SAS\nCó cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng thao tác Proc Summary, thao tác mà cung cấp tên biến và các thống kê mô tả\n18 R\nCó cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng summary(dataset) hoặc skim(dataset) từ package skimr package\n\n\n\n\n\n\n\n\nĐếm số lượng bảng của một biến sử dụng proc freq data=Dataset; Tables varname; Run;\nXem chương Bảng mô tả. Các tùy chọn trong số tất cả các tùy chọn khác bao gồm table() từ base R và tabyl() từ package janitor. Lưu ý rằng bạn sẽ cần xác định bộ dữ liệu và tên cột vì R chứa nhiều tập dữ liệu. |\n\n\n\nLập bảng chéo của hai biến trong bảng 2x2 được thực hiện bằng proc freq data=Dataset; Tables rowvar*colvar; Run;\nMột lần nữa, bạn có thể sử dụng table(), tabyl() hoặc những cách khác đã được mô tả trong chương Bảng mô tả.\n\n\n\n\nMột số tài nguyên hữu ích:\nR for SAS and SPSS Users (2011)\nSAS and R, Second Edition (2014)",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html#khả-năng-tương-tác-dữ-liệu",
    "href": "new_pages/transition_to_R.vn.html#khả-năng-tương-tác-dữ-liệu",
    "title": "3  Chuyển đổi sang R",
    "section": "18.1 Khả năng tương tác dữ liệu",
    "text": "18.1 Khả năng tương tác dữ liệu\nXem chương Nhập xuất dữ liệu để biết chi tiết về cách R package rio có thể nhập và xuất các file như file STATA .dta, file SAS .xpt và .sas7bdat, file SPSS .por và .sav và nhiều file khác.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.vn.html",
    "href": "new_pages/packages_suggested.vn.html",
    "title": "4  Package đề xuất",
    "section": "",
    "text": "4.1 Packages từ CRAN\n##########################################\n# List of useful epidemiology R packages #\n##########################################\n\n# This script uses the p_load() function from pacman R package, \n# which installs if package is absent, and loads for use if already installed\n\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Packages available from CRAN\n##############################\npacman::p_load(\n     \n     # learning R\n     ############\n     learnr,   # interactive tutorials in RStudio Tutorial pane\n     swirl,    # interactive tutorials in R console\n        \n     # project and file management\n     #############################\n     here,     # file paths relative to R project root folder\n     rio,      # import/export of many types of data\n     openxlsx, # import/export of multi-sheet Excel workbooks \n     \n     # package install and management\n     ################################\n     pacman,   # package install/load\n     renv,     # managing versions of packages when working in collaborative groups\n     remotes,  # install from github\n     \n     # General data management\n     #########################\n     tidyverse,    # includes many packages for tidy data wrangling and presentation\n          #dplyr,      # data management\n          #tidyr,      # data management\n          #ggplot2,    # data visualization\n          #stringr,    # work with strings and characters\n          #forcats,    # work with factors \n          #lubridate,  # work with dates\n          #purrr       # iteration and working with lists\n     linelist,     # cleaning linelists\n     naniar,       # assessing missing data\n     \n     # statistics  \n     ############\n     janitor,      # tables and data cleaning\n     gtsummary,    # making descriptive and statistical tables\n     rstatix,      # quickly run statistical tests and summaries\n     broom,        # tidy up results from regressions\n     lmtest,       # likelihood-ratio tests\n     easystats,\n          # parameters, # alternative to tidy up results from regressions\n          # see,        # alternative to visualise forest plots \n     \n     # epidemic modeling\n     ###################\n     epicontacts,  # Analysing transmission networks\n     EpiNow2,      # Rt estimation\n     EpiEstim,     # Rt estimation\n     projections,  # Incidence projections\n     incidence2,   # Make epicurves and handle incidence data\n     i2extras,     # Extra functions for the incidence2 package\n     epitrix,      # Useful epi functions\n     distcrete,    # Discrete delay distributions\n     \n     \n     # plots - general\n     #################\n     #ggplot2,         # included in tidyverse\n     cowplot,          # combining plots  \n     # patchwork,      # combining plots (alternative)     \n     RColorBrewer,     # color scales\n     ggnewscale,       # to add additional layers of color schemes\n\n     \n     # plots - specific types\n     ########################\n     DiagrammeR,       # diagrams using DOT language\n     incidence2,       # epidemic curves\n     gghighlight,      # highlight a subset\n     ggrepel,          # smart labels\n     plotly,           # interactive graphics\n     gganimate,        # animated graphics \n\n     \n     # gis\n     ######\n     sf,               # to manage spatial data using a Simple Feature format\n     tmap,             # to produce simple maps, works for both interactive and static maps\n     OpenStreetMap,    # to add OSM basemap in ggplot map\n     spdep,            # spatial statistics \n     \n     # routine reports\n     #################\n     rmarkdown,        # produce PDFs, Word Documents, Powerpoints, and HTML files\n     reportfactory,    # auto-organization of R Markdown outputs\n     officer,          # powerpoints\n     \n     # dashboards\n     ############\n     flexdashboard,    # convert an R Markdown script into a dashboard\n     shiny,            # interactive web apps\n     \n     # tables for presentation\n     #########################\n     knitr,            # R Markdown report generation and html tables\n     flextable,        # HTML tables\n     #DT,              # HTML tables (alternative)\n     #gt,              # HTML tables (alternative)\n     #huxtable,        # HTML tables (alternative) \n     \n     # phylogenetics\n     ###############\n     ggtree,           # visualization and annotation of trees\n     ape,              # analysis of phylogenetics and evolution\n     treeio            # to visualize phylogenetic files\n \n)",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Package đề xuất</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.vn.html#packages-từ-github",
    "href": "new_pages/packages_suggested.vn.html#packages-từ-github",
    "title": "4  Package đề xuất",
    "section": "4.2 Packages từ Github",
    "text": "4.2 Packages từ Github\nDưới đây là các lệnh giúp cài đặt trực tiếp packages từ kho lưu trữ trên Github.\n\nPhiên bản phát triển của epicontacts có khả năng tạo cây lây nhiễm với trục x tạm thời\n\nPackage epirhandbook chứa tất cả các dữ liệu minh họa cho sổ tay này và có thể được sử dụng để tải xuống phiên bản ngoại tuyến của sổ tay.\n\n\n# Packages to download from Github (not available on CRAN)\n##########################################################\n\n# Development version of epicontacts (for transmission chains with a time x-axis)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n# The package for this handbook, which includes all the example data  \npacman::p_install_gh(\"appliedepi/epirhandbook\")",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Package đề xuất</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html",
    "href": "new_pages/r_projects.vn.html",
    "title": "5  Dự án R",
    "section": "",
    "text": "5.1 Gợi ý sử dụng\nMột cách phổ biến, hiệu quả và ít rắc rối để sử dụng R là sự kết hợp của 3 thành tố này. Mỗi dự án công việc cụ thể sẽ được lưu trữ trong một dự án R. Từng thành tố được mô tả như dưới đây.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html#gợi-ý-sử-dụng",
    "href": "new_pages/r_projects.vn.html#gợi-ý-sử-dụng",
    "title": "5  Dự án R",
    "section": "",
    "text": "Một Dự án R\n\nMột môi trường làm việc khép kín với các thư mục bao gồm dữ liệu, tập lệnh, các kết quả đầu ra, v.v.\n\n\nPackage here dành cho các đường dẫn tương đối\n\nĐường dẫn tệp được ghi một cách tương đối dẫn đến thư mục gốc của dự án R - xem chương Nhập xuất dữ liệu để biết thêm chi tiết\n\n\nPackage rio để nhập/xuất\n\nimport() và export() giúp giải quyết tất cả các tệp với phần mở rộng khác nhau (ví dụ: .csv, .xlsx, .png)",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html#tạo-một-dự-án-r",
    "href": "new_pages/r_projects.vn.html#tạo-một-dự-án-r",
    "title": "5  Dự án R",
    "section": "5.2 Tạo một dự án R",
    "text": "5.2 Tạo một dự án R\nĐể tạo một dự án R, hãy chọn “New Project” từ menu File.\n\nNếu bạn muốn tạo một thư mục mới cho dự án, hãy chọn “New directory” và cho biết nơi bạn muốn nó được tạo.\n\nNếu bạn muốn tạo dự án trong một thư mục có sẵn, hãy chọn “Existing directory” và trỏ tới đường dẫn thư mục đó.\n\nNếu bạn muốn tạo một bản sao từ kho lưu trữ Github, hãy chọn tùy chọn thứ ba “Version Control” và sau đó chọn “Git”. Xem chương Version control với Git và Github để biết thêm chi tiết.\n\n\n\n\n\n\n\n\n\n\nDự án R bạn tạo ra sẽ có dạng một thư mục chứa tệp .Rproj. Tệp này có thể đóng vai trò là một lối tắt mà bạn sẽ mở dự án của mình. Bạn cũng có thể mở một dự án bằng cách chọn “Open Project” từ menu File. Ngoài ra, ở phía trên bên phải trên của RStudio, bạn sẽ thấy biểu tượng dự án R và menu thả xuống gồm các dự án R có sẵn.\nĐể thoát khỏi một dự án R, hãy mở một dự án mới hoặc đóng dự án (File - Close Project).\n\nDi chuyển giữa các dự án\nĐể di chuyển giữa các dự án, hãy bấm vào biểu tượng dự án R và menu thả xuống ở phía trên cùng bên phải của RStudio. Bạn sẽ thấy các tùy chọn Close Project, Open Project và danh sách các dự án gần đây.\n\n\n\n\n\n\n\n\n\n\n\nThiết lập\nThông thường, mỗi khi bạn khởi động RStudio nên là một “clean slate - khởi đầu mới” - nghĩa là với không gian làm việc hiện tại không được giữ nguyên so với phiên làm việc trước đó. Điều này có nghĩa là các đối tượng và kết quả của bạn sẽ không tồn tại giữa các phiên làm việc (bạn phải tạo lại chúng bằng cách chạy lại scripts của mình). Điều này là tốt, vì nó sẽ buộc bạn phải viết các đoạn code tốt hơn và tránh được lỗi về lâu dài.\nĐể thiết lập RStudio có một “khởi đầu mới” mỗi khi khởi động:\n\nChọn “Project Options” từ menu Tools.\n\nTrong tab “General”, thiết lập RStudio to không khôi phục .RData vào môi trường làm việc của bạn mỗi khi khởi động, và cũng không lưu môi trường làm việc vào tệp .RData khi kết thúc.\n\n\n\nTổ chức\nThông thường sẽ có các thư mục con trong dự án của bạn. Hãy cân nhắc đặt tên các thư mục như “data”, “scripts”, “figures”, “presentations”. Bạn có thể thêm các thư mục theo cách thông thường mà bạn sẽ thêm một thư mục mới cho máy tính của mình. Ngoài ra, hãy xem chương Tương tác với thư mục làm việc để tìm hiểu cách tạo thư mục mới bằng lệnh R.\n\n\nKiểm soát phiên bản\nHãy cân nhắc sử dụng một hệ thống kiểm soát phiên bản. Nó có thể là một cái gì đó đơn giản như có ngày tháng trên tên của các scripts (ví dụ: “transmission_analysis_2020-10-03.R”) và một thư mục “lưu trữ”. Bạn cũng có thể thêm các đoạn văn bản tiêu đề nhận xét ở đầu mỗi scripts bao gồm các thông tin như mô tả, thẻ, tác giả và nhật ký thay đổi.\nMột phương pháp phức tạp hơn đó là việc sử dụng Github hoặc một nền tảng tương tự để kiểm soát phiên bản. Xem chương Version control với Git và Github.\nMột mẹo là bạn có thể tìm kiếm trong toàn bộ dự án hoặc thư mục bằng cách sử dụng công cụ “Find in Files” (Edit menu)). Công cụ này có thể tìm kiếm và thậm chí thay thế các chuỗi trên nhiều tệp.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html#các-ví-dụ",
    "href": "new_pages/r_projects.vn.html#các-ví-dụ",
    "title": "5  Dự án R",
    "section": "5.3 Các ví dụ",
    "text": "5.3 Các ví dụ\nDưới đây là một vài ví dụ về cách nhập/xuất/lưu trữ sử dụng lệnh here() from within an R projct. bên trong một dự án R. Đọc thêm về package here trong chương Nhập xuất dữ liệu.\nNhập linelist_raw.xlsx từ thư mục “data” trong dự án R của bạn\n\nlinelist &lt;- import(here(\"data\", \"linelist_raw.xlsx\"))\n\nXuất đối tượng linelist thành tệp “my_linelist.rds” vào thư mục “clean” nằm trong thư mục “data” trong dự án R của bạn.\n\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.rds\"))\n\nLưu biểu đồ được in gần đây nhất thành tệp “epicurve_2021-02-15.png” nằm trong thư mục “epicurves” của thư mục “outputs” trong dự án R của bạn.\n\nggsave(here(\"outputs\", \"epicurves\", \"epicurve_2021-02-15.png\"))",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html#nguồn",
    "href": "new_pages/r_projects.vn.html#nguồn",
    "title": "5  Dự án R",
    "section": "5.4 Nguồn",
    "text": "5.4 Nguồn\nTrang web của RStudio về việc sử dụng các dự án R",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html",
    "href": "new_pages/importing.vn.html",
    "title": "6  Nhập xuất dữ liệu",
    "section": "",
    "text": "6.1 Tổng quan\nKhi bạn nhập một “dataset (bộ dữ liệu)” vào R, bạn thường cần tạo ra một đối tượng data frame mới trong môi trường R và định nghĩa nó là tệp được nhập (ví dụ: Excel, CSV, TSV, RDS), từ trong các thư mục của bạn tại một đường dẫn/địa chỉ tệp nhất định.\nBạn có thể nhập/xuất nhiều loại tệp, bao gồm cả những tệp được tạo bởi các chương trình thống kê khác (SAS, STATA, SPSS). Bạn cũng có thể kết nối với các cơ sở dữ liệu liên quan.\nR thậm chí còn có các định dạng dữ liệu riêng:",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#tổng-quan",
    "href": "new_pages/importing.vn.html#tổng-quan",
    "title": "6  Nhập xuất dữ liệu",
    "section": "",
    "text": "Một tệp RDS (.rds) lưu trữ một đối tượng R đơn lẻ, chẳng hạn như một data frame. Chúng hữu ích trong việc lưu trữ dữ liệu đã được làm sạch, vì chúng giữ lại kiểu dữ liệu cho các cột R. Đọc thêm trong mục này.\n\nMột tệp RData (.Rdata) có thể được sử dụng để lưu trữ nhiều đối tượng hoặc thậm chí là một không gian làm việc trong R hoàn chỉnh. Đọc thêm trong mục này.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#package-rio",
    "href": "new_pages/importing.vn.html#package-rio",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.2 Package rio",
    "text": "6.2 Package rio\nPackage R chúng tôi gợi ý là: rio. Tên “rio” là chữ viết tắt của “R I/O” (dữ liệu đầu vào (input)/kết quả đầu ra (output)).\nHàm import() và export() có thể xử lý nhiều loại tệp khác nhau (ví dụ: .xlsx, .csv, .rds, .tsv). Khi bạn cung cấp đường dẫn tệp đến một trong các hàm này (bao gồm cả đuôi file mở rộng như “.csv”), rio sẽ đọc phần mở rộng và sử dụng đúng công cụ để nhập hoặc xuất tệp.\nGiải pháp thay thế cho việc sử dụng rio là sử dụng các hàm từ nhiều package khác, mỗi package cụ thể cho một loại tệp. Ví dụ như, read.csv() (base R), read.xlsx() (package openxlsx) và write_csv() (package readr), v.v… Những lựa chọn thay thế này có thể khó nhớ, trong khi sử dụng import() và export() từ rio rất dễ dàng.\nCác hàm import() và export() của rio sử dụng package và lệnh phù hợp cho một tệp nhất định, dựa trên phần mở rộng của tệp đó. Xem phần cuối của chương này để xem bảng đầy đủ về các package/hàm rio sử dụng trong nền. Hàm này cũng có thể được sử dụng để nhập các tệp STATA, SAS và SPSS trong hàng tá các loại tệp khác.\nNhập/xuất shapefiles đòi hỏi sử dụng các package khác, được mô tả cụ thể trong chương GIS cơ bản.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#here",
    "href": "new_pages/importing.vn.html#here",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.3 Package here",
    "text": "6.3 Package here\nPackage here và hàm here() của nó giúp R dễ dàng biết nơi tìm và lưu tệp của bạn - về bản chất, nó xây dựng đường dẫn tệp.\nĐược sử dụng cùng với dự án R, here cho phép bạn mô tả vị trí các tệp trong dự án R của bạn trong thư mục gốc (root directory) của dự án R (thư mục cấp cao nhất). Điều này hữu ích khi dự án R có thể được chia sẻ hoặc truy cập bởi nhiều người dùng/máy tính. Package này ngăn ngừa sự phức tạp do các đường dẫn tệp là duy nhất trên các máy tính khác nhau (ví dụ: \"C:/Users/Laura/Documents...\") bằng cách “khởi động (starting)” đường dẫn tệp ở thư mục chung cho tất cả người dùng (dự án R gốc).\nĐây là cách here() làm việc trong một dự án R:\n\nKhi package here được tải lần đầu tiên trong dự án R, nó đặt một tệp nhỏ có tên là “.here” trong thư mục gốc dự án R của bạn như là một “điểm chuẩn” hoặc “mỏ neo”\n\nTrong script của bạn, để tham chiếu một tệp trong các thư mục con của dự án R, bạn sử dụng hàm here() để tạo đường dẫn tệp liên quan đến thư mục gốc (anchor)\nĐể tạo đường dẫn tệp, viết tên các thư mục bên ngoài thư mục gốc, trong dấu ngoặc kép, được phân tách bằng dấu phẩy, cuối cùng kết thúc bằng tên và phần mở rộng của tệp như được trình bày dưới đây\n\nCác đường dẫn tệp here() có thể được sử dụng cả để nhập và xuất dữ liệu\n\nVí dụ, dưới đây, một đường dẫn tệp được tạo bởi hàm here() đang được cung cấp cho hàm import()\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\n\nLệnh here(\"data\", \"linelists\", \"ebola_linelist.xlsx\") trên thực tế đang cung cấp đường dẫn tệp đầy đủ mà là duy nhất cho máy tính của người dùng:\n\"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx\"\nƯu điểm là lệnh here() được R sử dụng có thể chạy thành công trên bất kỳ máy tính nào truy cập vào dự án R.\nMẸO: Nếu bạn không chắc gốc “.here” được đặt ở đâu, hãy chạy lệnh here() với dấu ngoặc đơn trống.\nĐọc thêm về package here tại đường dẫn này.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#đường-dẫn-tệp",
    "href": "new_pages/importing.vn.html#đường-dẫn-tệp",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.4 Đường dẫn tệp",
    "text": "6.4 Đường dẫn tệp\nKhi nhập hoặc xuất dữ liệu, bạn phải cung cấp một đường dẫn tệp. Bạn có thể thực hiện thao tác này bằng một trong ba cách sau:\n\nKhuyên dùng: cung cấp một đường dẫn tệp “tương đối” bằng package here\n\nCung cấp đường dẫn tệp “đầy đủ” / “tuyệt đối”\n\nChọn tệp theo cách thủ công\n\n\nĐường dẫn tệp “tương đối”\nTrong R, đường dẫn tệp “tương đối” bao gồm đường dẫn tệp mà liên quan đến phần gốc của dự án R. Chúng cho phép nhiều đường dẫn tệp đơn giản hơn có thể làm việc trên nhiều máy tính khác nhau (ví dụ: nếu dự án R nằm trên bộ nhớ dùng chung hoặc được gửi qua thư điện tử). Như đã được mô tả ở trên, đường dẫn tệp tương đối được tạo ra dễ dàng bằng cách sử dụng package here.\nDưới đây là một ví dụ về đường dẫn tệp tương đối được tạo bằng package here(). Chúng tôi giả sử công việc nằm trong một dự án R có chứa một thư mục con “data” và bên trong nó là thư mục con “linelists”, trong đó có tệp .xlsx được quan tâm.\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\n\n\n\nĐường dẫn tệp “tuyệt đối”\nĐường dẫn tệp tuyệt đối hay “đầy đủ” có thể được cung cấp cho các hàm như import() nhưng chúng “dễ đứt gãy” bởi vì chúng là duy nhất đối với các máy tính của những người dùng khác nhau, và do đó không được khuyến khích sử dụng.\nDưới đây là một ví dụ về đường dẫn tệp tuyệt đối, trong máy tính của Laura có một thư mục “analysis”, tiếp theo là thư mục con “data” và bên trong là thư mục con “linelists”, trong đó có tệp .xlsx được quan tâm.\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx\")\n\nMột vài điều cần lưu ý về đường dẫn tệp tuyệt đối:\n\nTránh sử dụng đường dẫn tệp tuyệt đối vì chúng sẽ bị đứt gãy nếu script được chạy trên một máy tính khác\nSử dụng dấu gạch chéo tiến (/), như trong ví dụ trên (lưu ý: đây KHÔNG phải là kiểu mặc định đối với đường dẫn tệp trong Windows)\n\nĐường dẫn tệp bắt đầu với hai dấu gạch chéo (ví dụ: “//…”) sẽ có khả năng không được R nhận ra và tạo ra lỗi. Hãy cân nhắc chuyển công việc của bạn sang ổ đĩa “có tên” hoặc “có chữ” bắt đầu bằng một chữ cái (ví dụ: “J:” hoặc “C:”). Xem chương về Tương tác với thư mục làm việc để biết thêm chi tiết về vấn đề này.\n\nMột tình huống mà đường dẫn tệp tuyệt đối có thể thích hợp là khi bạn muốn nhập một tệp từ bộ nhớ dùng chung có cùng đường dẫn tệp đầy đủ cho tất cả người dùng.\nMẸO: Để nhanh chóng chuyển đổi tất cả \\ thành /, hãy bôi đen đoạn code cần chuyển, sử dụng Ctrl + F (trong Windows) và tích vào tùy chọn “In selection”, sau đó sử dụng chức năng thay thế (replace) để chuyển đổi chúng.\n\n\n\nChọn tệp theo cách thủ công\nBạn có thể nhập dữ liệu theo cách thủ công thông qua một trong các phương pháp sau:\n\nTừ cửa sổ Environment trong RStudio, nhấp vào “Import Dataset” và chọn loại dữ liệu\nNhấp vào File / Import Dataset / (chọn loại dữ liệu)\n\nĐể lựa chọn thủ công bằng code, hãy sử dụng lệnh file.choose() trong base R (để trống dấu ngoặc đơn) để kích hoạt sự xuất hiện của một cửa sổ pop-up cho phép người dùng chọn tệp theo cách thủ công từ máy tính của họ. Ví dụ:\n\n\n# Manual selection of a file. When this command is run, a POP-UP window will appear. \n# The file path selected will be supplied to the import() command.\n\nmy_data &lt;- import(file.choose())\n\nMẸO: Cửa sổ pop-up có thể xuất hiện SAU cửa sổ RStudio của bạn.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#nhập-dữ-liệu",
    "href": "new_pages/importing.vn.html#nhập-dữ-liệu",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.5 Nhập dữ liệu",
    "text": "6.5 Nhập dữ liệu\nSử dụng lệnh import() để nhập một bộ dữ liệu khá đơn giản. Chỉ cần cung cấp đường dẫn của tệp (bao gồm tên và phần mở rộng của tệp) trong dấu ngoặc kép. Nếu sử dụng hàm here() để xây dựng đường dẫn tệp, hãy làm theo hướng dẫn ở bên trên. Dưới đây là một vài ví dụ:\nNhập một tệp csv nằm trong “thư mục làm việc (working directory)” của bạn hoặc trong thư mục gốc của dự án R:\n\nlinelist &lt;- import(\"linelist_cleaned.csv\")\n\nNhập sheet đầu tiên của Excel workbook, được đặt trong thư mục con “data” và “linelists” của dự án R (đường dẫn tệp được tạo bằng hàm here()):\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"linelist_cleaned.xlsx\"))\n\nNhập một data frame (một tệp .rds ) sử dụng đường dẫn tệp tuyệt đối:\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds\")\n\n\nTrang tính Excel cụ thể\nTheo mặc định, nếu bạn cung cấp một Excel workbook (.xlsx) để nhập bằng hàm import(), trang tính đầu tiên của workbook sẽ được nhập. Nếu bạn muốn nhập một trang tính cụ thể, hãy cụ thể tên trang tính vào đối số which =. Ví dụ:\n\nmy_data &lt;- import(\"my_excel_file.xlsx\", which = \"Sheetname\")\n\nNếu sử dụng hàm here() để cung cấp một đường dẫn tương đối đến hàm import(), bạn vẫn có thể chỉ ra một trang tính cụ thể bằng cách thêm đối số which = sau dấu đóng ngoặc của hàm here().\n\n# Demonstration: importing a specific Excel sheet when using relative pathways with the 'here' package\nlinelist_raw &lt;- import(here(\"data\", \"linelist.xlsx\"), which = \"Sheet1\")`  \n\nĐể xuất một data frame từ R sang một trang tính Excel và phần còn lại của Excel workbook không thay đổi, bạn sẽ phải nhập, chỉnh sửa và xuất với một package thay thế chuyên biệt cho mục đích này, chẳng hạn như openxlsx. Xem thêm thông tin trong chương về Tương tác với thư mục làm việc hoặc tại trang github này.\nNếu Excel workbook của bạn có phần mở rộng là .xlsb (định dạng nhị phân của Excel workbook) bạn có thể sẽ không nhập được bằng package rio. Hãy cân nhắc lưu lại tệp dưới dạng .xlsx hoặc sử dụng một package như readxlsb, là package được xây dựng cho kiểu tệp này.\n\n\n\nGiá trị missing\nBạn có thể muốn xác định (các) giá trị nào trong bộ dữ liệu của mình nên được coi là missing. Như đã giải thích trong chương về Dữ liệu missing, giá trị cho dữ liệu missing trong R là NA, nhưng có thể bộ dữ liệu bạn muốn nhập vào sử dụng giá trị 99, “Missing” hoặc chỉ là khoảng trống ký tự ““.\nSử dụng đối số na = để (nhập) import() và cung cấp (các) giá trị trong dấu ngoặc kép (ngay cả khi chúng là các số). Bạn có thể chỉ định nhiều giá trị bằng cách gộp chúng trong một vectơ, bằng cách sử dụng c() như được trình bày dưới đây.\nTại đây, giá trị “99” trong bộ dữ liệu đã nhập được coi là missing và được chuyển đổi thành NA trong R.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.xlsx\"), na = \"99\")\n\nCòn ở đây, bất kỳ giá trị nào là “Missing”, “” (ô trống) hoặc ” ” (khoảng trắng) trong bộ dữ liệu đã nhập đều được chuyển đổi thành NA trong R.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.csv\"), na = c(\"Missing\", \"\", \" \"))\n\n\n\n\nBỏ qua một số hàng\nĐôi khi, bạn có thể không muốn nhập một hàng dữ liệu. Bạn có thể thực hiện thao tác này với đối số skip = nếu sử dụng hàm import() từ package rio trên tệp .xlsx hoặc .csv. Cung cấp số hàng bạn muốn bỏ qua.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\", skip = 1)  # does not import header row\n\nKhông may là hàm skip = chỉ chấp nhận một giá trị số nguyên, không chấp nhận một khoảng (ví dụ: “2:10” sẽ không hoạt động). Để bỏ qua việc nhập các hàng cụ thể không liên tiếp từ trên cùng, hãy cân nhắc nhập nhiều lần và sử dụng hàm bind_rows() từ dplyr. Hãy xem ví dụ dưới đây về việc chỉ bỏ qua hàng thứ 2.\n\n\nQuản lý hàng tiêu đề thứ hai\nĐôi khi, dữ liệu của bạn có thể có hàng thứ hai, với chức năng như là “từ điển dữ liệu” như hình dưới đây. Trường hợp này có thể xảy ra vấn đề vì nó có thể dẫn đến việc tất cả các cột được nhập vào dưới dạng kiểu “ký tự (character)”.\nDưới đây là một ví dụ về kiểu bộ dữ liệu này (với hàng đầu tiên là từ điển dữ liệu).\n\n\n\n\n\n\n\n\nXóa hàng tiêu đề thứ hai\nĐể bỏ hàng tiêu đề thứ hai, bạn có thể sẽ cần nhập dữ liệu hai lần.\n\nNhập dữ liệu vào để lấy tên các cột chính xác\n\nNhập lại dữ liệu, bỏ qua hai hàng đầu tiên (hàng tiêu đề và hàng thứ hai)\n\nLiên kết dataframe đã xóa bỏ 2 hàng đầu tiên với tên cột chính xác ở bước 1\n\nĐối số chính xác được sử dụng để liên kết các tên cột tùy thuộc vào loại tệp dữ liệu (.csv, .tsv, .xlsx, v.v.). Điều này là do rio sử dụng các hàm khác nhau cho các loại tệp khác nhau (xem bảng ở trên).\nĐối với tệp Excel: (col_names =)\n\n# import first time; store the column names\nlinelist_raw_names &lt;- import(\"linelist_raw.xlsx\") %&gt;% names()  # save true column names\n\n# import second time; skip row 2, and assign column names to argument col_names =\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\",\n                       skip = 2,\n                       col_names = linelist_raw_names\n                       ) \n\nĐối với tệp CSV: (col.names =)\n\n# import first time; sotre column names\nlinelist_raw_names &lt;- import(\"linelist_raw.csv\") %&gt;% names() # save true column names\n\n# note argument for csv files is 'col.names = '\nlinelist_raw &lt;- import(\"linelist_raw.csv\",\n                       skip = 2,\n                       col.names = linelist_raw_names\n                       ) \n\nTùy chọn sao lưu - thay đổi tên cột dưới dạng một lệnh riêng biệt\n\n# assign/overwrite headers using the base 'colnames()' function\ncolnames(linelist_raw) &lt;- linelist_raw_names\n\n\nTạo từ điển dữ liệu\nThông tin thêm! Nếu bạn có hàng thứ hai là từ điển dữ liệu, bạn có thể dễ dàng tạo từ điển dữ liệu thích hợp từ nó. Mẹo này được tham khảo từ bài đăng này.\n\ndict &lt;- linelist_2headers %&gt;%             # begin: linelist with dictionary as first row\n  head(1) %&gt;%                             # keep only column names and first dictionary row                \n  pivot_longer(cols = everything(),       # pivot all columns to long format\n               names_to = \"Column\",       # assign new column names\n               values_to = \"Description\")\n\n\n\n\n\n\n\n\n\nKết hợp hai hàng tiêu đề\nTrong một số trường hợp khi bộ dữ liệu thô của bạn có hai hàng tiêu đề (hoặc cụ thể hơn, hàng dữ liệu thứ 2 là tiêu đề phụ), bạn có thể sẽ muốn “kết hợp” chúng hoặc thêm các giá trị trong hàng tiêu đề thứ hai vào hàng tiêu đề đầu tiên.\nLệnh dưới đây sẽ xác định tên cột của data frame là sự kết hợp (dán với nhau) của các tiêu đề (đúng) đầu tiên với giá trị ngay bên dưới (trong hàng đầu tiên).\n\nnames(my_data) &lt;- paste(names(my_data), my_data[1, ], sep = \"_\")\n\n\n\n\n\nTrang tính Google\nBạn có thể nhập dữ liệu từ một trang tính Google trực tuyến với package googlesheet4 và bằng cách xác thực quyền truy cập của bạn vào trang tính.\n\npacman::p_load(\"googlesheets4\")\n\nDưới đây là một trang tính Google minh họa được nhập và lưu. Lệnh này có thể yêu cầu xác thực tài khoản Google của bạn. Làm theo lời nhắc và cửa sổ bật lên trong trình duyệt Internet của bạn để cấp cho các package Tidyverse API quyền chỉnh sửa, tạo và xóa trang tính của bạn trong Google Drive.\nTrang tính dưới đây “có thể được xem bởi bất kỳ ai có liên kết” và bạn có thể thử nhập trang tính đó.\n\nGsheets_demo &lt;- read_sheet(\"https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0\")\n\nTrang tính cũng có thể được nhập chỉ bằng ID của sheet, một phần ngắn hơn của URL:\n\nGsheets_demo &lt;- read_sheet(\"1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY\")\n\nMột package khác, googledrive cung cấp các hàm hữu ích để viết, chỉnh sửa và xóa các trang tính Google. Ví dụ: các hàm được sử dụng gs4_create() và sheet_write() đều được tìm thấy trong package này.\nDưới đây là một số hướng dẫn trực tuyến hữu ích khác:\nhướng dẫn nhập Google sheet cơ bản\nhướng dẫn chi tiết hơn\ntương tác giữa googlesheets4 và tidyverse",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#nhập-xuất-tách-kết-hợp---nhiều-tệp",
    "href": "new_pages/importing.vn.html#nhập-xuất-tách-kết-hợp---nhiều-tệp",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.6 Nhập, xuất, tách, kết hợp - nhiều tệp",
    "text": "6.6 Nhập, xuất, tách, kết hợp - nhiều tệp\nXem chương về Lặp, vòng lặp, và danh sách để biết ví dụ về cách nhập và kết hợp nhiều tệp hoặc nhiều Excel workbook. Chương này cũng có các ví dụ về cách chia một data frame thành các phần và xuất từng phần riêng biệt hoặc dưới dạng các trang tính được đặt tên trong một Excel workbook.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#import_github",
    "href": "new_pages/importing.vn.html#import_github",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.7 Nhập từ Github",
    "text": "6.7 Nhập từ Github\nNhập dữ liệu trực tiếp từ Github vào R có thể rất dễ dàng hoặc có thể yêu cầu một vài bước - tùy thuộc vào loại tệp. Dưới đây là một số cách tiếp cận:\n\nTệp CSV\nCó thể dễ dàng nhập tệp .csv trực tiếp từ Github vào R bằng lệnh R.\n\nĐi tới repo Github, tìm tệp quan tâm và nhấp vào tệp đó\n\nNhấp vào nút “Raw” (sau đó bạn sẽ thấy dữ liệu csv “thô”, như được hiển thị bên dưới)\n\nSao chép URL (địa chỉ web)\n\nĐặt URL trong dấu ngoặc kép trong lệnh R import()\n\n\n\n\n\n\n\n\n\n\n\n\nTệp XLSX\nBạn có thể không xem được dữ liệu “Thô” cho một số tệp (ví dụ: .xlsx, .rds, .nwk, .shp)\n\nĐi tới repo Github, tìm tệp quan tâm và nhấp vào tệp đó\n\nNhấp vào nút “Download”, như được hiển thị bên dưới\n\nLưu tệp trên máy tính của bạn và nhập tệp đó vào R\n\n\n\n\n\n\n\n\n\n\n\n\nShapefiles\nCác Shapefiles có nhiều tệp thành phần phụ, mỗi tệp có một phần mở rộng khác nhau. Một tệp sẽ có phần mở rộng “.shp”, nhưng những tệp khác có thể là “.dbf”, “.prj”, v.v. Để tải xuống shapefiles từ Github, bạn sẽ cần tải xuống từng tệp thành phần phụ riêng lẻ và lưu chúng trong cùng một thư mục trên máy tính của bạn. Trong Github, nhấp vào từng tệp riêng lẻ và tải chúng xuống bằng cách nhấp vào nút “Download”.\nMột khi được lưu vào máy tính, bạn có thể nhập định dạng tệp như được trình bày trong chương GIS cơ bản bằng cách sử dụng hàm st_read() từ package sf. Bạn chỉ cần cung cấp đường dẫn tệp và tên của tệp “.shp” - miễn là các tệp liên quan khác nằm trong cùng một thư mục trên máy tính của bạn.\nDưới đây, bạn có thể thấy shapefiles tên “sl_adm3” bao gồm nhiều tệp như thế nào - mỗi tệp phải được tải xuống từ Github.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#nhập-dữ-liệu-thủ-công",
    "href": "new_pages/importing.vn.html#nhập-dữ-liệu-thủ-công",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.8 Nhập dữ liệu thủ công",
    "text": "6.8 Nhập dữ liệu thủ công\n\nNhập theo hàng\nSử dụng hàm tribble của package tibble từ tidyverse (tài liệu tham khảo trực tuyến).\nLưu ý cách tiêu đề cột bắt đầu bằng dấu ngã (~). Cũng lưu ý rằng mỗi cột chỉ được chứa một nhóm dữ liệu (ký tự, số, v.v.). Bạn có thể sử dụng các tab, khoảng cách và hàng mới để làm cho việc nhập dữ liệu trực quan và dễ đọc hơn. Khoảng trắng không quan trọng giữa các giá trị, nhưng mỗi hàng được biểu thị bằng một dòng code mới. Ví dụ:\n\n# create the dataset manually by row\nmanual_entry_rows &lt;- tibble::tribble(\n  ~colA, ~colB,\n  \"a\",   1,\n  \"b\",   2,\n  \"c\",   3\n  )\n\nVà giờ chúng ta hiển thị bộ dữ liệu mới:\n\n\n\n\n\n\n\n\nNhập theo cột\nVì data frame bao gồm các vectơ (cột dọc), cách tiếp cận cơ bản để tạo data frame thủ công trong R yêu cầu bạn phải tạo từng cột và sau đó liên kết chúng lại với nhau. Điều này có thể phản trực quan trong dịch tễ học, vì chúng ta thường nghĩ về dữ liệu của mình theo hàng (như trên).\n\n# define each vector (vertical column) separately, each with its own name\nPatientID &lt;- c(235, 452, 778, 111)\nTreatment &lt;- c(\"Yes\", \"No\", \"Yes\", \"Yes\")\nDeath     &lt;- c(1, 0, 1, 0)\n\nCHÚ Ý: Tất cả các vectơ phải có cùng độ dài (cùng số giá trị).\nCác vectơ sau đó có thể được liên kết với nhau bằng cách sử dụng lệnh data.frame():\n\n# combine the columns into a data frame, by referencing the vector names\nmanual_entry_cols &lt;- data.frame(PatientID, Treatment, Death)\n\nVà giờ chúng ta hiển thị bộ dữ liệu mới:\n\n\n\n\n\n\n\n\nDán từ clipboard\nNếu bạn sao chép dữ liệu từ nơi khác và có nó trong clipboard (bộ nhớ tạm), bạn có thể thử một trong hai cách dưới đây:\nTừ package clipr, bạn có thể sử dụng hàm read_clip_tbl() để nhập dưới dạng data frame hoặc chỉ cần hàm read_clip() để nhập dưới dạng một vectơ ký tự. Trong cả hai trường hợp, hãy để trống dấu ngoặc đơn.\n\nlinelist &lt;- clipr::read_clip_tbl()  # imports current clipboard as data frame\nlinelist &lt;- clipr::read_clip()      # imports as character vector\n\nBạn cũng có thể dễ dàng xuất sang clipboard của hệ thống bằng clipr. Xem mục bên dưới về Xuất dữ liệu.\nNgoài ra, bạn có thể sử dụng lệnh read.table() từ base R với file = \"clipboard\") để nhập dưới dạng data frame:\n\ndf_from_clipboard &lt;- read.table(\n  file = \"clipboard\",  # specify this as \"clipboard\"\n  sep = \"t\",           # separator could be tab, or commas, etc.\n  header=TRUE)         # if there is a header row",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#nhập-tệp-gần-đây-nhất",
    "href": "new_pages/importing.vn.html#nhập-tệp-gần-đây-nhất",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.9 Nhập tệp gần đây nhất",
    "text": "6.9 Nhập tệp gần đây nhất\nThường thì bạn có thể nhận được các bản cập nhật hàng ngày cho bộ dữ liệu của mình. Trong trường hợp này, bạn sẽ muốn viết code mà nhập tệp gần đây nhất. Dưới đây, chúng tôi trình bày hai cách để tiếp cận điều này:\n\nChọn tệp dựa trên ngày trong tên tệp\n\nChọn tệp dựa trên metadata (siêu dữ liệu - là dạng dữ liệu mô tả thông tin chi tiết về dữ liệu) của tệp (lần sửa đổi cuối cùng)\n\n\nNgày trong tên tệp\nCách tiếp cận này dựa trên ba cơ sở:\n\nBạn tin tưởng ngày tháng trong tên tệp\n\nNgày tháng ở dạng số và thường xuất hiện ở cùng một định dạng (ví dụ: năm rồi tháng rồi ngày)\n\nKhông có số nào khác trong tên tệp\n\nChúng tôi sẽ giải thích từng bước và sau đó cho bạn thấy cách chúng được kết hợp ở phần cuối.\nĐầu tiên, sử dụng dir() từ base R để chỉ trích xuất tên tệp cho mỗi tệp trong thư mục quan tâm. Xem chương về Tương tác với thư mục làm việc để biết thêm chi tiết về dir(). Trong ví dụ này, thư mục quan tâm là thư mục “linelists” trong thư mục “example” chứa trong thư mục “data” của dự án R.\n\nlinelist_filenames &lt;- dir(here(\"data\", \"example\", \"linelists\")) # get file names from folder\nlinelist_filenames                                              # print\n\n[1] \"20201007linelist.csv\"          \"case_linelist_2020-10-02.csv\" \n[3] \"case_linelist_2020-10-03.csv\"  \"case_linelist_2020-10-04.csv\" \n[5] \"case_linelist_2020-10-05.csv\"  \"case_linelist_2020-10-08.xlsx\"\n[7] \"case_linelist20201006.csv\"    \n\n\nMột khi bạn có vectơ chứa các tên này, bạn có thể trích xuất ngày với chúng bằng cách áp dụng hàm str_extract() từ stringr với việc sử dụng biểu thức chính quy sau đây. Nó giúp trích xuất bất kỳ số nào trong tên tệp (bao gồm bất kỳ ký tự nào khác ở giữa như dấu gạch ngang hoặc dấu gạch chéo). Bạn có thể đọc thêm về stringr trong chương Ký tự và chuỗi.\n\nlinelist_dates_raw &lt;- stringr::str_extract(linelist_filenames, \"[0-9].*[0-9]\") # extract numbers and any characters in between\nlinelist_dates_raw  # print\n\n[1] \"20201007\"   \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"20201006\"  \n\n\nGiả sử ngày thường được viết theo cùng một định dạng ngày (ví dụ: Năm rồi Tháng rồi Ngày) và năm có 4 chữ số, bạn có thể sử dụng các hàm chuyển đổi linh hoạt của lubridate (ymd(), dmy(), or mdy()) để chuyển đổi chúng thành ngày. Đối với các hàm này, dấu gạch ngang, dấu cách hoặc dấu gạch chéo không quan trọng, quan trọng chỉ là thứ tự của các số. Đọc thêm trong chương Làm việc với ngày tháng.\n\nlinelist_dates_clean &lt;- lubridate::ymd(linelist_dates_raw)\nlinelist_dates_clean\n\n[1] \"2020-10-07\" \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"2020-10-06\"\n\n\nSau đó, hàm base R which.max() có thể được sử dụng để trả về vị trí chỉ mục (ví dụ: 1, 2, 3,…) của giá trị ngày lớn nhất. Tệp mới nhất được xác định chính xác là tệp thứ 6 - “case_linelist_2020-10-08.xlsx”.\n\nindex_latest_file &lt;- which.max(linelist_dates_clean)\nindex_latest_file\n\n[1] 6\n\n\nNếu chúng ta tổng hợp tất cả các lệnh này, code hoàn chỉnh có thể trông giống như bên dưới. Lưu ý rằng dấu . ở dòng cuối cùng thay thế cho đối tượng được truyền vào hàm trước đó. Tại thời điểm đó, giá trị chỉ đơn giản là số 6. Giá trị này được đặt trong dấu ngoặc kép để trích xuất phần tử thứ 6 của vectơ tên tệp được tạo bởi dir().\n\n# load packages\npacman::p_load(\n  tidyverse,         # data management\n  stringr,           # work with strings/characters\n  lubridate,         # work with dates\n  rio,               # import / export\n  here,              # relative file paths\n  fs)                # directory interactions\n\n# extract the file name of latest file\nlatest_file &lt;- dir(here(\"data\", \"example\", \"linelists\")) %&gt;%  # file names from \"linelists\" sub-folder          \n  str_extract(\"[0-9].*[0-9]\") %&gt;%                  # pull out dates (numbers)\n  ymd() %&gt;%                                        # convert numbers to dates (assuming year-month-day format)\n  which.max() %&gt;%                                  # get index of max date (latest file)\n  dir(here(\"data\", \"example\", \"linelists\"))[[.]]              # return the filename of latest linelist\n\nlatest_file  # print name of latest file\n\n[1] \"case_linelist_2020-10-08.xlsx\"\n\n\nBây giờ bạn có thể sử dụng tên này để hoàn thiện đường dẫn tệp tương đối, với hàm here():\n\nhere(\"data\", \"example\", \"linelists\", latest_file) \n\nVà bây giờ bạn có thể nhập tệp mới nhất:\n\n# import\nimport(here(\"data\", \"example\", \"linelists\", latest_file)) # import \n\n\n\nSử dụng thông tin tệp\nNếu tệp của bạn không có ngày trong tên của chúng (hoặc bạn không tin tưởng vào những ngày đó), bạn có thể thử trích xuất ngày sửa đổi cuối cùng từ siêu dữ liệu tệp. Sử dụng các hàm từ package fs để kiểm tra thông tin siêu dữ liệu cho từng tệp, bao gồm thời gian sửa đổi cuối cùng và đường dẫn tệp.\nDưới đây, chúng tôi cung cấp thư mục quan tâm tới hàm dir_info() của package fs. Trong trường hợp này, thư mục quan tâm nằm trong dự án R trong thư mục “data”, thư mục con “example” và thư mục con thư mục này “linelists”. Kết quả là một data frame với một dòng cho mỗi tệp và các cột cho modification_time, path, v.v. Bạn có thể xem ví dụ trực quan về điều này trong chương về Tương tác với thư mục làm việc.\nChúng ta có thể sắp xếp data frame này của các tệp theo cột với modification_time, và sau đó chỉ giữ lại hàng trên cùng/mới nhất (tệp) với head()của base R. Sau đó, chúng ta có thể trích xuất đường dẫn tệp của tệp mới nhất này chỉ với hàm pull() của dplyr trên path cột. Cuối cùng, chúng ta có thể chuyển đường dẫn tệp này đến import(). Tệp đã nhập được lưu dưới dạng latest_file.\n\nlatest_file &lt;- dir_info(here(\"data\", \"example\", \"linelists\")) %&gt;%  # collect file info on all files in directory\n  arrange(desc(modification_time)) %&gt;%      # sort by modification time\n  head(1) %&gt;%                               # keep only the top (latest) file\n  pull(path) %&gt;%                            # extract only the file path\n  import()                                  # import the file",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#import_api",
    "href": "new_pages/importing.vn.html#import_api",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.10 API",
    "text": "6.10 API\nMột “Giao diện lập trình tự động (Automated Programming Interface)” (API) có thể được sử dụng để yêu cầu trực tiếp dữ liệu từ một trang web. API là một tập hợp các quy tắc cho phép một ứng dụng phần mềm tương tác với một ứng dụng phần mềm khác. Khách hàng (bạn) gửi một “yêu cầu (request)” và nhận được một “phản hồi (response)” có chứa nội dung. Các package R httr và jsonlite có thể hỗ trợ quá trình này.\nMỗi trang web hỗ trợ API sẽ có tài liệu và chi tiết cụ thể riêng để làm quen. Một số trang web công khai API và cho phép có thể được truy cập bởi bất kỳ ai. Những nền tảng khác, chẳng hạn như nền tảng có ID người dùng và thông tin đăng nhập, yêu cầu xác thực để truy cập dữ liệu của họ.\nKhông cần phải nói, để nhập dữ liệu qua API thì cần phải có kết nối internet. Chúng tôi sẽ đưa ra các ví dụ ngắn gọn về việc sử dụng API để nhập dữ liệu và liên kết bạn với các tài nguyên khác.\nLưu ý: Hãy nhớ lại rằng dữ liệu có thể được đăng trên một trang web không có API, điều này có thể dễ dàng truy xuất hơn. Ví dụ: một tệp CSV đã đăng có thể được truy cập chỉ bằng cách cung cấp URL của trang web để import() như được mô tả trong mục nhập từ Github.\n\nHTTP request\nTrao đổi API thường được thực hiện thông qua một HTTP request. HTTP là Giao thức truyền siêu văn bản (Hypertext Transfer Protocol) và là định dạng cơ bản của giao thức yêu cầu (request)/phản hồi (response) giữa máy khách và máy chủ. Đầu vào và đầu ra chính xác có thể khác nhau tùy thuộc vào loại API nhưng quy trình là giống nhau - “Request” (thường là HTTP request) từ người dùng, thường chứa một truy vấn, theo sau là “Response”, chứa thông tin trạng thái về request và có thể là nội dung được yêu cầu.\nDưới đây là một số thành phần của một HTTP request:\n\nURL của điểm cuối API\n\n“Method (Phương thức)” (hoặc “Verb (Động từ)”)\n\nCác tiêu đề\n\nPhần thân\n\nHTTP request “method” là hành động bạn muốn thực hiện. Hai phương thức HTTP phổ biến nhất là GET và POST nhưng những phương thức khác có thể bao gồm PUT, DELETE, PATCH, v.v. Khi nhập dữ liệu vào R, rất có thể bạn sẽ sử dụng GET.\nSau request của bạn, máy tính của bạn sẽ nhận được “phản hồi” ở định dạng tương tự như những gì bạn đã gửi, bao gồm URL, trạng thái HTTP (Trạng thái 200 là thứ bạn muốn!), loại tệp, kích thước và nội dung mong muốn. Sau đó, bạn sẽ cần phân tích cú pháp phản hồi này và biến nó thành một data frame khả thi trong môi trường R của bạn.\n\n\nPackage\nPackage httr hoạt động tốt để xử lý các yêu cầu HTTP trong R. Nó đòi hỏi ít kiến thức về API Web và có thể được sử dụng bởi những người ít quen thuộc với thuật ngữ phát triển phần mềm. Ngoài ra, nếu phản hồi HTTP là .json, bạn có thể sử dụng jsonlite để phân tích cú pháp phản hồi.\n\n# load packages\npacman::p_load(httr, jsonlite, tidyverse)\n\n\n\nDữ liệu công khai\nDưới đây là một ví dụ về một HTTP request, được mượn từ một hướng dẫn từ Phòng thí nghiệm Dữ liệu Trafford. Trang web này chứa một số tài nguyên khác để tìm hiểu và các bài tập về API.\nTình huống: Chúng ta muốn nhập một danh sách các cửa hàng thức ăn nhanh ở thành phố Trafford, Vương quốc Anh. Dữ liệu có thể được truy cập từ API của Cơ quan Tiêu chuẩn Thực phẩm, cơ quan cung cấp dữ liệu xếp hạng vệ sinh thực phẩm cho Vương quốc Anh.\nDưới đây là các thông số cho yêu cầu của chúng tôi:\n\nPhương thức HTTP: GET\n\nURL của điểm cuối API: http://api.ratings.food.gov.uk/Establishments\n\nCác thông số đã chọn: tên, địa chỉ, kinh độ, vĩ độ, businessTypeId, ratingKey, localAuthorityId\n\nCác tiêu đề: “x-api-version”, 2\n\n(Các) Định dạng dữ liệu: JSON, XML\n\nTài liệu: http://api.ratings.food.gov.uk/help\n\nR code sẽ như sau:\n\n# prepare the request\npath &lt;- \"http://api.ratings.food.gov.uk/Establishments\"\nrequest &lt;- GET(url = path,\n             query = list(\n               localAuthorityId = 188,\n               BusinessTypeId = 7844,\n               pageNumber = 1,\n               pageSize = 5000),\n             add_headers(\"x-api-version\" = \"2\"))\n\n# check for any server error (\"200\" is good!)\nrequest$status_code\n\n# submit the request, parse the response, and convert to a data frame\nresponse &lt;- content(request, as = \"text\", encoding = \"UTF-8\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%\n  pluck(\"establishments\") %&gt;%\n  as_tibble()\n\nBây giờ bạn có thể làm sạch và sử dụng data frame có tên response, với mỗi hàng là một cơ sở thức ăn nhanh.\n\n\nYêu cầu xác thực\nMột số API yêu cầu xác thực - để bạn chứng minh mình là ai và có thể truy cập vào dữ liệu bị hạn chế. Để nhập những dữ liệu này, trước tiên bạn có thể cần sử dụng phương thức POST để cung cấp tên người dùng, mật khẩu hoặc code. Điều này sẽ trả về một mã thông báo truy cập, có thể được sử dụng cho các yêu cầu phương thức GET tiếp theo để truy xuất dữ liệu mong muốn.\nDưới đây là một ví dụ về truy vấn dữ liệu từ Go.Data, một công cụ điều tra ổ dịch. Go.Data sử dụng một API cho tất cả các tương tác giữa giao diện người dùng web và các ứng dụng điện thoại thông minh được sử dụng để thu thập dữ liệu. Go.Data được sử dụng trên khắp thế giới. Bởi vì dữ liệu các vụ dịch là nhạy cảm và bạn nên là người duy nhất có thể truy cập vào dữ liệu vụ dịch của mình, nên việc xác thực là bắt buộc.\nDưới đây là một số code R mẫu sử dụng httr và jsonlite để kết nối với API Go.Data để nhập dữ liệu liên hệ truy vết từ vụ dịch của bạn.\n\n# set credentials for authorization\nurl &lt;- \"https://godatasampleURL.int/\"           # valid Go.Data instance url\nusername &lt;- \"username\"                          # valid Go.Data username \npassword &lt;- \"password\"                          # valid Go,Data password \noutbreak_id &lt;- \"xxxxxx-xxxx-xxxx-xxxx-xxxxxxx\"  # valid Go.Data outbreak ID\n\n# get access token\nurl_request &lt;- paste0(url,\"api/oauth/token?access_token=123\") # define base URL request\n\n# prepare request\nresponse &lt;- POST(\n  url = url_request,  \n  body = list(\n    username = username,    # use saved username/password from above to authorize                               \n    password = password),                                       \n    encode = \"json\")\n\n# execute request and parse response\ncontent &lt;-\n  content(response, as = \"text\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%          # flatten nested JSON\n  glimpse()\n\n# Save access token from response\naccess_token &lt;- content$access_token    # save access token to allow subsequent API calls below\n\n# import outbreak contacts\n# Use the access token \nresponse_contacts &lt;- GET(\n  paste0(url,\"api/outbreaks/\",outbreak_id,\"/contacts\"),          # GET request\n  add_headers(\n    Authorization = paste(\"Bearer\", access_token, sep = \" \")))\n\njson_contacts &lt;- content(response_contacts, as = \"text\")         # convert to text JSON\n\ncontacts &lt;- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # flatten JSON to tibble\n\nCẨN TRỌNG: Nếu bạn đang nhập một lượng lớn dữ liệu từ một API yêu cầu xác thực, nó có thể hết thời gian chờ. Để tránh điều này, hãy truy xuất lại access_token trước mỗi yêu cầu API GET và thử sử dụng các bộ lọc hoặc giới hạn trong truy vấn.\nMẸO: Lệnh fromJSON() từ package jsonlite không hoàn toàn không - lồng ghép vào lần đầu tiên nó được chạy, vì vậy bạn vẫn có thể có danh sách các hàng trong phần kết quả của mình. Bạn sẽ cần phải bỏ lồng ghép thêm cho một số biến nhất định; tùy thuộc vào cách .json của bạn được lồng ghép vào nhau. Để xem thêm thông tin về điều này, hãy xem tài liệu về package jsonlite, chẳng hạn như flatten() function.\nĐể biết thêm chi tiết, hãy xem tài liệu trên LoopBack Explorer, chương Truy vết tiếp xúc hoặc các mẹo API trên Go.Data Github repository\nBạn có thể đọc thêm về httr trong gói lệnh here\nPhần này cũng đã được trình bày trong hướng dẫn này và hướng dẫn này.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#xuất-dữ-liệu",
    "href": "new_pages/importing.vn.html#xuất-dữ-liệu",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.11 Xuất dữ liệu",
    "text": "6.11 Xuất dữ liệu\n\nVới package rio\nVới rio, bạn có thể sử dụng lệnh export() theo cách tương tự với import(). Đầu tiên, cung cấp tên của đối tượng R bạn muốn lưu (ví dụ: linelist), sau đó trong dấu ngoặc kép đặt đường dẫn tệp nơi bạn muốn lưu tệp, bao gồm tên tệp mong muốn và phần mở rộng tệp. Ví dụ:\nThao tác này lưu data frame linelist dưới dạng một Excel workbook vào thư mục làm việc/thư mục gốc của dự án R:\n\nexport(linelist, \"my_linelist.xlsx\") # will save to working directory\n\nBạn có thể lưu cùng một data frame dưới dạng tệp csv bằng cách thay đổi phần mở rộng. Ví dụ, chúng tôi cũng lưu nó vào một đường dẫn tệp được tạo bằng here():\n\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.csv\"))\n\n\n\nTới clipboard\nĐể xuất khung dữ liệu sang “clipboard” của máy tính (để sau đó dán vào một phần mềm khác như Excel, Google Spreadsheets, v.v.), bạn có thể sử dụng write_clip() từ package clipr.\n\n# export the linelist data frame to your system's clipboard\nclipr::write_clip(linelist)",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#import_rds",
    "href": "new_pages/importing.vn.html#import_rds",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.12 Tệp RDS",
    "text": "6.12 Tệp RDS\nGiống như .csv, .xlsx, v.v., bạn cũng có thể xuất/lưu các R data frame dưới dạng tệp .rds. Đây là định dạng tệp dành riêng cho R và rất hữu ích nếu bạn biết mình sẽ làm việc lại với dữ liệu đã xuất trong R.\nCác nhóm của cột được lưu trữ, vì vậy bạn không cần phải làm sạch lại khi chúng được nhập (với Excel hoặc thậm chí là tệp CSV, điều này có thể khiến bạn đau đầu!). Nó cũng là một tệp nhỏ hơn, hữu ích cho việc xuất và nhập nếu bộ dữ liệu của bạn lớn.\nVí dụ: nếu bạn làm việc trong nhóm Dịch tễ học và cần gửi tệp cho nhóm GIS để lập bản đồ và họ cũng sử dụng R, chỉ cần gửi tệp .rds cho họ! Sau đó, tất cả các nhóm cột được giữ lại và có ít việc phải xử lý hơn.\n\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.rds\"))",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#import_rdata",
    "href": "new_pages/importing.vn.html#import_rdata",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.13 Tệp và danh sách Rdata",
    "text": "6.13 Tệp và danh sách Rdata\nTệp .Rdata có thể lưu trữ nhiều đối tượng R - ví dụ: nhiều data frame, kết quả mô hình, danh sách, v.v. Điều này có thể rất hữu ích để hợp nhất hoặc chia sẻ nhiều dữ liệu của bạn cho một dự án nhất định.\nTrong ví dụ dưới đây, nhiều đối tượng R được lưu trữ trong tệp “my_objects.Rdata” đã xuất:\n\nrio::export(my_list, my_dataframe, my_vector, \"my_objects.Rdata\")\n\nLưu ý: nếu bạn đang thử nhập một danh sách, hãy sử dụng import_list() từ rio để nhập nó với cấu trúc và nội dung gốc hoàn chỉnh.\n\nrio::import_list(\"my_list.Rdata\")",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#lưu-biểu-đồ",
    "href": "new_pages/importing.vn.html#lưu-biểu-đồ",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.14 Lưu biểu đồ",
    "text": "6.14 Lưu biểu đồ\nHướng dẫn về cách lưu các biểu đồ, chẳng hạn như các biểu đồ được tạo bởi ggplot(), được thảo luận sâu trong chương ggplot cơ bản.\nTóm lại, chạy lệnh ggsave(\"my_plot_filepath_and_name.png\") sau khi in biểu đồ của bạn. Bạn có thể cung cấp một đối tượng biểu đồ đã lưu cho đối số plot = hoặc chỉ cần xác định đường dẫn tệp đích (với phần mở rộng tệp) để lưu biểu đồ được hiển thị gần đây nhất. Bạn cũng có thể kiểm soát width =, height =, units = và dpi =.\nCách để lưu đồ thị mạng lưới (network graph), chẳng hạn như cây lây nhiễm, được đề cập trong chương Chuỗi lây nhiễm.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/importing.vn.html#tài-nguyên-học-liệu",
    "title": "6  Nhập xuất dữ liệu",
    "section": "6.15 Tài nguyên học liệu",
    "text": "6.15 Tài nguyên học liệu\nR Data Import/Export Manual\nR 4 Data Science chapter on data import\nggsave() documentation\nDưới đây là một bảng, lấy từ rio vignette trực tuyến. Đối với mỗi loại dữ liệu, nó hiển thị: phần mở rộng tệp dự kiến, package rio sử dụng để nhập hoặc xuất dữ liệu và trả lời chức năng này có được bao gồm trong phiên bản rio được cài đặt mặc định hay không.\n\n\n\n\n\n\n\n\n\n\nĐịnh dạng\nPhần mở rộng điển hình\nPackage nhập\nPackage xuất\nĐược cài đặt theo mặc định\n\n\n\n\nDữ liệu được phân tách bằng-dấu phẩy\n.csv\ndata.table fread()\ndata.table\nCó\n\n\nDữ liệu được phân tách bằng-dấu gạch\n.psv\ndata.table fread()\ndata.table\nCó\n\n\nDữ liệu được phân tách bằng-tab\n.tsv\ndata.table fread()\ndata.table\nCó\n\n\nSAS\n.sas7bdat\nhaven\nhaven\nCó\n\n\nSPSS\n.sav\nhaven\nhaven\nCó\n\n\nStata\n.dta\nhaven\nhaven\nCó\n\n\nSAS\nXPORT\n.xpt\nhaven\nhaven\n\n\nSPSS Portable\n.por\nhaven\n\nCó\n\n\nExcel\n.xls\nreadxl\n\nCó\n\n\nExcel\n.xlsx\nreadxl\nopenxlsx\nCó\n\n\nCú pháp R\n.R\nbase\nbase\nCó\n\n\nĐối tượng R được lưu\n.RData, .rda\nbase\nbase\nCó\n\n\nĐối tượng R được nối tiếp\n.rds\nbase\nbase\nCó\n\n\nEpiinfo\n.rec\nforeign\n\nCó\n\n\nMinitab\n.mtp\nforeign\n\nCó\n\n\nSystat\n.syd\nforeign\n\nCó\n\n\n“XBASE”\ndatabase files\n.dbf\nforeign\nforeign\n\n\nĐịnh dạng tệp Weka Attribute-Relation\n.arff\nforeign\nforeign\nCó\n\n\nĐịnh dạng trao đổi dữ liệu\n.dif\nutils\n\nCó\n\n\nDữ liệu Fortran\nno recognized extension\nutils\n\nCó\n\n\nĐịnh dạng dữ liệu Fixed-width\n.fwf\nutils\nutils\nCó\n\n\nDữ liệu gzip được phân tách bằng-dấu phẩy\n.csv.gz\nutils\nutils\nCó\n\n\nCSVY (Tiêu đề siêu dữ liệu CSV + YAML)\n.csvy\ncsvy\ncsvy\nKhông\n\n\nEViews\n.wf1\nhexView\n\nKhông\n\n\nĐịnh dạng trao đổi Feather giữa R/Python\n.feather\nfeather\nfeather\nKhông\n\n\nFast Storage\n.fst\nfst\nfst\nKhông\n\n\nJSON\n.json\njsonlite\njsonlite\nKhông\n\n\nMatlab\n.mat\nrmatio\nrmatio\nKhông\n\n\nOpenDocument Spreadsheet\n.ods\nreadODS\nreadODS\nKhông\n\n\nBảng HTML\n.html\nxml2\nxml2\nKhông\n\n\nTài liệu XML cạn\n.xml\nxml2\nxml2\nKhông\n\n\nYAML\n.yml\nyaml\nyaml\nKhông\n\n\nclipboard mặc định là tsv | | clipr | clipr | Không |",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html",
    "href": "new_pages/cleaning.vn.html",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "",
    "text": "Các hàm quan trọng\nChương sách này nhấn mạnh việc sử dụng các hàm từ hệ sinh thái của package tidyverse. Các hàm thiết yếu trong package này được liệt kê dưới đây.\nPhần lớn các hàm được liệt kê bên dưới thuộc về package dplyr (tên package được viết đầy đủ là “data frame-plier, cung cấp các hàm quan trọng để giải quyết các thách thức trong thao tác xử lý dữ liệu . dplyr là một phần trong hệ sinh thái của package tidyverse (bao gồm các package khác như ggplot2, tidyr, stringr, tibble, purrr, magrittr, và forcats).\nNếu bạn muốn so sánh các hàm này với các câu lệnh trong Stata hoặc SAS, hãy xem chương Chuyển đổi sang R.\nBạn cũng có thể bắt gặp một giải pháp quản lý dữ liệu khác được cung cấp bởi package data.table trong R với các toán tử như := và toán tử dấu ngoặc vuông [ ]. Cách tiếp cận và cú pháp này được giải thích ngắn gọn trong chương Data Table.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#quy-trình-làm-sạch",
    "href": "new_pages/cleaning.vn.html#quy-trình-làm-sạch",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.1 Quy trình làm sạch",
    "text": "7.1 Quy trình làm sạch\nChương này tiến hành các bước làm sạch điển hình, bằng cách thêm các hàm xử lý dữ liệu theo trình tự vào một chuỗi các câu lệnh (được gọi là cleaning pipeline).\nTrong phân tích dịch tễ học và xử lý dữ liệu, các bước làm sạch thường được thực hiện tuần tự, liên kết với nhau. Trong R, việc này thường được thực hiện dưới dạng một “pipeline - đường ống” làm sạch, trong đó bộ dữ liệu gốc được chuyển tiếp hoặc “dẫn” từ bước làm sạch này sang bước làm sạch khác.\nCác chuỗi như vậy sử dụng các hàm dạng “verb” trong package dplyr và toán tử pipe %&gt;% trong package magrittr. Chuỗi làm sạch bắt đầu từ dữ liệu “gốc (”linelist_raw.xlsx”) và kết thúc bằng bộ dữ liệu “sạch” trên R (linelist) có thể được sử dụng, lưu, xuất, v.v.\nTrong quy trình làm sạch dữ liệu, thứ tự của các bước là quan trọng. Các bước làm sạch có thể bao gồm:\n\nNhập dữ liệu\nLàm sạch hoặc đổi tên cột\nLoại bỏ trùng lặp\nTạo và chuyển đổi cột (ví dụ: mã hóa lại hoặc chuẩn hóa các giá trị)\nLọc hoặc thêm hàng",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#gọi-package",
    "href": "new_pages/cleaning.vn.html#gọi-package",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.2 Gọi package",
    "text": "7.2 Gọi package\nĐoạn code này trình bày cách gọi các package cần thiết cho phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt package nếu cần và gọi package ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() sẵn có trong base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\n\npacman::p_load(\n  rio,        # importing data  \n  here,       # relative file pathways  \n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # age_categories() function\n  tidyverse   # data management and visualization\n)",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#nhập-dữ-liệu",
    "href": "new_pages/cleaning.vn.html#nhập-dữ-liệu",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.3 Nhập dữ liệu",
    "text": "7.3 Nhập dữ liệu\n\nNhập\nỞ đây, chúng ta sẽ nhập dữ liệu gốc từ file Excel bằng cách sử dụng hàm import() từ package rio. Package rio có thể xử lý linh hoạt nhiều loại tệp tin (ví dụ: .xlsx, .csv, .tsv, .rds). Xem thêm chương Nhập xuất dữ liệu để biết thêm thông tin và mẹo về các tình huống bất thường (ví dụ: loại bỏ hàng, thiết lập giá trị trống, nạp trang tính Google, v.v.).\nNếu bạn muốn hiểu rõ hơn, hãy tải xuống tệp dữ liệu linelist “gốc (với file dạng .xlsx).\nNếu bộ dữ liệu của bạn quá lớn và mất nhiều thời gian để nhập, sẽ hữu ích khi bạn đặt lệnh nhập dữ liệu riêng biệt với chuỗi làm sạch và dữ liệu “gốc sẽ được lưu thành một tệp riêng biệt. Việc này cũng cho phép dễ dàng so sánh giữa phiên bản gốc và phiên bản đã làm sạch.\nDưới đây, chúng ta nạp một tệp Excel thô và lưu nó dưới dạng dataframe linelist_raw. Chúng tôi giả định rằng tệp này nằm trong thư mục làm việc của bạn hoặc thư mục gốc của dự án R và vì vậy không có thư mục con nào được chỉ định trong đường dẫn tệp.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\")\n\nBạn có thể xem 50 hàng đầu tiên của bộ dữ liệu bên dưới. Lưu ý: hàm head(n) trong base R cho phép bạn chỉ xem n hàng đầu tiên trong R console.\n\n\n\n\n\n\n\n\nĐánh giá\nBạn có thể sử dụng hàm skim() từ package skimr để có cái nhìn tổng quan về toàn bộ bộ dữ liệu (xem chương Bảng mô tả để biết thêm thông tin). Các cột được tóm tắt theo phân lớp/định dạng như ký tự và số. Lưu ý: “POSIXct” là một loại phân lớp ngày thô (xem chương Làm việc với ngày tháng.\n\nskimr::skim(linelist_raw)\n\n\n\n\nData summary\n\n\nName\nlinelist_raw\n\n\nNumber of rows\n6611\n\n\nNumber of columns\n28\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n17\n\n\nnumeric\n8\n\n\nPOSIXct\n3\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncase_id\n137\n0.98\n6\n6\n0\n5888\n0\n\n\ndate onset\n293\n0.96\n10\n10\n0\n580\n0\n\n\noutcome\n1500\n0.77\n5\n7\n0\n2\n0\n\n\ngender\n324\n0.95\n1\n1\n0\n2\n0\n\n\nhospital\n1512\n0.77\n5\n36\n0\n13\n0\n\n\ninfector\n2323\n0.65\n6\n6\n0\n2697\n0\n\n\nsource\n2323\n0.65\n5\n7\n0\n2\n0\n\n\nage\n107\n0.98\n1\n2\n0\n75\n0\n\n\nage_unit\n7\n1.00\n5\n6\n0\n2\n0\n\n\nfever\n258\n0.96\n2\n3\n0\n2\n0\n\n\nchills\n258\n0.96\n2\n3\n0\n2\n0\n\n\ncough\n258\n0.96\n2\n3\n0\n2\n0\n\n\naches\n258\n0.96\n2\n3\n0\n2\n0\n\n\nvomit\n258\n0.96\n2\n3\n0\n2\n0\n\n\ntime_admission\n844\n0.87\n5\n5\n0\n1091\n0\n\n\nmerged_header\n0\n1.00\n1\n1\n0\n1\n0\n\n\n…28\n0\n1.00\n1\n1\n0\n1\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\n\n\n\n\ngeneration\n7\n1.00\n16.60\n5.71\n0.00\n13.00\n16.00\n20.00\n37.00\n\n\nlon\n7\n1.00\n-13.23\n0.02\n-13.27\n-13.25\n-13.23\n-13.22\n-13.21\n\n\nlat\n7\n1.00\n8.47\n0.01\n8.45\n8.46\n8.47\n8.48\n8.49\n\n\nrow_num\n0\n1.00\n3240.91\n1857.83\n1.00\n1647.50\n3241.00\n4836.50\n6481.00\n\n\nwt_kg\n7\n1.00\n52.69\n18.59\n-11.00\n41.00\n54.00\n66.00\n111.00\n\n\nht_cm\n7\n1.00\n125.25\n49.57\n4.00\n91.00\n130.00\n159.00\n295.00\n\n\nct_blood\n7\n1.00\n21.26\n1.67\n16.00\n20.00\n22.00\n22.00\n26.00\n\n\ntemp\n158\n0.98\n38.60\n0.95\n35.20\n38.30\n38.80\n39.20\n40.80\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ninfection date\n2322\n0.65\n2012-04-09\n2015-04-27\n2014-10-04\n538\n\n\nhosp date\n7\n1.00\n2012-04-20\n2015-04-30\n2014-10-15\n570\n\n\ndate_of_outcome\n1068\n0.84\n2012-05-14\n2015-06-04\n2014-10-26\n575",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#tên-cột",
    "href": "new_pages/cleaning.vn.html#tên-cột",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.4 Tên cột",
    "text": "7.4 Tên cột\nTrong R, tên cột là “tiêu đề” hoặc giá trị “trên đỉnh” của một cột. Chúng được sử dụng để tham chiếu đến các cột trong đoạn code và đóng vai trò như một nhãn mặc định trong các bảng biểu.\nCác phần mềm thống kê khác như SAS và STATA sử dụng “nhãn” là tên cột phiên bản dài hơn khi in, cùng tồn tại song song với tên cột. Mặc dù R cung cấp tính năng thêm nhãn của cột vào dữ liệu, nhưng điều này hầu hết không được nhấn mạnh trong thực tế. Để đặt tên cột “dễ nhìn” cho các bảng biểu, người ta thường điều chỉnh hiển thị của chúng trong các lệnh vẽ biểu đồ để tạo ra kết quả (ví dụ: tiêu đề trục hoặc chú giải của một biểu đồ hoặc tiêu đề cột trong bảng - xem thêm mục scales trong chương Các mẹo với ggplot và chương Trình bày bảng). Nếu bạn muốn gán nhãn cột trong dữ liệu, hãy đọc thêm tài liệu trực tuyến tại đây và tại đây.\nVì tên cột trong R được sử dụng rất thường xuyên, vì vậy chúng phải có cú pháp “sạch”. Chúng tôi đề xuất những tiêu chí sau:\n\nTên ngắn\nKhông có khoảng trắng (thay thế bằng dấu gạch dưới_)\nKhông có ký tự lạ (&, #, &lt;, &gt;, …)\nThống nhất cách định danh (vd: toàn bộ tên cột ngày như date_onset, date_report, date_death…)\n\nTên các cột trong linelist_raw được in bên dưới bằng cách sử dụng hàm names() từ base R. Ban đầu chúng ta có thể thấy rằng:\n\nMột số tên chứa khoảng trắng (vd: infection date)\nMột số mẫu tên khác nhau được sử dụng cho biến ngày (date onset và infection date)\nPhải có một tiêu đề được hợp nhất ở hai cột cuối cùng trong tệp .xlsx. Chúng tôi biết điều này vì tên của hai cột được hợp nhất (“merge_header”) được R gán cho cột đầu tiên và cột thứ hai được gán tên giữ chỗ “… 28” (vì lúc đó nó trống và là cột thứ 28).\n\n\nnames(linelist_raw)\n\n [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"     \n [5] \"hosp date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"...28\"          \n\n\nCHÚ Ý: Để tham chiếu tên một cột có chứa khoảng trắng, hãy bao quanh tên cột bằng dấu huyền, ví dụ: linelist$` '\\x60infection date\\x60'`. Lưu ý là trên bàn phím, dấu huyền (`) được phân biệt với dấu ngoặc đơn (’).\n\nLàm sạch tự động\nHàm clean_names() từ package janitor chuẩn hóa tên cột và biến chúng thành duy nhất bằng cách thực hiện như sau:\n\nChuyển đổi tất cả các tên cột thành chỉ bao gồm dấu gạch dưới, số và chữ cái\nCác ký tự có dấu được chuyển ngữ sang dạng ASCII (ví dụ: o tiếng Đức với âm sắc trở thành “o”, “enye” tiếng Tây Ban Nha trở thành “n”)\nTùy chọn viết hoa cho tên cột mới có thể được chỉ định bằng cách sử dụng đối số case = (mặc định là “snake”, các lựa chọn thay thế bao gồm “sentence”, “title”, “small_camel”…)\nBạn có thể chỉ định các tên thay thế cụ thể bằng cách cung cấp một vectơ tới đố số replace = (ví dụ: replace = c(onset = \"date_of_onset\"))\nĐây là một hướng dẫn trực tuyến\n\nSau đây, quy trình làm sạch bắt đầu bằng cách sử dụng hàm clean_names() trên bộ dữ liệu linelist thô.\n\n# pipe the raw dataset through the function clean_names(), assign result as \"linelist\"  \nlinelist &lt;- linelist_raw %&gt;% \n  janitor::clean_names()\n\n# see the new column names\nnames(linelist)\n\n [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"     \n [5] \"hosp_date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"x28\"            \n\n\nLƯU Ý: Tên cột cuối cùng “… 28” đã được đổi thành “x28”.\n\n\nLàm sạch tên cột thủ công\nViệc đặt tên lại các cột theo cách thủ công thường là cần thiết, ngay cả sau bước chuẩn hóa ở trên. Dưới đây, việc đổi tên được thực hiện bằng cách sử dụng hàm rename() từ package dplyr, như một phần của quy trình. rename() sử dụng cú pháp NEW = OLD - tên cột mới được đặt trước tên cột cũ.\nDưới đây, một lệnh đổi tên được thêm vào quy trình làm sạch. Các khoảng trắng đã được thêm vào một cách chọn lọc để căn chỉnh code dễ đọc hơn.\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)\n\nBây giờ bạn có thể thấy rằng tên các cột đã được thay đổi:\n\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nThay đối tên cột theo vị trí\nBạn cũng có thể đổi tên theo vị trí cột, thay vì tên cột, ví dụ:\n\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)\n\n\n\nĐổi tên bằng hàm select() và summarise()\nNhư một lối tắt, bạn cũng có thể đổi tên các cột bằng hàm select() và summarise() thuộc package dplyr. Hàm select() được sử dụng để chỉ giữ một số cột nhất định (sẽ được đề cập sau trong chương này). Hàm summarise() được đề cập trong các chương Nhóm dữ liệu và Bảng mô tả. Các hàm này cũng sử dụng định dạng new_name = old_name. Đây là một ví dụ:\n\nlinelist_raw %&gt;% \n  select(# NEW name             # OLD name\n         date_infection       = `infection date`,    # rename and KEEP ONLY these columns\n         date_hospitalisation = `hosp date`)\n\n\n\n\nCác thách thức khác\n\nCột trống tên trên file Excel\nR không thể nhận diện các cột trong bộ dữ liệu mà không có tên cột (tiêu đề). Vì vậy, nếu bạn nhập một bộ dữ liệu Excel có dữ liệu nhưng không có tiêu đề cột, R sẽ điền vào các tiêu đề đó mặc định như “… 1” hoặc “… 2”. Phần số đại diện cho số cột (ví dụ: nếu cột thứ 4 trong bộ dữ liệu không có tiêu đề, thì R sẽ mặc định đặt tên là “… 4”).\nBạn có thể làm sạch các tên cột này theo cách thủ công bằng cách tham chiếu số vị trí của chúng (xem ví dụ ở trên) hoặc tên được chỉ định của chúng (linelist_raw$...1).\n\n\nHợp nhất tên cột và ô Excel\nCác ô được hợp nhất trong file Excel là một sự cố thường xảy ra khi nhận dữ liệu. Như đã giải thích trong chương Chuyển đổi sang R, các ô được hợp nhất có thể dễ nhìn cho con người đọc dữ liệu, nhưng không phải là “cấu trúc dữ liệu cơ bản” và gây ra nhiều vấn đề cho máy khi nhận diện dữ liệu. R không thể chứa các ô đã hợp nhất.\nNhắc nhở người nhập liệu rằng dữ liệu có thể đọc được bởi con người không giống với dữ liệu mà máy có thể đọc được. Hãy cố gắng đào tạo người dùng về các nguyên tắc về dữ liệu tidy. Nếu có thể, hãy cố gắng thay đổi quy trình để dữ liệu có định dạng gọn gàng hơn mà không hợp nhất các ô.\n\nMỗi biến phải là một cột riêng biệt\nMỗi quan sát phải là một dòng riêng biệt\nMỗi giá trị phải là một ô riêng biệt\n\nKhi sử dụng hàm import() của package rio, giá trị trong một ô đã hợp nhất sẽ được gán cho ô đầu tiên và các ô tiếp theo sẽ trống.\nMột giải pháp để xử lý các ô đã hợp nhất là nạp dữ liệu bằng hàm readWorkbook() từ package openxlsx. Thiết lập đối số fillMergedCells = TRUE. Điều này cho phép giá trị trong ô hợp nhất được tham chiếu cho tất cả các ô nằm trong phạm vi hợp nhất.\n\nlinelist_raw &lt;- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)\n\nNGUY HIỂM: Nếu các tên cột được hợp nhất với readWorkbook(), có thể sẽ trả về tên cột trùng lặp, mà bạn sẽ cần phải sửa một cách thủ công - R không làm việc được với các tên cột trùng lặp! Bạn có thể đặt lại tên cho chúng bằng cách tham chiếu vị trí của chúng (ví dụ: cột 5), như được giải thích trong mục làm sạch tên cột thủ công.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#chọn-hoặc-đổi-vị-trí-cột",
    "href": "new_pages/cleaning.vn.html#chọn-hoặc-đổi-vị-trí-cột",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.5 Chọn hoặc đổi vị trí cột",
    "text": "7.5 Chọn hoặc đổi vị trí cột\nSử dụng hàm select() từ package dplyr để chọn các cột bạn muốn giữ lại và sắp xếp lại thứ tự của chúng trong bộ dữ liệu.\nCẨN TRỌNG: Trong các ví dụ dưới đây, bộ dữ liệu linelist được điều chỉnh với hàm select() và được hiển thị, nhưng không được lưu. Việc này được sử dụng phục vụ mục đích mô tả. Tên cột đã sửa đổi được in ra bằng cách chuyển tiếp bộ dữ liệu tới hàm names().\nDưới đây là TẤT CẢ các tên cột trong bộ dữ liệu linelist tại thời điểm làm sạch:\n\nnames(linelist)\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nGiữ cột\nGiữ lại những cột mong muốn\nViết tên cột cần giữ trong hàm select(), không có dấu ngoặc kép. Kết quả trả về sẽ xuất hiện trong bộ dữ liệu theo thứ tự mà bạn cung cấp. Lưu ý rằng nếu bạn chỉ định một cột không tồn tại, R sẽ báo lỗi (xem cách sử dụng hàm any_of() bên dưới nếu bạn không muốn gặp lỗi trong trường hợp này).\n\n# linelist dataset is piped through select() command, and names() prints just the column names\nlinelist %&gt;% \n  select(case_id, date_onset, date_hospitalisation, fever) %&gt;% \n  names()  # display the column names\n\n[1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\"\n[4] \"fever\"               \n\n\n\n\nHàm trợ giúp “tidyselect”\nCác hàm trợ giúp này được xây dựng để giúp bạn dễ dàng chỉ định các cột cần giữ, loại bỏ hoặc chuyển đổi. Chúng nằm trong package tidyselect, thuộc hệ sinh thái tidyverse và làm cơ sở cho cách chọn cột trong các hàm dplyr.\nVí dụ: nếu bạn muốn sắp xếp lại các cột, hàm everything() là một hàm hữu ích để biểu thị “tất cả các cột khác chưa được đề cập”. Lệnh dưới đây di chuyển các cột date_onset và date_hospitalisation lên cột đầu tiên (bên trái) của bộ dữ liệu, nhưng vẫn giữ tất cả các cột khác sau đó. Lưu ý rằng hàm everything() được viết bằng dấu ngoặc đơn trống:\n\n# move date_onset and date_hospitalisation to beginning\nlinelist %&gt;% \n  select(date_onset, date_hospitalisation, everything()) %&gt;% \n  names()\n\n [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"             \n [4] \"generation\"           \"date_infection\"       \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\nDưới đây là các hàm trợ giúp “tidyselect” khác cũng hoạt động trong các hàm dplyr như select(), across(), và summarise():\n\neverything() - tất cả các cột khác chưa được đề cập\nlast_col() - cột cuối cùng\nwhere() - áp dụng một hàm cho tất cả các cột và chọn những cột trả về giá trị TRUE\ncontains() - cột chứa một chuỗi ký tự\n\nVí dụ: select(contains(\"time\"))\n\nstarts_with() - khớp với các tiền tố được chỉ định\n\nVí dụ: select(starts_with(\"date_\"))\n\nends_with() - khớp với các hậu tố được chỉ định\n\nVí dụ: select(ends_with(\"_post\"))\n\nmatches() - để áp dụng một mệnh đề chính quy (regex)\n\nVí dụ: select(matches(\"[pt]al\"))\n\nnum_range() - một khoảng số học như x01, x02, x03\nany_of() - khớp NẾU cột tồn tại nhưng không báo lỗi nếu không tìm thấy\n\nVí dụ: select(any_of(date_onset, date_death, cardiac_arrest))\n\n\nNgoài ra, sử dụng các toán tử bình thường như c() để liệt kê danh sách cột, hoặc : cho các cột liên tiếp, ! cho đối lập, & cho VÀ, và | cho HOẶC.\nSử dụng where() để cụ thể tiêu chí logic cho các cột. Nếu đưa một hàm vào trong where(), hãy nhớ không bao gồm dấu ngoặc đơn trống của hàm đó. Câu lệnh bên dưới chọn các cột kiểu Số.\n\n# select columns that are class Numeric\nlinelist %&gt;% \n  select(where(is.numeric)) %&gt;% \n  names()\n\n[1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"     \n[6] \"ht_cm\"      \"ct_blood\"   \"temp\"      \n\n\nSử dụng contains() để chọn các cột trong đó tên cột chứa một chuỗi ký tự được chỉ định. ends_with() và starts_with() cung cấp thêm các lựa chọn khác nhau.\n\n# select columns containing certain characters\nlinelist %&gt;% \n  select(contains(\"date\")) %&gt;% \n  names()\n\n[1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\n[4] \"date_outcome\"        \n\n\nHàm matches() hoạt động tương tự như hàm contains() nhưng có thể được cung cấp một biểu thức chính quy (xem chương Ký tự và chuỗi), chẳng hạn như nhiều chuỗi được phân tách bằng toán tự OR trong dấu ngoặc đơn:\n\n# searched for multiple character matches\nlinelist %&gt;% \n  select(matches(\"onset|hosp|fev\")) %&gt;%   # note the OR symbol \"|\"\n  names()\n\n[1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"            \n[4] \"fever\"               \n\n\nCẨN TRỌNG: Nếu tên cột mà bạn đưa ra không tồn tại trong dữ liệu, máy có thể báo lỗi và dừng code của bạn. Cân nhắc sử dụng hàm any_of() để trích dẫn các cột có thể hoặc không thể tồn tại, đặc biệt hữu ích trong các lựa chọn loại trừ (loại bỏ).\nChỉ có một trong các cột này tồn tại, nhưng không có lỗi được báo và code sẽ tiếp tục các bước trong quy trình làm sạch.\n\nlinelist %&gt;% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %&gt;% \n  names()\n\n[1] \"date_onset\"\n\n\n\n\nXóa cột\nChỉ ra cột nào cần loại bỏ bằng cách đặt biểu tượng dấu trừ “-” ở phía trước tên cột (ví dụ: select(-outcome)) hoặc một vectơ tên các cột (như bên dưới). Tất cả các cột khác sẽ được giữ nguyên.\n\nlinelist %&gt;% \n  select(-c(date_onset, fever:vomit)) %&gt;% # remove date_onset and all columns from fever to vomit\n  names()\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \n [7] \"gender\"               \"hospital\"             \"lon\"                 \n[10] \"lat\"                  \"infector\"             \"source\"              \n[13] \"age\"                  \"age_unit\"             \"row_num\"             \n[16] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"            \n[19] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[22] \"x28\"                 \n\n\nBạn cũng có thể xóa một cột bằng cú pháp trong base R, bằng cách định nghĩa nó là NULL. Ví dụ:\n\nlinelist$date_onset &lt;- NULL   # deletes column with base R syntax \n\n\n\nHoạt động độc lập\nselect() cũng có thể được sử dụng như một lệnh độc lập (không bắt buộc trong chuỗi các bước làm sạch). Trong trường hợp này, đối số đầu tiên trong bộ dữ liệu gốc sẽ được tham chiếu.\n\n# Create a new linelist with id and age-related columns\nlinelist_age &lt;- select(linelist, case_id, contains(\"age\"))\n\n# display the column names\nnames(linelist_age)\n\n[1] \"case_id\"  \"age\"      \"age_unit\"\n\n\n\nThêm vào quy trình làm sạch\nTrong bộ dữ liệu linelist_raw, có một vài cột chúng ta không cần: row_num, merged_header, và x28. Chúng ta xóa chúng bằng lệnh select() trong chuỗi các bước làm sạch như sau:\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n\n    # remove column\n    select(-c(row_num, merged_header, x28))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#loại-bỏ-trùng-lặp",
    "href": "new_pages/cleaning.vn.html#loại-bỏ-trùng-lặp",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.6 Loại bỏ trùng lặp",
    "text": "7.6 Loại bỏ trùng lặp\nXem chương Loại bỏ trùng lặp để biết các tùy chọn mở rộng về cách loại bỏ dữ liệu trùng lặp. Chỉ một ví dụ rất đơn giản về cách loại bỏ hàng trùng lặp được trình bày ở chương này.\nPackage dplyr cung cấp hàm distinct(). Hàm này kiểm tra tất cả các hàng và rút gọn bộ dữ liệu cho chỉ còn các hàng là duy nhất. Nghĩa là, nó loại bỏ 100% các hàng trùng lặp.\nKhi đánh giá các hàng trùng lặp, hàm này sẽ thực hiện trên các cột được chỉ định - mặc định nó sẽ xem xét tất cả các cột. Như trình bày trong chương loại bỏ trùng lặp, bạn có thể điều chỉnh phạm vi cột để việc khảo sát tính duy nhất của các hàng sẽ chỉ được đánh giá trong phạm vi một số cột nhất định.\nTrong ví dụ đơn giản này, chúng ta chỉ cần thêm câu lệnh trống distinct() vào chuỗi các bước làm sạch. Điều này đảm bảo không có hàng nào là bản sao 100% của các hàng khác (được đánh giá trên tất cả các cột).\nChúng ta bắt đầu với nrow(linelist) hàng trong bộ linelist.\n\nlinelist &lt;- linelist %&gt;% \n  distinct()\n\nSau khi loại bỏ trùng lặp, thì bộ dữ liệu mới có nrow(linelist) hàng. Bất kỳ hàng nào bị xóa cũng có thể là 100% bản sao của các hàng khác.\nDưới đây, lệnh distinct() được thêm vào quy trình làm sạch:\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n    \n    # de-duplicate\n    distinct()",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#tạo-và-biến-đổi-cột",
    "href": "new_pages/cleaning.vn.html#tạo-và-biến-đổi-cột",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.7 Tạo và biến đổi cột",
    "text": "7.7 Tạo và biến đổi cột\nChúng tôi khuyến khích sử dụng hàm mutate() trong package dplyr để thêm một cột mới hoặc để sửa đổi một cột sẵn có.\nDưới đây là một ví dụ về tạo cột mới với hàm mutate(). Cú pháp là: mutate(new_column_name = value or transformation)\nTrong Stata, điều này tương tự như lệnh generate, nhưng hàm mutate() trong R còn có thể được sử dụng để điều chỉnh cột đã tồn tại.\n\nTạo cột mới\nTính năng cơ bản nhất của hàm mutate() là để tạo một cột mới, có thể thấy trong ví dụ dưới đây. Nó tạo một cột mới new_col trong đó giá trị trong mỗi hàng đều là 10.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(new_col = 10)\n\nBạn cũng có thể tham chiếu các giá trị trong các cột khác, để thực hiện phép tính toán. Dưới đây, cột mới bmi được tạo để tính chỉ số khối cơ thể (BMI) cho mỗi trường hợp - như được tính bằng công thức BMI = kg/m^2, sử dụng cột ht_cm và cột wt_kg.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\n\nNếu tạo nhiều cột mới, hãy tách riêng từng cột bằng dấu phẩy và dòng mới. Dưới đây là các ví dụ về tạo các cột mới, bao gồm một cột mà chứa các giá trị từ các cột khác được kết hợp bằng hàm str_glue() từ package stringr (xem chương Ký tự và chuỗi).\n\nnew_col_demo &lt;- linelist %&gt;%                       \n  mutate(\n    new_var_dup    = case_id,             # new column = duplicate/copy another existing column\n    new_var_static = 7,                   # new column = all values the same\n    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # new column = pasting together values from other columns\n    ) %&gt;% \n  select(case_id, hospital, date_hospitalisation, contains(\"new\"))        # show only new columns, for demonstration purposes\n\nKiểm tra các cột mới. Đối với mục tiêu minh họa, chỉ các cột mới và các cột được sử dụng để tạo cột mới được hiển thị:\n\n\n\n\n\n\nMẸO: Một biến thể của hàm mutate() là hàm transmute(). Hàm này thêm một cột mới giống như mutate(), nhưng cũng bỏ/xóa tất cả các cột khác mà bạn không đề cập trong dấu ngoặc đơn của hàm.\n\n# HIDDEN FROM READER\n# removes new demo columns created above\n# linelist &lt;- linelist %&gt;% \n#   select(-contains(\"new_var\"))\n\n\n\nĐịnh dạng lại kiểu dữ liệu của cột\nMột số hàm sẽ không chạy được trên các cột chứa giá trị là ngày tháng, số hoặc giá trị logic (TRUE/FALSE) nếu chúng không được định nghĩa chính xác. Có sự khác biệt giữa giá trị “2” của kiểu dữ liệu dạng ký tự và giá trị 2 của kiểu dữ liệu dạng số!\nCó nhiều cách để thiết lập kiểu dữ liệu cho cột khi nhập dữ liệu, nhưng chúng thường phức tạp. Xem chương R cơ bản về kiểu dữ liệu để tìm hiểu thêm về cách chuyển đổi kiểu dữ liệu đối tượng và cột.\nĐầu tiên, hãy kiểm tra các cột quan trọng để xem chúng đã đúng định dạng chính xác chưa. Chúng ta có thể thực hiện điều này bằng hàm skim().\nVí dụ, ở đây kiểu dữ liệu của cột age là dạng ký tự. Để thực hiện các phân tích định lượng, chúng ta cần những giá trị số này được định dạng là dạng số!\n\nclass(linelist$age)\n\n[1] \"character\"\n\n\nTương tự kiểu dữ liệu của cột date_onset cũng là ký tự! Để thực hiện phân tích, những cột ngày này phải được định dạng là dạng ngày tháng!\n\nclass(linelist$date_onset)\n\n[1] \"character\"\n\n\nĐể giải quyết vấn đề này, hãy sử dụng hàm mutate() để định dạng và chuyển đổi lại kiểu dữ liệu cho một cột. Chúng ta giữ nguyên cột đó và định dạng lại sang một kiểu khác. Dưới đây là một ví dụ cơ bản, thực hiện định dạng lại cột age dưới dạng số:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age = as.numeric(age))\n\nTheo cách tương tự, bạn có thể sử dụng hàm as.character() và hàm as.logical(). Để chuyển đổi sang kiểu danh mục, bạn có thể sử dụng hàm factor() từ base R hoặc hàm as_factor() từ package forcats. Đọc thêm ở chương Factors.\nBạn phải cẩn thận khi định dạng lại cột sang kiểu Ngày, các giải thích chi tiết hơn được đề cập ở chương Làm việc với ngày tháng. Thông thường, tất cả các giá trị ngày ban đầu phải ở cùng một định dạng cần chuyển đổi để có thể sử dụng (ví dụ: “MM/DD/YYYY” hoặc “DD MM YYYY”). Sau khi chuyển đổi thành thành kiểu Ngày, hãy kiểm tra dữ liệu của bạn để xác nhận rằng mỗi giá trị đã được chuyển đổi chính xác.\n\n\nDữ liệu được nhóm\nNếu bộ dữ liệu của bạn đã được nhóm (xem chương Nhóm dữ liệu), hàm mutate() có thể hoạt động khác so với khi bộ dữ liệu không được nhóm. Bất kỳ hàm tổng hợp nào, như mean(), median(), max(), v.v. sẽ tính theo nhóm, không phải theo tất cả các hàng.\n\n# age normalized to mean of ALL rows\nlinelist %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# age normalized to mean of hospital group\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\nĐọc thêm về cách sử dụng hàm mutate() trên các bộ dữ liệu được nhóm ở tài liệu về mutate trong package tidyverse.\n\n\nBiến đổi nhiều cột\nThông thường, để viết mã ngắn gọn, bạn muốn áp dụng cùng một biến đổi trên nhiều cột cùng một lúc. Một cách biến đổi có thể được áp dụng trên nhiều cột cùng một lúc bằng cách sử dụng hàm across() từ package dplyr (cũng trong package tidyverse). Hàm across() có thể được sử dụng với bất kỳ hàm nào trong packe dplyr, nhưng thường được sử dụng với hàm select(), mutate(), filter(), hoặc summarise(). Xem cách sử dụng hàm summarise() trong chương Bảng mô tả.\nChỉ định các cột bằng đối số .cols = và các hàm được sử dụng bằng .fns =. Bất kỳ đối số bổ sung nào để cung cấp cho hàm .fns đều có thể được bao gồm sau dấu phẩy, vẫn nằm trong hàm across().\n\nLựa chọn cột với hàm across()\nChỉ định các cột tới đối số .cols =. Bạn có thể đặt tên cho chúng một cách riêng lẻ hoặc sử dụng các hàm trợ giúp “tidyselect”. Cụ thể hàm tới đối số .fns =. Lưu ý rằng cách sử dụng hàm được trình bày bên dưới, hàm được viết mà không có dấu ngoặc đơn ().\nỞ đây, phép biến đổi as.character() được áp dụng cho tên cột cụ thể trong hàm across().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n\nCác hàm trợ giúp “tidyselect” có sẵn để hỗ trợ bạn trong việc chỉ định các cột. Chúng được trình bày chi tiết ở trên trong mục Chọn và sắp xếp thứ tự cột, bao gồm: everything(), last_col(), where(), starts_with(), ends_with(), contains(), matches(), num_range() và any_of().\nĐây là một ví dụ về cách thay đổi tất cả các cột thành phân lớp dạng ký tự:\n\n#to change all columns to character class\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = everything(), .fns = as.character))\n\nChuyển đổi tất cả các cột thành dạng ký tự có tên chứa chuỗi ký tự “date” (lưu ý vị trí của dấu phẩy và dấu ngoặc đơn):\n\n#to change all columns to character class\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\n\nDưới đây, một ví dụ về việc thay đổi các cột hiện là phân lớp POSIXct (một kiểu dữ liệu ngày tháng thô hiển thị mốc thời gian) - hay nói cách khác, khi hàm is.POSIXct() đánh giá là TRUE. Sau đó, chúng ta muốn áp dụng hàm as.Date() cho các cột này để chuyển đổi chúng thành kiểu Ngày thông thường.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))\n\n\nLưu ý rằng trong hàm across(), chúng tôi cũng sử dụng hàm where() tương tự như hàm is.POSIXct được đánh giá là TRUE hoặc FALSE.\n\nLưu ý rằng hàm is.POSIXct() là từ package lubridate. Các hàm “is” tương tự khác như is.character(), is.numeric(), và is.logical() thì thuộc base R\n\n\n\nHàm across()\nBạn có thể đọc tài liệu với hàm ?across để biết chi tiết về cách sử dụng hàm across(). Một vài điểm tóm tắt: có một số cách để chỉ định (các) hàm để thực hiện trên một cột và bạn thậm chí có thể tự chỉ định các hàm riêng của mình:\n\nBạn có thể cung cấp tên hàm đứng một mình (ví dụ: mean hoặc as.character)\n\nBạn có thể cung cấp hàm theo phong cách purrr (ví dụ: ~ mean(.x, na.rm = TRUE)) (xem chương Lặp, vòng lặp, và danh sách)\n\nBạn có thể chỉ định nhiều hàm bằng cách cung cấp danh sách (ví dụ: list(mean = mean, n_miss = ~ sum(is.na(.x))).\nNếu bạn cung cấp nhiều hàm, nhiều cột được chuyển đổi sẽ được trả về dựa trên mỗi cột ban đầu, với các tên duy nhất theo định dạng col_fn. Bạn có thể điều chỉnh cách đặt tên các cột mới với đối số .names = bằng cách sử dụng cú pháp glue (xem chương Ký tự và chuỗi) trong đó {.col} và {.fn} được viết tắt cho cột và hàm đầu vào.\n\nDưới đây là một số tài nguyên trực tuyến về cách sử dụng hàm across(): creator Hadley Wickham’s thoughts/rationale\n\n\n\nHàm coalesce()\nHàm dplyr này tìm giá trị không bị thiếu đầu tiên tại mỗi vị trí. Nó “điền vào” các giá trị còn thiếu với giá trị có sẵn đầu tiên theo thứ tự bạn chỉ định.\nĐây là một ví dụ ngoài phạm vi của bộ dữ liệu: Giả sử bạn có hai vectơ, một vectơ chứa thông tin về làng nơi bệnh nhân được phát hiện và một vectơ chứa thông tin làng nơi bệnh nhân cư trú . Bạn có thể sử dụng hàm coalesce() để chọn giá trị không bị thiếu đầu tiên cho mỗi biến số:\n\nvillage_detection &lt;- c(\"a\", \"b\", NA,  NA)\nvillage_residence &lt;- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage &lt;- coalesce(village_detection, village_residence)\nvillage    # print\n\n[1] \"a\" \"b\" \"a\" \"d\"\n\n\nĐiều này hoạt động tương tự nếu bạn cung cấp các cột trong bộ dữ liệu: đối với mỗi hàng, hàm sẽ gán giá trị cột mới với giá trị không bị thiếu đầu tiên trong các cột bạn đã cung cấp (theo thứ tự được cung cấp).\n\nlinelist &lt;- linelist %&gt;% \n  mutate(village = coalesce(village_detection, village_residence))\n\nĐây là một ví dụ về thao tác “theo hàng (row-wise)”. Để biết các phép tính theo hàng phức tạp hơn, hãy xem chương bên dưới về Tính toán theo hàng.\n\n\nToán lũy tích\nNếu bạn muốn một cột thể hiện tổng tích lũy/trung bình/tối thiểu/tối đa, v.v. như đánh giá các hàng của bộ dữ liệu cho đến thời điểm đó, hãy sử dụng các hàm sau:\ncumsum() trả về tổng tích lũy, như được hiển thị bên dưới:\n\nsum(c(2,4,15,10))     # returns only one number\n\n[1] 31\n\ncumsum(c(2,4,15,10))  # returns the cumulative sum at each step\n\n[1]  2  6 21 31\n\n\nĐiều này có thể được sử dụng trong bộ dữ liệu khi tạo một cột mới. Ví dụ: để tính toán số ca lũy tích mỗi ngày trong một đợt bùng dịch, hãy xem xét đoạn code như sau:\n\ncumulative_case_counts &lt;- linelist %&gt;%  # begin with case linelist\n  count(date_onset) %&gt;%                 # count of rows per day, as column 'n'   \n  mutate(cumulative_cases = cumsum(n))  # new column, of the cumulative sum at each row\n\nDưới đây là 10 hàng đầu tiên:\n\nhead(cumulative_case_counts, 10)\n\n   date_onset n cumulative_cases\n1  2012-04-15 1                1\n2  2012-05-05 1                2\n3  2012-05-08 1                3\n4  2012-05-31 1                4\n5  2012-06-02 1                5\n6  2012-06-07 1                6\n7  2012-06-14 1                7\n8  2012-06-21 1                8\n9  2012-06-24 1                9\n10 2012-06-25 1               10\n\n\nXem chương Đường cong dịch bệnh để biết cách lập biểu đồ các trường hợp mới mắc tích lũy với epicurve.\nXem thêm:\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall()\n\n\nSử dụng base R\nĐể định nghĩa một cột mới (hoặc tái định nghĩa lại một cột) bằng cách sử dụng base R, hãy viết tên của bộ dữ liệu, được liên kết với $, vào tên cột mới (hoặc cột được sửa đổi). Sử dụng toán tử gán &lt;- để xác định (các) giá trị mới. Hãy nhớ rằng khi sử dụng base R, bạn phải chỉ định tên bộ dữ liệu trước tên cột (ví dụ: dataframe$column). Đây là một ví dụ về cách tạo cột bmi bằng cách sử dụng base R:\n\nlinelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)\n\n\n\nThêm vào chuỗi làm sạch\nCode dưới đây minh hoạt cách thêm một cột mới vào chuỗi làm sạch và định dạng lại kiểu dữ liệu của biến.\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # de-duplicate\n    distinct() %&gt;% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    # add new column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;% \n  \n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#mã-hóa-lại-giá-trị",
    "href": "new_pages/cleaning.vn.html#mã-hóa-lại-giá-trị",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.8 Mã hóa lại giá trị",
    "text": "7.8 Mã hóa lại giá trị\nDưới đây là một số tình huống mà bạn cần mã hóa lại (thay đổi) các giá trị:\n\nđể chỉnh sửa một giá trị cụ thể (ví dụ: một ngày có năm hoặc định dạng không chính xác)\nđể hợp nhất các giá trị được viết sai chính tả\nđể tạo một cột chứa giá trị phân loại mới\nđể tạo một cột chứa danh mục số mới (ví dụ: danh mục độ tuổi)\n\n\nGiá trị cụ thể\nĐể thay đổi các giá trị theo cách thủ công, bạn có thể sử dụng hàm recode() bên trong hàm mutate().\nHãy tưởng tượng có một ngày không bình thường trong dữ liệu (ví dụ: “2014-14-15”): bạn có thể sửa ngày theo cách thủ công trong dữ liệu gốc hoặc, bạn có thể ghi thay đổi trong chuỗi các bước làm sạch thông qua mutate() và recode(). Cách thứ hai sẽ rõ ràng hơn và có thể được tái lập lại cho bất kỳ ai khác muốn hiểu hoặc lặp lại phân tích của bạn.\n\n# fix incorrect values                   # old value       # new value\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\n\nDòng mutate() ở trên có thể được đọc là: “biến đổi cột date_onset bằng với cột date_onset sau khi được mã hóa lại để GIÁ TRỊ CŨ được đổi thành GIÁ TRỊ MỚI”. Lưu ý rằng cú pháp (CŨ = MỚI) này của hàm recode() ngược lại với hầu hết các cú pháp trong R (mới = cũ). Cộng đồng phát triển R đang làm việc để sửa đổi điều này.\nSau đây là một ví dụ khác về việc mã hóa lại nhiều giá trị trong một cột.\nTrong bộ dữ liệu linelist, các giá trị trong cột “hospital” phải được làm sạch. Có một số cách viết khác nhau và nhiều giá trị bị thiếu.\n\ntable(linelist$hospital, useNA = \"always\")  # print table of all unique values, including missing  \n\n\n                     Central Hopital                     Central Hospital \n                                  11                                  457 \n                          Hospital A                           Hospital B \n                                 290                                  289 \n                    Military Hopital                    Military Hospital \n                                  32                                  798 \n                    Mitylira Hopital                    Mitylira Hospital \n                                   1                                   79 \n                               Other                         Port Hopital \n                                 907                                   48 \n                       Port Hospital St. Mark's Maternity Hospital (SMMH) \n                                1756                                  417 \n  St. Marks Maternity Hopital (SMMH)                                 &lt;NA&gt; \n                                  11                                 1512 \n\n\nLệnh recode() bên dưới tái định nghĩa lại cột “hospital” theo cột hiện tại “hospital”, nhưng với các thay đổi mã hóa được chỉ định. Đừng quên dấu phẩy sau mỗi dòng mã hóa lại!\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital,\n                     # for reference: OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\n\nBây giờ chúng ta thấy các cách viết trong cột hospital đã được sửa chữa và hợp nhất:\n\ntable(linelist$hospital, useNA = \"always\")\n\n\n                    Central Hospital                           Hospital A \n                                 468                                  290 \n                          Hospital B                    Military Hospital \n                                 289                                  910 \n                               Other                        Port Hospital \n                                 907                                 1804 \nSt. Mark's Maternity Hospital (SMMH)                                 &lt;NA&gt; \n                                 428                                 1512 \n\n\nMẸO: Số lượng khoảng trắng trước và sau dấu bằng không quan trọng. Hãy làm cho code của bạn dễ đọc hơn bằng cách căn chỉnh dấu = cho tất cả hoặc hầu hết các hàng. Ngoài ra, hãy cân nhắc thêm hàng bình luận để làm rõ cho người đọc biết bên nào CŨ và bên nào MỚI.\nMẸO: Đôi khi tồn tại một giá trị ký tự trống trong bộ dữ liệu (không được nhận dạng là giá trị missing của R - NA). Bạn có thể tham chiếu giá trị này bằng hai dấu ngoặc kép không có khoảng trắng ở giữa (““).\n\n\nTheo logic\nDưới đây, chúng ta trình bày cách mã hóa lại các giá trị trong một cột bằng cách sử dụng logic và điều kiện:\n\nSử dụng hàm replace(), ifelse() và if_else() cho logic đơn giản\nSử dụng hàm case_when() cho logic phức tạp\n\n\n\nLogic đơn giản\n\nreplace()\nĐể mã hóa lại với các tiêu chí logic đơn giản, bạn có thể sử dụng hàm replace() bên trong hàm mutate(). replace() là một hàm từ base R. Sử dụng một điều kiện logic để cụ thể các hàng cần thay đổi. Cú pháp chung là:\nmutate(col_to_change = replace(col_to_change, criteria for rows, new value)).\nMột tình huống phổ biến để sử dụng replace() là chỉ thay đổi một giá trị trong một hàng, bằng cách sử dụng định danh hàng duy nhất. Dưới đây, giới tính được thay đổi thành “Female” trong hàng mà cột case_id có giá trị là “2195”.\n\n# Example: change gender of one specific observation to \"Female\" \nlinelist &lt;- linelist %&gt;% \n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\"))\n\nLệnh tương tự sử dụng cú pháp trong base R và dấu ngoặc vuông [] ở bên dưới. Nó có nội dung là “Thay đổi giá trị của cột gender trong bộ dữ liệu linelist (đối với các hàng mà cột case_id của linelist có giá trị ‘2195’) thành ‘Female’”.\n\nlinelist$gender[linelist$case_id == \"2195\"] &lt;- \"Female\"\n\n\n\nifelse() và if_else()\nMột cách khác áp dụng cho logic đơn giản là hàm ifelse() và hàm tương tự là if_else(). Tuy nhiên, trong hầu hết các trường hợp để mã hóa lại, cách rõ ràng hơn là sử dụng hàm case_when() (chi tiết bên dưới). Câu lệnh “if else” này là các phiên bản đơn giản hóa của câu lệnh lập trình if và else. Cú pháp chung là:\nifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)\nDưới đây, cột source_known được định nghĩa. Giá trị của nó trong một hàng được đặt thành “known” nếu giá trị của hàng trong cột source không bị thiếu. Nếu thiếu giá trị trong cột source, thì giá trị trong source_known được đặt thành “unknown”.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n\nif_else() là một phiên bản đặc biệt từ package dplyr để xử lý ngày tháng. Lưu ý rằng nếu giá trị ‘true’ là một ngày thì giá trị ‘false’ cũng phải đủ điều kiện là một ngày, do đó sử dụng giá trị đặc biệt NA_real_ thay vì chỉ NA.\n\n# Create a date of death column, which is NA if patient has not died.\nlinelist &lt;- linelist %&gt;% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))\n\nTránh lồng ghép nhiều lệnh ifelse với nhau… thay vào đó hãy sử dụng case_when()! case_when() dễ đọc hơn và bạn sẽ mắc ít lỗi hơn.\n\n\n\n\n\n\n\n\n\nNgoài phạm vi của bộ dữ liệu, nếu bạn muốn một đối tượng được sử dụng trong code của mình chuyển đổi giá trị của nó, hãy xem xét sử dụng hàm switch() từ base R.\n\n\n\nLogic phức tạp\nSử dụng case_when() của package dplyr nếu bạn đang mã hóa lại thành nhiều nhóm mới hoặc nếu bạn cần sử dụng các câu lệnh logic phức tạp để mã hóa lại các giá trị. Hàm này đánh giá mọi hàng trong bộ dữ liệu, đánh giá xem các hàng có đáp ứng các tiêu chí đã chỉ định hay không và chỉ định giá trị mới chính xác.\nCâu lệnh case_when() bao gồm hai cấu phần là Bên tay Phải (RHS) và Bên tay Trái (LHS) được phân tách bằng “dấu ngã” ~. Các tiêu chí logic nằm ở phía bên trái và các giá trị tương ứng nằm ở phía bên phải của mỗi mệnh đề. Các mệnh đề được phân tách bằng dấu phẩy.\nVí dụ: chúng tôi sử dụng cột age và age_unit để tạo cột age_years:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # if unit is years\n            age_unit == \"months\" ~ age/12,    # if unit is months, divide age by 12\n            is.na(age_unit)      ~ age,       # if age unit is missing, assume years\n            TRUE                 ~ NA_real_)) # any other circumstance, assign NA (missing)\n\nKhi mỗi hàng trong dữ liệu được đánh giá, các tiêu chí được áp dụng/đánh giá theo thứ tự đã viết trong case_when() - từ trên xuống dưới. Nếu tiêu chí đánh giá đầu tiên trả kết quả là TRUE cho một hàng nhất định, giá trị Bên tay phải sẽ được gán và các tiêu chí còn lại sẽ không được kiểm tra cho hàng đó. Vì vậy, tốt nhất là bạn nên viết các tiêu chí đánh giá cụ thể nhất lên đầu, theo sau bởi các tiêu chí chung hơn. Các dòng không đáp ứng bất kỳ tiêu chí nào sẽ được gán giá trị NA.\nĐôi khi, bạn muốn gán một giá trị cụ thể cho biến mới mà không thỏa mãn bất kỳ tiêu chí nào, hãy đặt TRUE ở phía bên trái của tiêu chí đánh giá cuối cùng. Phía bên phải của mệnh đề này có thể được gán một giá trị như “kiểm tra tôi! (check me)” hoặc missing.\nDưới đấy là một ví dụ khác sử dụng case_when() để tạo cột mới phân loại tình trạng bệnh nhân, dựa theo định nghĩa ca bệnh là đã xác định hoặc nghi ngờ:\n\nlinelist &lt;- linelist %&gt;% \n     mutate(case_status = case_when(\n          \n          # if patient had lab test and it is positive,\n          # then they are marked as a confirmed case \n          ct_blood &lt; 20                   ~ \"Confirmed\",\n          \n          # given that a patient does not have a positive lab result,\n          # if patient has a \"source\" (epidemiological link) AND has fever, \n          # then they are marked as a suspect case\n          !is.na(source) & fever == \"yes\" ~ \"Suspect\",\n          \n          # any other patient not addressed above \n          # is marked for follow up\n          TRUE                            ~ \"To investigate\"))\n\nNGUY HIỂM: Các giá trị ở phía bên phải đều phải cùng một phần lớp - số, ký tự, ngày tháng, lôgic, v.v. Để gán giá trị thiếu (NA), bạn có thể cần sử dụng các biến thể đặc biệt của NA như NA_character_, NA_real_ (cho số hoặc POSIX) và as.Date(NA). Đọc thêm trong chương Làm việc với ngày tháng.\n\n\nGiá trị missing\nDưới đây là các hàm đặc biệt để xử lý các giá trị bị thiếu trong khi làm sạch dữ liệu.\nXem chương về Dữ liệu Missing để biết thêm các mẹo chi tiết về xác định và xử lý các giá trị bị thiếu. Ví dụ, hàm is.na() kiểm tra một cách logic sự thiếu giá trị.\nreplace_na()\nĐể thay đổi các giá trị bị thiếu (NA) thành một giá trị cụ thể, chẳng hạn như “Missing”, hãy sử dụng hàm replace_na() trong hàm mutate() trong package dplyr. Lưu ý rằng điều này được sử dụng theo cách tương tự như hàm recode ở trên - tên của biến phải được lặp lại trong replace_na().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = replace_na(hospital, \"Missing\"))\n\nfct_explicit_na()\nĐây là một hàm từ package forcats. Package forcats xử lý các cột dạng Factor. Factor là cách của R để xử lý các giá trị có thứ tự như c(\"First\", \"Second\", \"Third\") hoặc để thiết lập thứ tự cho các giá trị (ví dụ: bệnh viện) xuất hiện trong bảng và biểu đồ. Xem chương Factors.\nNếu dữ liệu của bạn là kiểu Factor và bạn đang cố gắng chuyển giá trị NA thành “Missing” bằng cách sử dụng hàm replace_na(), bạn sẽ gặp lỗi này: invalid factor level, NA generated. Bạn đã cố gắng thêm “Missing” làm giá trị, trong khi nó đã không được xác định là một thứ bậc trong cột Factor, và câu lệnh bị từ chối.\nCách dễ nhất để giải quyết vấn đề này là sử dụng hàm forcats fct_explicit_na() để chuyển đổi một cột thành kiểu Factor và chuyển đổi các giá trị NA thành ký tự “(Missing)”.\n\nlinelist %&gt;% \n  mutate(hospital = fct_explicit_na(hospital))\n\nMột giải pháp thay thế chậm hơn sẽ là thêm thứ bậc cho cột Factor bằng cách sử dụng hàm fct_expand() và sau đó chuyển đổi các giá trị bị thiếu.\nna_if()\nĐể chuyển đổi một giá trị cụ thể thành NA, hãy sử dụng hàm na_if() trong package dplyr. Hàm này thực hiện thao tác ngược lại với hàm replace_na(). Trong ví dụ bên dưới, bất kỳ giá trị nào bị “Missing” trong cột hospital đều được chuyển đổi thành NA.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n\nLưu ý: na_if() không thể sử dụng cho điều kiện logic (ví dụ: “all values &gt; 99”) - hãy sử dụng replace() hoặc case_when() cho điều này:\n\n# Convert temperatures above 40 to NA \nlinelist &lt;- linelist %&gt;% \n  mutate(temp = replace(temp, temp &gt; 40, NA))\n\n# Convert onset dates earlier than 1 Jan 2000 to missing\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = replace(date_onset, date_onset &gt; as.Date(\"2000-01-01\"), NA))\n\n\n\nTừ điển làm sạch\nSử dụng package matchmaker trong R và hàm match_df() để làm sạch bộ dữ liệu bằng từ điển làm sạch.\n\nTạo từ điển làm sạch với 3 cột:\n\nCột “từ” (giá trị không chính xác)\n\nCột “tới” (giá trị chính xác)\n\nMột cột chỉ định cột cho các thay đổi sẽ được áp dụng (hoặc “.global” để áp dụng cho tất cả các cột)\n\n\nLưu ý: các mục từ điển .global sẽ bị ghi đè bởi các mục từ điển theo cột cụ thể.\n\n\n\n\n\n\n\n\n\n\nNạp tệp từ điển vào R. Ví dụ này có thể được tải xuống theo hướng dẫn trong chương Tải sách và dữ liệu.\n\n\ncleaning_dict &lt;- import(\"cleaning_dict.csv\")\n\n\nChuyển bộ dữ liệu linelist ban đầu đến hàm match_df(), xác định dictionary = là bộ dữ liệu từ điển làm sạch. Đối số from = dùng để chỉ định cột trong từ điển tham chiếu chứa các giá trị “cũ”, đối số by = dùng để chỉ định cột trong từ điển tham chiếu chứa các giá trị “mới” tương ứng và cột thứ ba liệt kê cột thực hiện thay đổi. Sử dụng .global trong đối số by = để áp dụng thay đổi trên tất cả các cột. Cột từ điển thứ tư order có thể được sử dụng để chỉ định thức bậc của các giá trị mới.\n\nBạn có thể đọc thêm về hàm ở package documentation bằng cách chạy ?match_df. Lưu ý rằng hàm này có thể mất nhiều thời gian để chạy trên dữ liệu lớn.\n\nlinelist &lt;- linelist %&gt;% \n  matchmaker::match_df(\n          dictionary = cleaning_dict,  # name of your dictionary\n          from = \"from\",               # column with values to be replaced (default is col 1)\n          to = \"to\",                   # column with final values (default is col 2)\n          by = \"col\"                   # column with column names (default is col 3)\n  )\n\nBây giờ, hãy cuộn sang bên phải để xem các giá trị đã thay đổi như thế nào - đặc biệt là gender (chữ thường thành chữ hoa) và tất cả các cột triệu chứng đã được chuyển từ có/không thành 1/0.\n\n\n\n\n\n\nLưu ý rằng tên cột của bạn trong từ điển làm sạch phải tương ứng với tên tại thời điểm trong script làm sạch của bạn. Xem tài liệu tham khảo trực tuyến về package linelist để biết thêm chi tiết.\n\nThêm vào chuỗi làm sạch\nDưới đây, một số cột mới và biến đổi cột được thêm vào chuỗi các bước làm sạch.\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # de-duplicate\n    distinct() %&gt;% \n  \n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n   # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n   ###################################################\n\n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#num_cats",
    "href": "new_pages/cleaning.vn.html#num_cats",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.9 Biến danh mục số",
    "text": "7.9 Biến danh mục số\nỞ đây chúng tôi mô tả một số cách tiếp cận đặc biệt để tạo cột dạng danh mục từ các cột dạng số. Các ví dụ phổ biến bao gồm danh mục độ tuổi, nhóm giá trị trong phòng thí nghiệm, v.v. Ở đây chúng ta sẽ thảo luận:\n\nage_categories(), từ package epikit\n\ncut(), từ base R\n\ncase_when()\n\nChia khoảng phân vị với quantile() and ntile()\n\n\nĐánh giá phân phối\nTrong ví dụ này, chúng tôi sẽ tạo một cột age_cat bằng cách sử dụng cột age_years.\n\n#check the class of the linelist variable age\nclass(linelist$age_years)\n\n[1] \"numeric\"\n\n\nTrước tiên, hãy kiểm tra phân phối dữ liệu của bạn để đưa ra các điểm cắt thích hợp. Xem chương ggplot cơ bản.\n\n# examine the distribution\nhist(linelist$age_years)\n\n\n\n\n\n\n\n\n\nsummary(linelist$age_years, na.rm=T)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.04   23.00   84.00     107 \n\n\nCẨN TRỌNG: Đôi khi, các biến số sẽ được nhập vào dưới dạng kiểu “ký tự”. Điều này xảy ra nếu có các ký tự không phải số trong một số giá trị, ví dụ: có bản ghi nhập “2 tháng” cho biến tuổi hoặc (tùy thuộc vào cài đặt ngôn ngữ R của bạn) nếu dấu phẩy được sử dụng cho số thập phân (ví dụ: “4,5”nghĩa là bốn năm rưỡi).\n\n\n\nage_categories()\nVới package epikit, bạn có thể sử dụng hàm age_categories() để dễ dàng phân loại và gắn nhãn các cột dạng số (lưu ý: hàm này cũng có thể được áp dụng cho các biến ngoài biến tuổi). Như một “phần thưởng”, cột trả về tự động là một cột dạng factor có thứ tự.\nDưới đây là các yêu cầu đầu vào:\n\nMột vectơ (cột) dạng số\n\nĐối sốc breakers = - cung cấp một vectơ dạng số của các điểm cắt cho các phân nhóm mới.\n\nĐầu tiên, ví dụ đơn giản nhất:\n\n# Simple example\n################\npacman::p_load(epikit)                    # load package\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(             # create new column\n      age_years,                            # numeric column to make groups from\n      breakers = c(0, 5, 10, 15, 20,        # break points\n                   30, 40, 50, 60, 70)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    27     7   107 \n\n\nCác giá trị cắt bạn chỉ định mặc định là các giới hạn thấp hơn - nghĩa là chúng được đưa vào nhóm “cao hơn”/các nhóm “mở” ở phía dưới/bên trái. Như trình bày dưới đây, bạn có thể thêm 1 vào mỗi giá trị cắt để đạt được các nhóm mà được “mở” ở trên cùng/bên phải.\n\n# Include upper ends for the same categories\n############################################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  &lt;NA&gt; \n 1469  1195  1040   770  1149   547   231    70    24     6   107 \n\n\nBạn có thể điều chỉnh cách hiển thị nhãn bằng separator =. Giá trị mặc định là “-”\nBạn có thể điều chỉnh cách xử lý các số ở hàng đầu, với đối số ceiling =. Thiết lập mức giới hạn cắt trên với ceiling = TRUE. Trong cách sử dụng này, giá trị cắt cao nhất được cung cấp là “ceiling” và danh mục “XX+” không được tạo. Bất kỳ giá trị nào trên giá trị cắt cao nhất (hoặc upper =, nếu được xác định) đều được phân loại là NA. Dưới đây là một ví dụ với ceiling = TRUE, do đó không có danh mục nào là XX + và các giá trị trên 70 (giá trị cắt cao nhất) được chỉ định là NA.\n\n# With ceiling set to TRUE\n##########################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 is ceiling, all above become NA\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    28   113 \n\n\nNgoài ra, thay vì dùng breakers =, bạn có thể sử dụng hàm lower =, upper =, và by =:\n\nlower = Mức giới hạn thấp nhất bạn muốn xem xét - mặc định là 0\n\nupper = Mức giới hạn cao nhất bạn muốn xem xét\n\nby = Khoảng cách “năm” giữa các nhóm\n\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  &lt;NA&gt; \n 2450  1875  1216   597   251    78    27     6     1     0     0   107 \n\n\nXem thêm trang trợ giúp của hàm để biết thêm chi tiết (nhập ?age_categories trong R console).\n\n\n\ncut()\nHàm cut() trong base R là một thay thế cho hàm age_categories(), nhưng tôi nghĩ bạn sẽ thấy lý do tại sao hàm age_categories() được phát triển để đơn giản hóa quá trình này. Một số khác biệt đáng chú ý với hàm age_categories() là:\n\nBạn không cần cài đặt/gọi package khác\n\nBạn có thể chỉ định xem các nhóm được mở/đóng ở bên phải/bên trái\n\nBạn cần phải cung cấp nhãn chính xác\n\nNếu bạn muốn 0 được thêm vào trong nhóm thấp nhất, bạn cần phải cụ thể điều này\n\nCú pháp cơ bản trong cut() trước tiên là cung cấp cột dạng số cần xử lý (age_years), sau đó là đối số break, một vectơ dạng số c() bao gồm các điểm cắt. Sử dụng cut(), kết quả trả về là cột kiểu factor có thứ tự.\nMặc định, việc phân loại xảy ra sao cho phía bên phải/phía trên là “mở” và có tính dung nạp (và phía bên trái/phía dưới là “đóng” hoặc tách biệt). Cách vận hành của hàm này ngược lại với hàm age_categories(). Các nhãn mặc định sử dụng ký hiệu “(A,B]”, có nghĩa là A không được bao gồm nhưng B thì có. Đảo ngược hành động này bằng cách cung cấp đối số right = TRUE.\nDo đó, theo mặc định, các giá trị “0” bị loại trừ khỏi nhóm thấp nhất và được phân loại là NA! Giá trị “0” có thể là trẻ sơ sinh được mã hóa là 0 tuổi, vì vậy hãy thật thận trọng! Để thay đổi điều này, hãy thêm argument include.lowest = TRUE để mọi giá trị “0” sẽ được đưa vào nhóm thấp nhất. Nhãn được tạo tự động cho danh mục thấp nhất sau đó sẽ là “[A],B]”. Lưu ý rằng nếu bạn thêm include.lowest = TRUE và right = TRUE, hành động này bây giờ sẽ áp dụng cho điểm cắt giá trị cao nhất và phân loại, không phải điểm thấp nhất.\nBạn có thể cung cấp một vectơ nhãn tùy chỉnh bằng cách sử dụng argument labels =. Vì chúng được viết theo cách thủ công, hãy rất cẩn thận để đảm bảo chúng chính xác! Kiểm tra bằng cách lập bảng chéo, như được mô tả bên dưới.\nDưới đây là một ví dụ về hàm cut() được áp dụng cho biến age_years để tạo biến age_cat mới:\n\n# Create new variable, by cutting the numeric age variable\n# lower break is excluded but upper break is included in each category\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # include 0 in lowest group\n      ))\n\n# tabulate the number of observations per group\ntable(linelist$age_cat, useNA = \"always\")\n\n\n   [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100] \n    1469     1195     1040      770     1149      778       94        6 \n    &lt;NA&gt; \n     107 \n\n\nKiểm tra đoạn code của bạn!!! Hãy chắc chắn rằng mỗi giá trị độ tuổi đã được chỉ định đúng danh mục bằng cách lập bảng chéo giữa các cột số và danh mục. Kiểm tra việc gán các giá trị ranh giới (ví dụ: 15, nếu các danh mục lân cận là 10-15 và 16-20).\n\n# Cross tabulation of the numeric and category columns. \ntable(\"Numeric Values\" = linelist$age_years,   # names specified in table for clarity.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # don't forget to examine NA values\n\n                    Categories\nNumeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70]\n  0                    136      0       0       0       0       0       0\n  0.0833333333333333     1      0       0       0       0       0       0\n  0.25                   2      0       0       0       0       0       0\n  0.333333333333333      6      0       0       0       0       0       0\n  0.416666666666667      1      0       0       0       0       0       0\n  0.5                    6      0       0       0       0       0       0\n  0.583333333333333      3      0       0       0       0       0       0\n  0.666666666666667      3      0       0       0       0       0       0\n  0.75                   3      0       0       0       0       0       0\n  0.833333333333333      1      0       0       0       0       0       0\n  0.916666666666667      1      0       0       0       0       0       0\n  1                    275      0       0       0       0       0       0\n  1.5                    2      0       0       0       0       0       0\n  2                    308      0       0       0       0       0       0\n  3                    246      0       0       0       0       0       0\n  4                    233      0       0       0       0       0       0\n  5                    242      0       0       0       0       0       0\n  6                      0    241       0       0       0       0       0\n  7                      0    256       0       0       0       0       0\n  8                      0    239       0       0       0       0       0\n  9                      0    245       0       0       0       0       0\n  10                     0    214       0       0       0       0       0\n  11                     0      0     220       0       0       0       0\n  12                     0      0     224       0       0       0       0\n  13                     0      0     191       0       0       0       0\n  14                     0      0     199       0       0       0       0\n  15                     0      0     206       0       0       0       0\n  16                     0      0       0     186       0       0       0\n  17                     0      0       0     164       0       0       0\n  18                     0      0       0     141       0       0       0\n  19                     0      0       0     130       0       0       0\n  20                     0      0       0     149       0       0       0\n  21                     0      0       0       0     158       0       0\n  22                     0      0       0       0     149       0       0\n  23                     0      0       0       0     125       0       0\n  24                     0      0       0       0     144       0       0\n  25                     0      0       0       0     107       0       0\n  26                     0      0       0       0     100       0       0\n  27                     0      0       0       0     117       0       0\n  28                     0      0       0       0      85       0       0\n  29                     0      0       0       0      82       0       0\n  30                     0      0       0       0      82       0       0\n  31                     0      0       0       0       0      68       0\n  32                     0      0       0       0       0      84       0\n  33                     0      0       0       0       0      78       0\n  34                     0      0       0       0       0      58       0\n  35                     0      0       0       0       0      58       0\n  36                     0      0       0       0       0      33       0\n  37                     0      0       0       0       0      46       0\n  38                     0      0       0       0       0      45       0\n  39                     0      0       0       0       0      45       0\n  40                     0      0       0       0       0      32       0\n  41                     0      0       0       0       0      34       0\n  42                     0      0       0       0       0      26       0\n  43                     0      0       0       0       0      31       0\n  44                     0      0       0       0       0      24       0\n  45                     0      0       0       0       0      27       0\n  46                     0      0       0       0       0      25       0\n  47                     0      0       0       0       0      16       0\n  48                     0      0       0       0       0      21       0\n  49                     0      0       0       0       0      15       0\n  50                     0      0       0       0       0      12       0\n  51                     0      0       0       0       0       0      13\n  52                     0      0       0       0       0       0       7\n  53                     0      0       0       0       0       0       4\n  54                     0      0       0       0       0       0       6\n  55                     0      0       0       0       0       0       9\n  56                     0      0       0       0       0       0       7\n  57                     0      0       0       0       0       0       9\n  58                     0      0       0       0       0       0       6\n  59                     0      0       0       0       0       0       5\n  60                     0      0       0       0       0       0       4\n  61                     0      0       0       0       0       0       2\n  62                     0      0       0       0       0       0       1\n  63                     0      0       0       0       0       0       5\n  64                     0      0       0       0       0       0       1\n  65                     0      0       0       0       0       0       5\n  66                     0      0       0       0       0       0       3\n  67                     0      0       0       0       0       0       2\n  68                     0      0       0       0       0       0       1\n  69                     0      0       0       0       0       0       3\n  70                     0      0       0       0       0       0       1\n  72                     0      0       0       0       0       0       0\n  73                     0      0       0       0       0       0       0\n  76                     0      0       0       0       0       0       0\n  84                     0      0       0       0       0       0       0\n  &lt;NA&gt;                   0      0       0       0       0       0       0\n                    Categories\nNumeric Values       (70,100] &lt;NA&gt;\n  0                         0    0\n  0.0833333333333333        0    0\n  0.25                      0    0\n  0.333333333333333         0    0\n  0.416666666666667         0    0\n  0.5                       0    0\n  0.583333333333333         0    0\n  0.666666666666667         0    0\n  0.75                      0    0\n  0.833333333333333         0    0\n  0.916666666666667         0    0\n  1                         0    0\n  1.5                       0    0\n  2                         0    0\n  3                         0    0\n  4                         0    0\n  5                         0    0\n  6                         0    0\n  7                         0    0\n  8                         0    0\n  9                         0    0\n  10                        0    0\n  11                        0    0\n  12                        0    0\n  13                        0    0\n  14                        0    0\n  15                        0    0\n  16                        0    0\n  17                        0    0\n  18                        0    0\n  19                        0    0\n  20                        0    0\n  21                        0    0\n  22                        0    0\n  23                        0    0\n  24                        0    0\n  25                        0    0\n  26                        0    0\n  27                        0    0\n  28                        0    0\n  29                        0    0\n  30                        0    0\n  31                        0    0\n  32                        0    0\n  33                        0    0\n  34                        0    0\n  35                        0    0\n  36                        0    0\n  37                        0    0\n  38                        0    0\n  39                        0    0\n  40                        0    0\n  41                        0    0\n  42                        0    0\n  43                        0    0\n  44                        0    0\n  45                        0    0\n  46                        0    0\n  47                        0    0\n  48                        0    0\n  49                        0    0\n  50                        0    0\n  51                        0    0\n  52                        0    0\n  53                        0    0\n  54                        0    0\n  55                        0    0\n  56                        0    0\n  57                        0    0\n  58                        0    0\n  59                        0    0\n  60                        0    0\n  61                        0    0\n  62                        0    0\n  63                        0    0\n  64                        0    0\n  65                        0    0\n  66                        0    0\n  67                        0    0\n  68                        0    0\n  69                        0    0\n  70                        0    0\n  72                        1    0\n  73                        3    0\n  76                        1    0\n  84                        1    0\n  &lt;NA&gt;                      0  107\n\n\nGán nhãn giá trị NA\nBạn có thể muốn gán nhãn cho các giá trị NA chẳng hạn như “Missing”. Bởi vì cột mới có kiểu Factor (số giá trị bị hạn chế), bạn không thể chỉ đơn giản thay đổi nó bằng replace_na(), vì giá trị này sẽ không được chấp nhận. Thay vào đó, hãy sử dụng hàm fct_explicit_na() từ package forcats như được giải thích trong chương Factors.\n\nlinelist &lt;- linelist %&gt;% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(\n    age_years,\n    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n    right = FALSE,\n    include.lowest = TRUE,        \n    labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n    # make missing values explicit\n    age_cat = fct_explicit_na(\n      age_cat,\n      na_level = \"Missing age\")  # you can specify the label\n  )    \n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `age_cat = fct_explicit_na(age_cat, na_level = \"Missing age\")`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\n\n# table to view counts\ntable(linelist$age_cat, useNA = \"always\")\n\n\n        0-4         5-9       10-14       15-19       20-29       30-49 \n       1227        1223        1048         827        1216         848 \n      50-69      70-100 Missing age        &lt;NA&gt; \n        105           7         107           0 \n\n\nTạo nhanh điểm cắt và dán nhãn\nĐể nhanh chóng tạo điểm cắt và gắn nhãn vectơ, hãy thực hành như bên dưới. Xem chương R cơ bản về hàm seq() và rep().\n\n# Make break points from 0 to 90 by 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Make labels for the above categories, assuming default cut() settings\nage_labels = paste0(age_seq + 1, \"-\", age_seq + 5)\nage_labels\n\n# check that both vectors are the same length\nlength(age_seq) == length(age_labels)\n\nĐọc thêm về hàm cut() trong trang Trợ giúp của hàm bằng cách nhập ?cut trong R console.\n\n\nChia khoảng phân vị\nTheo cách hiểu thông thường, “phân vị” hoặc “phần trăm” thường đề cập đến một giá trị dưới ngưỡng tỷ lệ đang được đề cập. Ví dụ: phân vị thứ thứ 95 của biến độ tuổi trong linelist sẽ là các độ tuổi dưới 95% độ tuổi.\nTuy nhiên, trong cách nói thông thường, “tứ phân vị” và “thập phân vị” cũng có thể đề cập đến phân nhóm dữ liệu được chia đều thành 4 hoặc 10 nhóm (lưu ý sẽ có thêm một điểm cắt so với số nhóm).\nĐể nhận biết điểm cắt của khoảng phân vị, bạn có thể sử dụng hàm quantile() từ package stats trong base R. Bạn cung cấp một vectơ số (ví dụ: một cột trong bộ dữ liệu) và vectơ các giá trị xác suất số từ 0 đến 1. Các điểm cắt được trả về dưới dạng một vectơ số. Đọc thêm chi tiết các phương pháp thống kê bằng cách nhập ?quantile.\n\nNếu vectơ số đầu vào của bạn có bất kỳ giá trị nào bị thiếu, tốt nhất nên thiết lập na.rm = TRUE\n\nThiết lậpnames = FALSE để lấy một vectơ số chưa được đặt tên\n\n\nquantile(linelist$age_years,               # specify numeric vector to work on\n  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want\n  na.rm = TRUE)                            # ignore missing values \n\n 0% 25% 50% 75% 90% 95% \n  0   6  13  23  33  41 \n\n\nBạn có thể sử dụng kết quả của quantile() làm điểm cắt trong age_categories() hoặc cut(). Dưới đây, chúng ta tạo một cột deciles mới bằng cách sử dụng hàm cut() trong đó các dấu ngắt được xác định bằng cách sử dụng hàm quantiles() trên cột age_years. Sau đó, chúng ta hiển thị kết quả bằng hàm tabyl() từ package janitor để bạn có thể xem tỷ lệ phần trăm (xem chương Bảng mô tả). Lưu ý rằng chúng không chính xác là 10% trong mỗi nhóm.\n\nlinelist %&gt;%                                # begin with linelist\n  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years\n    breaks = quantile(                      # define cut breaks using quantile()\n      age_years,                               # operate on age_years\n      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1\n      na.rm = TRUE),                           # ignore missing values\n    include.lowest = TRUE)) %&gt;%             # for cut() include age 0\n  janitor::tabyl(deciles)                   # pipe to table to display\n\n deciles   n    percent valid_percent\n   [0,2] 748 0.11319613    0.11505922\n   (2,5] 721 0.10911017    0.11090601\n   (5,7] 497 0.07521186    0.07644978\n  (7,10] 698 0.10562954    0.10736810\n (10,13] 635 0.09609564    0.09767728\n (13,17] 755 0.11425545    0.11613598\n (17,21] 578 0.08746973    0.08890940\n (21,26] 625 0.09458232    0.09613906\n (26,33] 596 0.09019370    0.09167820\n (33,84] 648 0.09806295    0.09967697\n    &lt;NA&gt; 107 0.01619249            NA\n\n\n\n\nNhóm có khoảng đều\nMột công cụ khác để tạo nhóm dạng số là hàm ntile() trong package dplyr, cố gắng chia dữ liệu của bạn thành n nhóm có khoảng cách đều - nhưng lưu ý rằng không giống như với quantile(), cùng một giá trị có thể xuất hiện trong nhiều nhóm. Cung cấp vectơ số và sau đó là số lượng nhóm. Các giá trị trong cột mới được tạo chỉ là nhóm “số” (ví dụ: 1 đến 10), không phải phạm vi giá trị như khi sử dụng hàm cut().\n\n# make groups with ntile()\nntile_data &lt;- linelist %&gt;% \n  mutate(even_groups = ntile(age_years, 10))\n\n# make table of counts and proportions by group\nntile_table &lt;- ntile_data %&gt;% \n  janitor::tabyl(even_groups)\n  \n# attach min/max values to demonstrate ranges\nntile_ranges &lt;- ntile_data %&gt;% \n  group_by(even_groups) %&gt;% \n  summarise(\n    min = min(age_years, na.rm=T),\n    max = max(age_years, na.rm=T)\n  )\n\nWarning: There were 2 warnings in `summarise()`.\nThe first warning was:\nℹ In argument: `min = min(age_years, na.rm = T)`.\nℹ In group 11: `even_groups = NA`.\nCaused by warning in `min()`:\n! no non-missing arguments to min; returning Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n# combine and print - note that values are present in multiple groups\nleft_join(ntile_table, ntile_ranges, by = \"even_groups\")\n\n even_groups   n    percent valid_percent min  max\n           1 651 0.09851695    0.10013844   0    2\n           2 650 0.09836562    0.09998462   2    5\n           3 650 0.09836562    0.09998462   5    7\n           4 650 0.09836562    0.09998462   7   10\n           5 650 0.09836562    0.09998462  10   13\n           6 650 0.09836562    0.09998462  13   17\n           7 650 0.09836562    0.09998462  17   21\n           8 650 0.09836562    0.09998462  21   26\n           9 650 0.09836562    0.09998462  26   33\n          10 650 0.09836562    0.09998462  33   84\n          NA 107 0.01619249            NA Inf -Inf\n\n\n\n\n\ncase_when()\nCó thể sử dụng hàm case_when() từ dplyr để tạo biến danh mục từ cột số, tuy nhiên điều này được thực hiện dễ dàng hơn với hàm age_categories() từ epikit hoặc cut() vì chúng sẽ tự động tạo ra một biến factor có thứ tự.\nNếu sử dụng case_when(), vui lòng xem lại cách sử dụng thích hợp như đã mô tả trước đó trong mục Mã hóa lại giá trị. Cũng lưu ý rằng tất cả các giá trị bên tay phải phải thuộc cùng một kiểu. Do đó, nếu bạn muốn giá trị NA ở phía bên phải, bạn nên viết “Missing” hoặc sử dụng giá trị NA đặc biệt là NA_character_.\n\n\nThêm vào chuỗi làm sạch\nDưới đây, code để tạo hai cột phân loại tuổi được thêm vào chuỗi các bước làm sạch:\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # de-duplicate\n    distinct() %&gt;% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %&gt;%\n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################   \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#thêm-hàng",
    "href": "new_pages/cleaning.vn.html#thêm-hàng",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.10 Thêm hàng",
    "text": "7.10 Thêm hàng\n\nThêm từng hàng một\nViệc thêm từng hàng một theo cách thủ công là rất nhàm chán nhưng có thể được thực hiện với hàm add_row() từ package dplyr. Hãy nhớ rằng mỗi cột chỉ được chứa các giá trị của một phân lớp (ký tự, số, lôgic, v.v.). Vì vậy, khi thêm một hàng cần chú ý tới điều này.\n\nlinelist &lt;- linelist %&gt;% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)\n\nSử dụng .before và .after. để cụ thể vị trí của hàng bạn muốn thêm. .before = 3 sẽ cho phép hàng mới được thêm trước hàng thứ 3 hiện tại. Mặc định thì hàng sẽ được thêm vào dòng cuối cùng. Các cột không được chỉ định sẽ được để trống (NA).\nSố thứ tự hàng mới có thể trông lạ (“… 23”) nhưng số thứ tự hàng trong các hàng tồn tại trước đó đã thay đổi. Vì vậy, nếu sử dụng lệnh hai lần, hãy kiểm tra/thử việc chèn một cách cẩn thận.\nNếu một phân lớp bạn cung cấp không hoạt động, bạn sẽ thấy báo lỗi như sau:\nError: Can't combine ..1$infection date &lt;date&gt; and ..2$infection date &lt;character&gt;.\n(khi chèn một hàng có giá trị ngày tháng, hãy nhớ đặt thông tin as.Date() ví dụ như as.Date(\"2020-10-10\")).\n\n\nNối các hàng\nĐể kết hợp các bộ dữ liệu với nhau bằng cách liên kết các hàng của một bộ dữ liệu này với phần cuối bộ dữ liệu khác, bạn có thể sử dụng hàm bind_rows() từ dplyr. Điều này được giải thích chi tiết hơn trong chương Nối dữ liệu.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#lọc-hàng",
    "href": "new_pages/cleaning.vn.html#lọc-hàng",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.11 Lọc hàng",
    "text": "7.11 Lọc hàng\nBước làm sạch điển hình sau khi bạn đã làm sạch các cột và các giá trị được mã hóa lại đó là lọc bộ dữ liệu cho các hàng cụ thể bằng cách sử dụng hàm filter() trong package dplyr.\nTrong hàm filter(), hãy cụ thể điều kiện logic phải là giá trị TRUE cho một hàng được giữ trong bộ dữ liệu. Dưới đây chúng tôi trình bày cách lọc hàng dựa trên điều kiện logic đơn giản và phức tạp.\n\n\nLọc đơn giản\nVí dụ đơn giản này định nghĩa lại bộ dữ liệu linelist, đã lọc các hàng để đáp ứng điều kiện logic. Chỉ những hàng mà câu lệnh logic trong dấu ngoặc đơn đánh giá là TRUE mới được giữ lại.\nTrong ví dụ này, câu lệnh logic là gender == \"f\", được hỏi liệu giá trị trong cột gender có bằng “f” (phân biệt chữ hoa chữ thường) hay không.\nTrước khi bộ lọc được áp dụng, số hàng trong linelist là nrow(linelist).\n\nlinelist &lt;- linelist %&gt;% \n  filter(gender == \"f\")   # keep only rows where gender is equal to \"f\"\n\nSau khi bộ lọc được áp dụng, số hàng trong linelist là linelist %&gt;% filter(gender == \"f\") %&gt;% nrow().\n\n\nLọc bỏ các giá trị missing\nMột điều khá phổ biến là bạn muốn lọc bỏ các hàng có giá trị missing. Hãy bỏ qua cách lọc cổ điển filter(!is.na(column) & !is.na(column)) và thay vào đó, hãy sử dụng hàm drop_na() trong package tidyr được xây dựng để tùy chỉnh cho mục đích này. Nếu chạy với dấu ngoặc trống, nó sẽ loại bỏ các hàng có bất kỳ giá trị nào bị missing. Ngoài ra, bạn có thể cung cấp tên của các cột cụ thể sẽ được đánh giá về mức độ missing hoặc sử dụng các hàm trợ giúp “tidyselect” như được mô tả ở trên.\n\nlinelist %&gt;% \n  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years\n\nXem chương về Dữ liệu Missing để biết nhiều kỹ thuật phân tích và quản lý dữ liệu missing.\n\n\nLọc bằng số thứ tự của hàng\nTrong một data frame hoặc tibble, mỗi hàng thường sẽ có một “số thứ tự” (khi xem trong R Viewer) xuất hiện ở bên trái của cột đầu tiên. Bản thân nó không phải là một cột trong dữ liệu, nhưng nó có thể được sử dụng trong câu lệnh filter().\nĐể lọc dựa trên “số thứ tự của hàng”, bạn có thể sử dụng hàm dplyr row_number() với “dấu ngoặc đơn mở” như một phần của câu lệnh lọc logic. Thường thì bạn sẽ sử dụng toán tử %in% và một dãy số như một phần của câu lệnh logic đó, như được trình bày bên dưới. Để xem N hàng đầu tiên, bạn cũng có thể sử dụng hàm đặc biệt head() trong package dplyr.\n\n# View first 100 rows\nlinelist %&gt;% head(100)     # or use tail() to see the n last rows\n\n# Show row 5 only\nlinelist %&gt;% filter(row_number() == 5)\n\n# View rows 2 through 20, and three specific columns\nlinelist %&gt;% filter(row_number() %in% 2:20) %&gt;% select(date_onset, outcome, age)\n\nBạn cũng có thể chuyển đổi số thứ tự hàng thành cột bằng cách sử dụng hàm tibble rownames_to_column() (không viết bất kỳ ký tự nào trong dấu ngoặc đơn).\n\n\n\nLọc phức tạp\nCác câu lệnh logic phức tạp hơn có thể được xây dựng bằng cách sử dụng các toán tử ngoặc đơn ( ), HOẶC |, PHỦ ĐỊNH !, %in%, và VÀ &. Dưới đây là một ví dụ:\nLưu ý: Bạn có thể sử dụng ! trước một mệnh đề logic để phủ định nó. Ví dụ, !is.na(column) trả về giá trị TRUE nếu cột đó không bị thiếu giá trị. Tương tự như vậy !column %in% c(\"a\", \"b\", \"c\") trả về kết quả là TRUE nếu giá trị cột không có trong vectơ.\n\nKiểm tra dữ liệu\nDưới đây là một dòng lệnh đơn giản để tạo biểu đồ các ngày bắt đầu. Chúng ta thấy rằng có một đợt bùng phát nhỏ thứ hai từ năm 2012-2013 cũng được bao gồm trong tập bộ dữ liệu gốc này. Trong các phân tích, chúng ta muốn xóa các bản ghi từ đợt bùng phát sớm.\n\nhist(linelist$date_onset, breaks = 50)\n\n\n\n\n\n\n\n\n\n\nCách lọc và xử lý các giá trị số và ngày bị missing\nChúng ta có thể chỉ lọc theo date_onset đến những hàng sau tháng 6 năm 2013 không? Lưu ý! Việc áp dụng code filter(date_onset &gt; as.Date(\"2013-06-01\"))) sẽ xóa bất kỳ hàng nào trong đợt dịch sau đó có ngày bắt đầu bị thiếu!\nNGUY HIỂM: Việc lọc với điều kiện lớn hơn (&gt;) hoặc nhỏ hơn (&lt;) một ngày hoặc số có thể loại bỏ bất kỳ hàng nào có giá trị bị thiếu (NA)! Điều này là do NA được coi là giá trị lớn hoặc nhỏ vô hạn.\n(Xem chương Làm việc với ngày tháng để biết thêm thông tin về cách xử lý với ngày tháng và package lubridate)\n\n\nThiết kế bộ lọc\nLập một bảng chéo để đảm bảo rằng chúng ta chỉ loại bỏ các hàng cần loại bỏ:\n\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values\n\n                                      YearOnset\nHospital                               2012 2013 2014 2015 &lt;NA&gt;\n  Central Hospital                        0    0  351   99   18\n  Hospital A                            229   46    0    0   15\n  Hospital B                            227   47    0    0   15\n  Military Hospital                       0    0  676  200   34\n  Missing                                 0    0 1117  318   77\n  Other                                   0    0  684  177   46\n  Port Hospital                           9    1 1372  347   75\n  St. Mark's Maternity Hospital (SMMH)    0    0  322   93   13\n  &lt;NA&gt;                                    0    0    0    0    0\n\n\nLiệu chúng ta có thể lọc theo tiêu chí nào khác để loại bỏ đợt bùng phát đầu tiên (trong năm 2012 & 2013) khỏi bộ dữ liệu? Chúng ta thấy rằng:\n\nVụ dịch đầu tiên năm 2012 & 2013 xảy ra tại Hospital A, Hospital B, tại Port Hospital cũng có 10 trường hợp mắc.\n\nHospital A & B không có ca bệnh nào trong đợt dịch thứ hai, nhưng Port Hospital thì có.\n\nChúng ta muốn loại bỏ:\n\nCác dòng nrow(linelist %&gt;% filter(hospital %in% c(\"Hospital A\", \"Hospital B\") | date_onset &lt; as.Date(\"2013-06-01\"))) bắt đầu vào năm 2012 và 2013 tại Hospital A, B hoặc Port Hospital:\n\nLoại trừ các hàng nrow(linelist %&gt;% filter(date_onset &lt; as.Date(\"2013-06-01\"))) bắt đầu vào năm 2012 và 2013\nLoại trừ các hàng nrow(linelist %&gt;% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))) từ Hospital A và B với các giá trị ngày bị thiếu\n\nKhông loại bỏ các dòng khác nrow(linelist %&gt;% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))) bị thiếu ngày bắt đầu.\n\n\nChúng ta bắt đầu với linelist bằng câu lệnh nrow(linelist). Đây là toàn bộ câu lệnh lọc của chúng ta:\n\nlinelist &lt;- linelist %&gt;% \n  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B\n  filter(date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)\n\n[1] 6019\n\n\nKhi chúng ta lập lại bảng chéo, chúng ta thấy rằng Hospital A & B bị loại bỏ hoàn toàn, và 10 trường hợp của Port Hospital từ năm 2012 & 2013 bị loại bỏ và tất cả các giá trị khác đều tương tự - đúng như ý chúng ta muốn.\n\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values\n\n                                      YearOnset\nHospital                               2014 2015 &lt;NA&gt;\n  Central Hospital                      351   99   18\n  Military Hospital                     676  200   34\n  Missing                              1117  318   77\n  Other                                 684  177   46\n  Port Hospital                        1372  347   75\n  St. Mark's Maternity Hospital (SMMH)  322   93   13\n  &lt;NA&gt;                                    0    0    0\n\n\nNhiều biểu thức có thể được bao hàm trong một lệnh lọc (được phân tách bằng dấu phẩy) hoặc bạn luôn có thể viết chúng riêng biệt và nối tiếp nhau trong chuỗi các bước làm sạch để rõ ràng hơn.\nGhi chú: một số độc giả có thể nhận thấy rằng sẽ dễ dàng hơn nếu chỉ lọc theo date_hospitalisation vì nó hoàn chỉnh 100% mà không có giá trị nào bị thiếu. Đây là sự thật. Nhưng date_onset được sử dụng cho mục đích thể hiện sự phức tạp của việc lọc.\n\n\n\nĐộc lập\nViệc lọc cũng có thể được thực hiện như một lệnh độc lập (không phải là một phần của chuỗi các bước làm sạch). Giống như các hàm dplyr khác, trong trường hợp này, đối số đầu tiên phải chính là bộ dữ liệu.\n\n# dataframe &lt;- filter(dataframe, condition(s) for rows to keep)\n\nlinelist &lt;- filter(linelist, !is.na(case_id))\n\nBạn cũng có thể sử dụng base R để chia nhỏ dữ liệu bằng cách sử dụng dấu ngoặc đểm tham chiếu tới [hàng, cột] mà bạn muốn giữ lại.\n\n# dataframe &lt;- dataframe[row conditions, column conditions] (blank means keep all)\n\nlinelist &lt;- linelist[!is.na(case_id), ]\n\n\n\nXem nhanh các bản ghi\nThường thì bạn muốn xem nhanh một vài bản ghi, chỉ cho một vài cột. Hàm View() trong base R sẽ hiển thị một khung dữ liệu để xem trong RStudio.\nXem linelist trong RStudio:\n\nView(linelist)\n\nDưới đây là hai ví dụ về việc xem các ô cụ thể (hàng cụ thể và cột cụ thể):\nVới hàm filter() và select() trong dplyr:\nVới hàm View(), chuyển tiếp bộ dữ liệu đến hàm filter() để giữ các hàng nhất định và sau đó select() để giữ các cột nhất định. Ví dụ, để xem xét ngày khởi phát và nhập viện của 3 trường hợp cụ thể:\n\nView(linelist %&gt;%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %&gt;%\n       select(date_onset, date_hospitalisation))\n\nBạn có thể đạt được điều tương tự với cú pháp trong base R, sử dụng dấu ngoặc [ ] cho tập hợp con bạn muốn xem.\n\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])\n\n\nThêm vào chuỗi làm sạch\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # de-duplicate\n    distinct() %&gt;% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %&gt;%\n  \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %&gt;% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#tính-toán-theo-hàng",
    "href": "new_pages/cleaning.vn.html#tính-toán-theo-hàng",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.12 Tính toán theo hàng",
    "text": "7.12 Tính toán theo hàng\nNếu bạn muốn thực hiện một phép tính trong một hàng, bạn có thể sử dụng hàm rowwise() từ dplyr. Xem chi tiết tại row-wise calculations.\nVí dụ: code này sử dụng hàm rowwise() và sau đó tạo một cột mới là tổng số cột triệu chứng được chứa giá trị “có”, cho mỗi hàng trong linelist. Các cột được cụ thể trong hàm sum() theo tên trong vectơ c(). Hàm rowwise() về cơ bản là một hình thức group_by() đặc biệt, vì vậy tốt nhất bạn nên sử dụng ungroup() khi bạn hoàn tất (trong chương Nhóm dữ liệu).\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %&gt;% \n  ungroup() %&gt;% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # for display\n\n# A tibble: 5,888 × 6\n   fever chills cough aches vomit num_symptoms\n   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;        &lt;int&gt;\n 1 no    no     yes   no    yes              2\n 2 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 3 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 4 no    no     no    no    no               0\n 5 no    no     yes   no    yes              2\n 6 no    no     yes   no    yes              2\n 7 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 8 no    no     yes   no    yes              2\n 9 no    no     yes   no    yes              2\n10 no    no     yes   no    no               1\n# ℹ 5,878 more rows\n\n\nKhi bạn chỉ định cột để đánh giá, bạn có thể muốn sử dụng các hàm trợ giúp “tidyselect” như được mô tả trong mục select() của chương này. Bạn chỉ cần thực hiện một điều chỉnh (vì bạn đang không sử dụng chúng bên trong một hàm của dplyr như select() hoặc summarise()).\nĐặt tiêu chí đặc tả cột trong hàm dplyr là c_across(). Điều này là do hàm c_across (tài liệu) được thiết kế để hoạt động cụ thể với hàm rowwise(). Ví dụ, như đoạn code sau:\n\nÁp dụng rowwise() nên bước tiếp theo (sum()) được áp dụng trong mỗi hàng (không tính tổng toàn bộ các cột)\n\nTạo cột mới num_NA_dates, được xác định cho mỗi hàng là số cột (có tên chứa “ngày tháng”) mà is.na() trả về giá trị TRUE (nghĩa là chúng bị thiếu dữ liệu)\n\nungroup() để loại bỏ ảnh hưởng của rowwise() cho các bước tiếp theo\n\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %&gt;% \n  ungroup() %&gt;% \n  select(num_NA_dates, contains(\"date\")) # for display\n\n# A tibble: 5,888 × 5\n   num_NA_dates date_infection date_onset date_hospitalisation date_outcome\n          &lt;int&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1            1 2014-05-08     2014-05-13 2014-05-15           NA          \n 2            1 NA             2014-05-13 2014-05-14           2014-05-18  \n 3            1 NA             2014-05-16 2014-05-18           2014-05-30  \n 4            1 2014-05-04     2014-05-18 2014-05-20           NA          \n 5            0 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6            0 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7            0 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8            0 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9            1 NA             2014-06-05 2014-06-06           2014-06-18  \n10            1 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n\n\nBạn cũng có thể cung cấp các hàm khác, chẳng hạn như max() để lấy ngày mới nhất hoặc gần đây nhất cho mỗi hàng:\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %&gt;% \n  ungroup() %&gt;% \n  select(latest_date, contains(\"date\"))  # for display\n\n# A tibble: 5,888 × 5\n   latest_date date_infection date_onset date_hospitalisation date_outcome\n   &lt;date&gt;      &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \n 2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \n 3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \n 4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \n 5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \n10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#sắp-xếp",
    "href": "new_pages/cleaning.vn.html#sắp-xếp",
    "title": "7  Làm sạch số liệu và các hàm quan trọng",
    "section": "7.13 Sắp xếp",
    "text": "7.13 Sắp xếp\nSử dụng hàm dplyr arrange() để sắp xếp thứ tự các hàng theo giá trị cột.\nĐơn giản hãy liệt kê các cột theo thứ tự mà chúng cần được sắp xếp. Thêm .by_group = TRUE nếu bạn muốn việc sắp xếp xảy ra trước bất kỳ hành động nhóm dữ liệu nào được áp dụng trong dữ liệu (xem chương Nhóm dữ liệu).\nMặc định, cột sẽ được sắp xếp theo thứ tự “tăng dần” (áp dụng cho cột số và cả cột ký tự). Bạn có thể sắp xếp một biến theo thứ tự “giảm dần” bằng cách đặt tên biến trong hàm desc().\nViệc sắp xếp dữ liệu với hàm arrange() đặc biệt hữu ích khi Trình bày bảng, sử dụng hàm slice() để lấy các hàng “trên cùng” trên mỗi nhóm hoặc thiết lập thứ tự danh mục theo thứ tự xuất hiện.\nVí dụ: để sắp xếp các hàng trong linelist theo hospital, sau đó theo date_onset thứ tự giảm dần, chúng ta sẽ thực hiện như sau:\n\nlinelist %&gt;% \n   arrange(hospital, desc(date_onset))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html",
    "href": "new_pages/iteration.vn.html",
    "title": "8  Lặp, vòng lặp, và danh sách",
    "section": "",
    "text": "8.1 Chuẩn bị",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#chuẩn-bị",
    "href": "new_pages/iteration.vn.html#chuẩn-bị",
    "title": "8  Lặp, vòng lặp, và danh sách",
    "section": "",
    "text": "Gọi packages\nĐoạn code này hiển thị cách gọi các packages cần thiết cho phần phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt package nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về packages R.\n\npacman::p_load(\n     rio,         # import/export\n     here,        # file locator\n     purrr,       # iteration\n     grates,      # scales in ggplot\n     tidyverse    # data management and visualization\n)\n\n\n\nNhập dữ liệu\nChúng tôi nhập dataset về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn làm theo, hãy nhấp để tải xuống linelist “sạch” (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - Xem chương Nhập xuất dữ liệu để biết chi tiết).\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của linelist được hiển thị bên dưới.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#vòng-lặp-for",
    "href": "new_pages/iteration.vn.html#vòng-lặp-for",
    "title": "8  Lặp, vòng lặp, và danh sách",
    "section": "8.2 vòng lặp for",
    "text": "8.2 vòng lặp for\n\nvòng lặp for trong R\nVòng lặp for không được nhấn mạnh trong R, nhưng phổ biến trong các ngôn ngữ lập trình khác. Khi mới bắt đầu, chúng có thể hữu ích để học và thực hành vì chúng dễ “khám phá”, “gỡ lỗi” hơn và nắm bắt chính xác những gì đang xảy ra cho mỗi lần lặp, đặc biệt là khi bạn chưa cảm thấy thoải mái khi viết các hàm của riêng mình.\nBạn có thể chuyển nhanh qua phần vòng lặp for tới phần lặp với các hàm được tạo với purrr (xem phần bên dưới).\n\n\nCấu phần cốt lõi\nMột vòng lặp for có ba phần cốt lõi:\n\nChuỗi các phần tử cần lặp lại\nCác thao tác để tiến hành cho mỗi phần tử trong chuỗi\n\nVùng chứa cho kết quả (tùy chọn)\n\nCú pháp cơ bản là: for (phần tử trong chuỗi) {các thao tác thực hiện với phần tử}. Lưu ý dấu ngoặc đơn và dấu ngoặc nhọn. Kết quả có thể được in ra console hoặc được lưu trữ trong một đối tượng vùng chứa.\nDưới đây là một ví dụ đơn giản về vòng lặp for.\n\nfor (num in c(1,2,3,4,5)) {  # the SEQUENCE is defined (numbers 1 to 5) and loop is opened with \"{\"\n  print(num + 2)             # The OPERATIONS (add two to each sequence number and print)\n}                            # The loop is closed with \"}\"                            \n\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n\n                             # There is no \"container\" in this example\n\n\n\nChuỗi\nĐây là phần “for” của vòng lặp for - các thao tác sẽ chạy “cho (for)” từng phần tử trong chuỗi. Chuỗi có thể là một loạt các giá trị (ví dụ: tên của khu vực pháp lý, bệnh, tên cột, phần tử danh sách, v.v.) hoặc nó có thể là một chuỗi các số liên tiếp (ví dụ: 1,2,3,4,5). Mỗi cách tiếp cận được mô tả dưới đây có các tiện ích riêng của chúng.\nCấu trúc cơ bản của biểu thức chuỗi là item in vector.\n\nBạn có thể viết bất kỳ ký tự hoặc từ nào thay cho “item” (ví dụ: “i”, “num”, “hosp”, “district”, v.v.). Giá trị của “item” này thay đổi theo từng lần lặp lại của vòng lặp, tiếp tục qua từng giá trị trong vector.\n\nVector có thể là các giá trị ký tự, tên cột hoặc có thể là một chuỗi số - đây là những giá trị sẽ thay đổi theo mỗi lần lặp. Bạn có thể sử dụng chúng trong các thao tác vòng lặp for bằng cách sử dụng thuật ngữ “item”.\n\nVí dụ: chuỗi giá trị ký tự\nTrong ví dụ này, một vòng lặp được thực hiện cho mỗi giá trị được xác định trước trong một vector ký tự của tên bệnh viện.\n\n# make vector of the hospital names\nhospital_names &lt;- unique(linelist$hospital)\nhospital_names # print\n\n[1] \"Other\"                               \n[2] \"Missing\"                             \n[3] \"St. Mark's Maternity Hospital (SMMH)\"\n[4] \"Port Hospital\"                       \n[5] \"Military Hospital\"                   \n[6] \"Central Hospital\"                    \n\n\nChúng tôi đã chọn thuật ngữ hosp để đại diện cho các giá trị từ vector hospital_names. Đối với lần lặp đầu tiên của vòng lặp, giá trị của hosp sẽ là hospital_names[[1]]. Đối với vòng lặp thứ hai, nó sẽ là hospital_names[[2]]. Và cứ như thế…\n\n# a 'for loop' with character sequence\n\nfor (hosp in hospital_names){       # sequence\n  \n       # OPERATIONS HERE\n  }\n\nVí dụ: chuỗi tên cột\nĐây là một biến thể của chuỗi ký tự ở trên, trong đó tên của một đối tượng R hiện có được trích xuất và trở thành vector. Ví dụ, tên cột của dataframe. Trong code hoạt động của vòng lặp for, tên cột có thể được sử dụng để lập chỉ mục (tập hợp con) dataframe ban đầu của chúng.\nDưới đây, chuỗi là names() (tên cột) của dataframe linelist. Tên “item” của chúng ta là col, sẽ đại diện cho từng tên cột khi các vòng lặp diễn ra.\nVới ví dụ này, chúng tôi bao gồm code thao tác bên trong vòng lặp for, được chạy cho mọi giá trị trong chuỗi. Trong code này, các giá trị trình tự (tên cột) được sử dụng để chỉ mục (tập hợp con) từng phần tử một trong linelist. Như đã dạy trong chương R cơ bản, dấu ngoặc vuông kép [[]] được sử dụng cho tập hợp con. Cột kết quả được chuyển đến is.na(), sau đó đến sum() để tạo ra số giá trị trong cột bị thiếu. Kết quả được in ra console - một số cho mỗi cột.\nMột lưu ý về lập chỉ mục với tên cột - bất cứ khi nào tham chiếu đến chính cột đó, đừng chỉ viết “col”! col chỉ đại diện cho tên cột ký tự! Để tham chiếu đến toàn bộ cột, bạn phải sử dụng tên cột dưới dạng chỉ mục trên linelist thông qua linelist[[col]].\n\nfor (col in names(linelist)){        # loop runs for each column in linelist; column name represented by \"col\" \n  \n  # Example operations code - print number of missing values in column\n  print(sum(is.na(linelist[[col]])))  # linelist is indexed by current value of \"col\"\n     \n}\n\n[1] 0\n[1] 0\n[1] 2087\n[1] 256\n[1] 0\n[1] 936\n[1] 1323\n[1] 278\n[1] 86\n[1] 0\n[1] 86\n[1] 86\n[1] 86\n[1] 0\n[1] 0\n[1] 0\n[1] 2088\n[1] 2088\n[1] 0\n[1] 0\n[1] 0\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 149\n[1] 765\n[1] 0\n[1] 256\n\n\nDãy số\nTheo cách tiếp cận này, dãy số là một chuỗi các số liên tiếp. Do đó, giá trị của “item” không phải là giá trị ký tự (ví dụ: “Central Hospital” hoặc “date_onset”) mà là một số. Điều này rất hữu ích cho việc lặp qua các dataframes, vì bạn có thể sử dụng số “item” bên trong vòng lặp for để lập chỉ mục dataframe theo số hàng.\nVí dụ: giả sử bạn muốn lặp qua mọi hàng trong dataframe của mình và trích xuất thông tin nhất định. “Item” của bạn sẽ là số hàng số. Thông thường, “item” trong trường hợp này được viết là i.\nQuá trình vòng lặp for có thể được giải thích bằng lời là “đối với mọi mục trong chuỗi số từ 1 đến tổng số hàng trong dataframe của tôi, hãy thực hiện X”. Đối với lần lặp đầu tiên của vòng lặp, giá trị của “item” i sẽ là 1. Đối với lần lặp thứ hai,i sẽ là 2, v.v.\nĐây là hình thức của chuỗi trong code: for (i in 1:nrow(linelist)) {OPERATIONS CODE} trong đó i đại diện cho “item”và 1:nrow(linelist) tạo ra một chuỗi liên tiếp số từ 1 đến số hàng trong linelist.\n\nfor (i in 1:nrow(linelist)) {  # use on a data frame\n  # OPERATIONS HERE\n}  \n\nNếu bạn muốn chuỗi là số, nhưng bạn đang bắt đầu từ một vector (không phải dataframe), hãy sử dụng hàm tắt seq_along() để trả về một dãy số cho mỗi phần tử trong vector. Ví dụ: for (i in seq_along(hospital_names) {OPERATIONS CODE}.\nĐoạn code dưới đây thực sự trả về các số, sẽ trở thành giá trị của i trong vòng lặp tương ứng của chúng.\n\nseq_along(hospital_names)  # use on a named vector\n\n[1] 1 2 3 4 5 6\n\n\nMột lợi thế của việc sử dụng các số trong chuỗi là cũng dễ dàng sử dụng số i để lập chỉ mục vùng chứa lưu trữ các kết quả đầu ra của vòng lặp. Có một ví dụ về điều này trong phần Thao tác bên dưới.\n\n\nCác thao tác\nĐây là code trong dấu ngoặc nhọn {} của vòng lặp for. Bạn muốn code này chạy cho từng “item” trong chuỗi. Do đó, hãy thận trọng với mọi phần code của bạn thay đổi bởi “item” đều được mã hóa chính xác để nó thực sự thay đổi! Ví dụ. nhớ sử dụng [[ ]] để lập chỉ mục.\nTrong ví dụ dưới đây, chúng tôi lặp lại từng hàng trong linelist. Giá trị gender và age của mỗi hàng được dán lại với nhau và được lưu trữ trong vector ký tự vùng chứa cases_demographics. Lưu ý cách chúng tôi cũng sử dụng lập chỉ mục [[i]] để lưu đầu ra của vòng lặp vào vị trí chính xác trong vector “container”.\n\n# create container to store results - a character vector\ncases_demographics &lt;- vector(mode = \"character\", length = nrow(linelist))\n\n# the for loop\nfor (i in 1:nrow(linelist)){\n  \n  # OPERATIONS\n  # extract values from linelist for row i, using brackets for indexing\n  row_gender  &lt;- linelist$gender[[i]]\n  row_age     &lt;- linelist$age_years[[i]]    # don't forget to index!\n     \n  # combine gender-age and store in container vector at indexed location\n  cases_demographics[[i]] &lt;- str_c(row_gender, row_age, sep = \",\") \n\n}  # end for loop\n\n\n# display first 10 rows of container\nhead(cases_demographics, 10)\n\n [1] \"m,2\"  \"f,3\"  \"m,56\" \"f,18\" \"m,3\"  \"f,16\" \"f,16\" \"f,0\"  \"m,61\" \"f,27\"\n\n\n\n\nVùng chứa\nĐôi khi kết quả của vòng lặp for của bạn sẽ được in ra console hoặc cửa sổ RStudio Plots. Lần khác, bạn sẽ muốn lưu trữ các kết quả đầu ra trong một “vùng chứa” để sử dụng sau này. Một vùng chứa như vậy có thể là một vector, một data frame hoặc thậm chí là một danh sách.\nHiệu quả nhất là tạo vùng chứa cho các kết quả thậm chí trước khi bắt đầu vòng lặp for. Trong thực tế, điều này có nghĩa là tạo một vector, data frame hoặc danh sách trống. Chúng có thể được tạo bằng các hàm vector() cho vectors hoặc danh sách, hoặc với matrix() và data.frame() cho một data frame.\nVector trống\nSử dụng vector() và chỉ định mode = dựa trên lớp phân loại dự kiến của các đối tượng mà bạn sẽ chèn - “double” (để giữ số), “ký tự” hoặc “logic”. Bạn cũng nên đặt trước length =. Đây phải là độ dài chuỗi vòng lặp for của bạn.\nGiả sử bạn muốn lưu trữ thời gian nhập viện trễ trung bình cho mỗi bệnh viện. Bạn sẽ sử dụng “double” và đặt độ dài là số đầu ra dự kiến (số bệnh viện duy nhất trong data set).\n\ndelays &lt;- vector(\n  mode = \"double\",                            # we expect to store numbers\n  length = length(unique(linelist$hospital))) # the number of unique hospitals in the dataset\n\nData frame trống\nBạn có thể tạo một data frame trống bằng cách chỉ định số hàng và cột như sau:\n\ndelays &lt;- data.frame(matrix(ncol = 2, nrow = 3))\n\nDanh sách trống\nBạn có thể muốn lưu trữ một số biểu đồ được tạo bởi vòng lặp for trong danh sách. Một danh sách giống như vector, nhưng chứa các đối tượng R khác bên trong nó có thể thuộc các lớp khác nhau. Các phần tử trong danh sách có thể là một số, một dataframe, một vector và thậm chí là một danh sách khác.\nBạn thực sự khởi tạo một danh sách trống bằng cách sử dụng cùng một lệnh vector() như trên, nhưng với mode = \"list\". Chỉ định độ dài như bạn muốn.\n\nplots &lt;- vector(mode = \"list\", length = 16)\n\n\n\nIn\nLưu ý rằng để in từ bên trong vòng lặp for, bạn có thể sẽ cần phải đưa hàm print() vào.\nTrong ví dụ dưới đây, chuỗi là một vector ký tự rõ ràng, được sử dụng để đặt linelist con theo bệnh viện. Kết quả không được lưu trữ trong vùng chứa mà được in ra console với hàm print().\n\nfor (hosp in hospital_names){ \n     hospital_cases &lt;- linelist %&gt;% filter(hospital == hosp)\n     print(nrow(hospital_cases))\n}\n\n[1] 885\n[1] 1469\n[1] 422\n[1] 1762\n[1] 896\n[1] 454\n\n\n\n\nKiểm tra vòng lặp for\nĐể kiểm tra vòng lặp của mình, bạn có thể chạy lệnh để gán tạm thời “item”, chẳng hạn như i &lt;- 10 hoặc hosp &lt;- \"Central Hospital\". Thực hiện việc này bên ngoài vòng lặp và sau đó chỉ chạy code thao tác của bạn (code trong dấu ngoặc nhọn) để xem liệu kết quả mong đợi có được tạo ra hay không.\n\n\nLặp lại biểu đồ\nĐể đặt tất cả ba thành phần lại với nhau (vùng chứa, trình tự và thao tác), chúng ta hãy cố gắng vẽ biểu đồ đường cong dịch bệnh cho mỗi bệnh viện (xem chương Đường cong dịch bệnh).\nChúng tôi có thể tạo ra một đường cong dịch bệnh đẹp về tất cả các trường hợp theo giới tính bằng cách sử dụng package incidence2 như bên dưới:\n\n# create 'incidence' object\noutbreak &lt;- incidence2::incidence(   \n     x = linelist,                   # dataframe - complete linelist\n     date_index = \"date_onset\",      # date column\n     interval = \"week\",              # aggregate counts weekly\n     groups = \"gender\")              # group values by gender\n     #na_as_group = TRUE)            # missing gender is own group\n\n# plot epi curve\nggplot(outbreak,                     # incidence object name\n        aes(x = date_index,          # aesthetics and axes\n            y = count, \n            fill = gender),          # Fill colour of bars by gender\n       color = \"black\"               # Contour colour of bars\n       ) +  \n     geom_col() + \n     facet_wrap(~gender) +\n     theme_bw() + \n     labs(title = \"Outbreak of all cases\", #title\n          x = \"Counts\", \n          y = \"Date\", \n          fill = \"Gender\", \n          color = \"Gender\")\n\n\n\n\n\n\n\n\nĐể tạo ra một biểu đồ riêng cho từng trường hợp của bệnh viện, chúng ta có thể đặt code đường cong dịch bệnh này trong vòng lặp for.\nĐầu tiên, chúng tôi lưu một vector được đặt tên duy nhất của các tên bệnh viện, hospital_names. Vòng lặp for sẽ chạy một lần cho mỗi tên sau: for (hosp in hospital_names). Mỗi lần lặp lại của vòng lặp for, tên bệnh viện hiện tại từ vector sẽ được biểu diễn dưới dạng hosp để sử dụng trong vòng lặp.\nTrong các thao tác vòng lặp, bạn có thể viết code R như bình thường, nhưng cần biết rằng giá trị của “item” (hosp trong trường hợp này) sẽ thay đổi. Trong vòng lặp này:\n\nMột filter() được áp dụng cho linelist, sao cho cột hospital phải bằng giá trị hiện tại của hosp\n\nĐối tượng tỷ lệ mắc được tạo trên linelist đã lọc\n\nBiểu đồ cho bệnh viện hiện tại được tạo, với tiêu đề tự động điều chỉnh sử dụng hosp\n\nBiểu đồ cho bệnh viện hiện tại được lưu tạm thời và sau đó được in\n\nSau đó, vòng lặp di chuyển tiếp để lặp lại với bệnh viện tiếp theo trong hospital_names\n\n\n# make vector of the hospital names\nhospital_names &lt;- unique(linelist$hospital)\n\n# for each name (\"hosp\") in hospital_names, create and print the epi curve\nfor (hosp in hospital_names) {\n     \n     # create incidence object specific to the current hospital\n     outbreak_hosp &lt;- incidence2::incidence(\n          x = linelist %&gt;% filter(hospital == hosp),   # linelist is filtered to the current hospital\n          date_index = \"date_onset\",\n          interval = \"week\", \n          groups = \"gender\"\n          #na_as_group = TRUE\n     )\n     \n     # Create and save the plot. Title automatically adjusts to the current hospital\n      plot_hosp &lt;- ggplot(outbreak_hosp, # incidence object name\n                         aes(x = date_index, #axes\n                             y = count, \n                             fill = gender), # fill colour by gender\n                         color = \"black\"      # colour of bar contour\n                         ) +  \n          geom_col() + \n          facet_wrap(~gender) +\n          theme_bw() + \n          labs(title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\"), #title\n               x = \"Counts\", \n               y = \"Date\", \n               fill = \"Gender\", \n               color = \"Gender\")\n     \n     # With older versions of R, remove the # before na_as_group and use this plot command instead.\n    # plot_hosp &lt;- plot(\n#       outbreak_hosp,\n#       fill = \"gender\",\n#       color = \"black\",\n#       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n#     )\n     \n     # print the plot for hospitals\n     print(plot_hosp)\n     \n} # end the for loop when it has been run for every hospital in hospital_names \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTheo dõi tiến trình của một vòng lặp\nMột vòng lặp có nhiều lần lặp có thể chạy trong nhiều phút hoặc thậm chí hàng giờ. Do đó, có thể hữu ích khi in tiến trình ra R console. Câu lệnh if dưới đây có thể được đặt trong các thao tác vòng lặp để in mỗi số thứ 100. Chỉ cần điều chỉnh nó để i là “item” trong vòng lặp của bạn.\n\n# loop with code to print progress every 100 iterations\nfor (i in seq_len(nrow(linelist))){\n\n  # print progress\n  if(i %% 100==0){    # The %% operator is the remainder\n    print(i)\n\n}",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#iter_purrr",
    "href": "new_pages/iteration.vn.html#iter_purrr",
    "title": "8  Lặp, vòng lặp, và danh sách",
    "section": "8.3 purrr và các danh sách",
    "text": "8.3 purrr và các danh sách\nMột cách tiếp cận khác đối với các thao tác lặp là package purrr - nó là phương pháp tidyverse để lặp lại.\nNếu bạn phải thực hiện cùng một tác vụ nhiều lần, có lẽ bạn nên tạo một giải pháp tổng thể có thể sử dụng trên nhiều đầu vào. Ví dụ: tạo các biểu đồ cho nhiều khu vực pháp lý, hoặc nhập và kết hợp nhiều tệp.\nNgoài ra còn có một số lợi thế khác đối với purrr - bạn có thể sử dụng nó với các pipes %&gt;%, nó xử lý lỗi tốt hơn vòng lặp for bình thường, và có cú pháp khá rõ ràng và đơn giản! Nếu bạn đang sử dụng vòng lặp for, bạn có thể tạo vòng lặp rõ ràng và ngắn gọn hơn với purrr!\nHãy nhớ rằng purrr là một công cụ lập trình theo hàm. Có nghĩa là, các thao tác lặp đi lặp lại được gói gọn trong các hàm. Xem chương Viết hàm để tìm hiểu cách viết hàm của riêng bạn.\npurrr cũng gần như hoàn toàn dựa trên danh sách và vectors - vì vậy hãy nghĩ về nó như là áp dụng một hàm cho mỗi phần tử của danh sách/vector đó!\n\nTải packages\npurrr là một phần của tidyverse, vì vậy không cần cài đặt/tải một package riêng biệt.\n\npacman::p_load(\n     rio,            # import/export\n     here,           # relative filepaths\n     tidyverse,      # data mgmt and viz\n     writexl,        # write Excel file with multiple sheets\n     readxl          # import Excel with multiple sheets\n)\n\n\n\nmap()\nMột hàm cốt lõi của purrr là map(), hàm này “maps” (áp dụng) một hàm cho từng phần tử đầu vào của danh sách/vector bạn cung cấp.\nCú pháp cơ bản là map(.x = SEQUENCE, .f = HÀM, CÁC ĐỐI SỐ KHÁC). Chi tiết hơn như sau:\n\n.x = là các đầu vào mà hàm .f sẽ được áp dụng lặp đi lặp lại - ví dụ: vector của tên các khu vực pháp lý, các cột trong data frame hoặc danh sách các data frame\n\n.f = là hàm áp dụng cho từng phần tử của đầu vào .x - nó có thể là một hàm như print() đã tồn tại hoặc một hàm tùy chỉnh mà bạn xác định. Hàm thường được viết sau dấu ngã ~ (chi tiết bên dưới).\n\nThêm một số lưu ý về cú pháp:\n\nNếu hàm không cần chỉ định thêm đối số, nó có thể được viết không có dấu ngoặc đơn và không có dấu ngã (ví dụ: .f = mean). Để cung cấp các đối số sẽ có cùng giá trị cho mỗi lần lặp, hãy cung cấp chúng trong map() nhưng bên ngoài đối số .f =, chẳng hạn như na.rm = T trong map(.x = my_list, .f = mean, na.rm=T).\n\nBạn có thể sử dụng .x (hoặc đơn giản là .) bên trong hàm .f = làm trình giữ chỗ cho giá trị .x của lần lặp đó\n\nSử dụng cú pháp dấu ngã (~) để kiểm soát hàm nhiều hơn - viết hàm như bình thường với dấu ngoặc đơn, chẳng hạn như: map(.x = my_list, .f = ~mean(., na.rm = T)). Sử dụng cú pháp này đặc biệt nếu giá trị của một đối số sẽ thay đổi mỗi lần lặp lại hoặc nếu nó là chính giá trị .x (xem ví dụ bên dưới)\n\n** Đầu ra của việc sử dụng map() là một danh sách** - một danh sách là một lớp đối tượng giống như một vector nhưng các phần tử của nó có thể thuộc các lớp khác nhau. Vì vậy, một danh sách được tạo bởi map() có thể chứa nhiều data frames, hoặc nhiều vector, nhiều giá trị đơn lẻ, hoặc thậm chí nhiều danh sách! Có các phiên bản thay thế của map() được giải thích bên dưới, tạo ra các loại kết quả khác (ví dụ: map_dfr() để tạo data frame, map_chr() để tạo vectors ký tự và map_dbl() để tạo vectors số).\n\nVí dụ - nhập và kết hợp các trang tính Excel\nHãy biểu diễn với một công việc thường gặp của nhà dịch tễ học: - Bạn muốn nhập một Excel workbook với dữ liệu trường hợp bệnh, nhưng dữ liệu được chia thành các trang tính có tên khác nhau trong workbook. Làm cách nào để bạn nhập và kết hợp các trang tính vào một data frame một cách hiệu quả?\nGiả sử chúng tôi được gửi Excel workbook bên dưới. Mỗi trang tính chứa các trường hợp từ một bệnh viện nhất định.\n\n\n\n\n\n\n\n\n\nĐây là một cách tiếp cận sử dụng map():\n\nmap() hàm import() để nó chạy qua mỗi trang tính Excel\n\nKết hợp các data frames đã nhập thành một bằng cách sử dụng bind_rows()\n\nTrong khi đó, hãy giữ nguyên tên trang tính ban đầu cho mỗi hàng, lưu trữ thông tin này trong một cột mới trong data frame cuối cùng\n\nĐầu tiên, chúng ta cần trích xuất tên trang tính và lưu chúng. Chúng tôi cung cấp đường dẫn tệp của Excel workbook tới hàm excel_sheets() từ package readxl, sẽ trích xuất tên trang tính. Chúng tôi lưu trữ chúng trong một vector ký tự được gọi là sheet_names.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\nĐây là các tên trang tính:\n\nsheet_names\n\n[1] \"Central Hospital\"              \"Military Hospital\"            \n[3] \"Missing\"                       \"Other\"                        \n[5] \"Port Hospital\"                 \"St. Mark's Maternity Hospital\"\n\n\nBây giờ chúng ta có tên của vector này, map() có thể cung cấp từng cái một cho hàm import(). Trong ví dụ này, sheet_names là .x và import() là hàm .f.\nNhớ lại từ chương Nhập và xuất dữ liệu, khi sử dụng trên Excel workbooks, import() có thể chấp nhận đối số which = để chỉ định trang tính để nhập. Trong hàm import() của .f, chúng tôi cung cấp which = .x, giá trị của nó sẽ thay đổi theo mỗi lần lặp thông qua vector sheet_names - đầu tiên là “Central Hospital”, sau đó là “Military Hospital”, v.v.\nLưu ý - bởi vì chúng tôi đã sử dụng map(), dữ liệu trong mỗi trang tính Excel sẽ được lưu thành một data frame riêng biệt trong danh sách. Chúng tôi muốn mỗi phần tử danh sách này (data frames) có một tên, vì vậy trước khi chuyển sheet_names đến map(), chúng tôi chuyển nó qua set_names() từ purrr, điều này đảm bảo rằng mỗi phần tử danh sách nhận được tên thích hợp.\nChúng tôi lưu danh sách đầu ra dưới dạng combined.\n\ncombined &lt;- sheet_names %&gt;% \n  purrr::set_names() %&gt;% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\n\nKhi kiểm tra đầu ra, chúng ta thấy rằng dữ liệu từ mỗi trang tính Excel được lưu trong danh sách với một tên. Điều này là tốt, nhưng chúng ta chưa kết thúc ở đây.\n\n\n\n\n\n\n\n\n\nCuối cùng, chúng tôi sử dụng hàm bind_rows() (từ dplyr) chấp nhận danh sách các data frames có cấu trúc tương tự và kết hợp chúng thành một data frame. Để tạo một cột mới từ phần tử danh sách tên, chúng tôi sử dụng đối số .id = và cung cấp cho nó tên mong muốn cho cột mới.\nDưới đây là toàn bộ chuỗi lệnh:\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")  # extract sheet names\n \ncombined &lt;- sheet_names %&gt;%                                     # begin with sheet names\n  purrr::set_names() %&gt;%                                        # set their names\n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %&gt;%  # iterate, import, save in list\n  bind_rows(.id = \"origin_sheet\") # combine list of data frames, preserving origin in new column  \n\nVà bây giờ chúng ta có một data frame với một cột chứa trang tính ban đầu!\n\n\n\n\n\n\n\n\n\nCó những biến thể của map() mà bạn nên biết. Ví dụ: map_dfr() trả về data frame, không phải danh sách. Vì vậy, chúng ta có thể đã sử dụng nó cho tác vụ ở trên và không cần phải ràng buộc các hàng. Nhưng sau đó chúng ta sẽ không thể nắm bắt được trường hợp nào đến từ trang tính nào (bệnh viện).\nCác biến thể khác bao gồm map_chr(), map_dbl(). Đây là những hàm rất hữu ích vì hai lý do. Trước hết, chúng tự động chuyển đổi đầu ra của một hàm lặp thành một vector (không phải danh sách). Thứ hai, chúng có thể kiểm soát rõ ràng lớp mà dữ liệu quay trở lại - bạn đảm bảo rằng dữ liệu của bạn quay trở lại dưới dạng vector ký tự với map_chr(), hoặc vector số với map_dbl(). Hãy quay lại những hàm này sau trong phần sau!\nCác hàm map_at() và map_if() cũng rất hữu ích để lặp lại - chúng cho phép bạn chỉ định phần tử nào của danh sách nên lặp lại! Chúng hoạt động đơn giản bằng cách áp dụng một vector gồm các chỉ mục/tên (với map_at()) hoặc một phép kiểm tra logic (với map_if()).\nVí dụ, chúng tôi không muốn đọc trang tính đầu tiên chứa dữ liệu của bệnh viện. Chúng tôi sử dụng map_at() thay vì map() và chỉ định đối số .at = thành c(-1) có nghĩa là không sử dụng phần tử đầu tiên của .x. Ngoài ra, bạn có thể cung cấp một vector gồm các số dương hoặc tên cho .at = để chỉ định phần tử nào sẽ sử dụng.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined &lt;- sheet_names %&gt;% \n     purrr::set_names() %&gt;% \n     # exclude the first sheet\n     map_at(.f = ~import( \"hospital_linelists.xlsx\", which = .x),\n            .at = c(-1))\n\nLưu ý rằng tên trang tính đầu tiên sẽ vẫn xuất hiện như một phần tử của danh sách đầu ra - nhưng nó chỉ là một tên ký tự đơn lẻ (không phải là một data frame). Bạn sẽ cần phải loại bỏ phần tử này trước khi liên kết các hàng. Chúng tôi sẽ trình bày cách xóa và sửa đổi các phần tử danh sách trong phần sau.\n\n\n\nTách và xuất bộ dữ liệu\nDưới đây, chúng tôi đưa ra một ví dụ về cách tách bộ dữ liệu thành các phần và sau đó sử dụng phép lặp map() để xuất từng phần dưới dạng trang tính Excel riêng biệt hoặc dưới dạng tệp CSV riêng biệt.\n\nTách bộ dữ liệu\nGiả sử chúng ta có toàn bộ trường hợp linelist làm data frame và bây giờ chúng ta muốn tạo một linelist riêng biệt cho từng bệnh viện và xuất từng trường hợp dưới dạng tệp CSV riêng biệt. Dưới đây, chúng tôi thực hiện các bước sau:\nSử dụng group_split() (từ dplyr) để tách data frame linelist theo các giá trị duy nhất trong cột hospital. Đầu ra là một danh sách chứa một data frame cho mỗi tập hợp con của bệnh viện.\n\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital)\n\nChúng ta có thể chạy View(linelist_split) và thấy rằng danh sách này chứa 6 data frames (“tibbles”), mỗi khung đại diện cho các trường hợp từ một bệnh viện.\n\n\n\n\n\n\n\n\n\nTuy nhiên, lưu ý rằng các data frames trong danh sách không có tên theo mặc định! Chúng tôi muốn mỗi người có một tên và sau đó sử dụng tên đó khi lưu tệp CSV.\nMột cách tiếp cận để trích xuất các tên là sử dụng pull() (từ dplyr) để trích xuất cột hospital từ mỗi data frame trong danh sách. Sau đó, để an toàn, chúng tôi chuyển đổi các giá trị thành ký tự và sau đó sử dụng unique() để lấy tên cho data frame cụ thể đó. Tất cả các bước này được áp dụng cho từng data frame thông qua map().\n\nnames(linelist_split) &lt;- linelist_split %&gt;%   # Assign to names of listed data frames \n     # Extract the names by doing the following to each data frame: \n     map(.f = ~pull(.x, hospital)) %&gt;%        # Pull out hospital column\n     map(.f = ~as.character(.x)) %&gt;%          # Convert to character, just in case\n     map(.f = ~unique(.x))                    # Take the unique hospital name\n\nBây giờ chúng ta có thể thấy rằng mỗi phần tử trong danh sách đều có một tên. Những tên này có thể được truy cập thông qua names(linelist_split).\n\n\n\n\n\n\n\n\n\n\nnames(linelist_split)\n\n[1] \"Central Hospital\"                    \n[2] \"Military Hospital\"                   \n[3] \"Missing\"                             \n[4] \"Other\"                               \n[5] \"Port Hospital\"                       \n[6] \"St. Mark's Maternity Hospital (SMMH)\"\n\n\n\nNhiều hơn một cột group_split()\nNếu bạn muốn chia linelist theo nhiều hơn một nhóm cột, chẳng hạn như để tạo tập hợp con linelist theo giao điểm của bệnh viện VÀ giới tính, bạn sẽ cần một cách tiếp cận khác để đặt tên cho các phần tử danh sách. Điều này liên quan đến việc thu thập các “nhóm chính (group keys)” duy nhất bằng cách sử dụng group_keys() từ dplyr - chúng được trả về dưới dạng một data frame. Sau đó, bạn có thể kết hợp các nhóm chính thành các giá trị với unite() như được hiển thị bên dưới và gán các tên tập nhóm này cho linelist_split.\n\n# split linelist by unique hospital-gender combinations\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital, gender)\n\n# extract group_keys() as a dataframe\ngroupings &lt;- linelist %&gt;% \n     group_by(hospital, gender) %&gt;%       \n     group_keys()\n\ngroupings      # show unique groupings \n\n# A tibble: 18 × 2\n   hospital                             gender\n   &lt;chr&gt;                                &lt;chr&gt; \n 1 Central Hospital                     f     \n 2 Central Hospital                     m     \n 3 Central Hospital                     &lt;NA&gt;  \n 4 Military Hospital                    f     \n 5 Military Hospital                    m     \n 6 Military Hospital                    &lt;NA&gt;  \n 7 Missing                              f     \n 8 Missing                              m     \n 9 Missing                              &lt;NA&gt;  \n10 Other                                f     \n11 Other                                m     \n12 Other                                &lt;NA&gt;  \n13 Port Hospital                        f     \n14 Port Hospital                        m     \n15 Port Hospital                        &lt;NA&gt;  \n16 St. Mark's Maternity Hospital (SMMH) f     \n17 St. Mark's Maternity Hospital (SMMH) m     \n18 St. Mark's Maternity Hospital (SMMH) &lt;NA&gt;  \n\n\nBây giờ chúng ta kết hợp các nhóm với nhau, được phân tách bằng dấu gạch ngang và gán chúng làm tên của các phần tử danh sách trong linelist_split. Thao tác này sẽ mất thêm vài dòng khi chúng ta thay thế NA bằng “Missing”, sử dụng unite() từ dplyr để kết hợp các giá trị cột với nhau (phân tách bằng dấu gạch ngang), sau đó chuyển đổi thành vector không tên để nó có thể được dùng làm tên của linelist_split.\n\n# Combine into one name value \nnames(linelist_split) &lt;- groupings %&gt;% \n     mutate(across(everything(), replace_na, \"Missing\")) %&gt;%  # replace NA with \"Missing\" in all columns\n     unite(\"combined\", sep = \"-\") %&gt;%                         # Unite all column values into one\n     setNames(NULL) %&gt;% \n     as_vector() %&gt;% \n     as.list()\n\n\n\n\nXuất dưới dạng trang tính Excel\nĐể xuất linelists bệnh viện dưới dạng Excel workbook với một linelist trên mỗi trang tính, chúng tôi chỉ có thể cung cấp danh sách có tên linelist_split cho hàm write_xlsx() từ package writexl. Điều này có khả năng lưu một Excel workbook với nhiều trang tính. Tên phần tử danh sách được tự động áp dụng làm tên trang tính.\n\nlinelist_split %&gt;% \n     writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))\n\nBây giờ bạn có thể mở tệp Excel và thấy rằng mỗi bệnh viện có một trang tính riêng.\n\n\n\n\n\n\n\n\n\n\n\nXuất dưới dạng tệp CSV\nĐây là lệnh phức tạp hơn một chút, nhưng bạn cũng có thể xuất từng linelist dành riêng cho bệnh viện dưới dạng tệp CSV riêng biệt, với tên tệp dành riêng cho bệnh viện.\nMột lần nữa, chúng tôi sử dụng map(): chúng tôi lấy vector của tên phần tử danh sách (được hiển thị ở trên) và sử dụng map() để lặp lại chúng, áp dụng export() (từ package rio, xem chương Nhập và xuất dữ liệu) trên data frame với danh sách linelist_split có tên đó. Chúng tôi cũng sử dụng tên để tạo một tên tệp duy nhất. Đây là các bước thực hiện:\n\nChúng ta bắt đầu với vector tên kí tự, được chuyển tới map() dưới dạng .x\n\nHàm .f là export(), hàm này yêu cầu một data frame và một đường dẫn tệp để ghi vào\n\nĐầu vào .x (tên bệnh viện) được sử dụng trong .f để trích xuất/lập chỉ mục phần tử cụ thể đó của danh sách linelist_split. Điều này làm cho mỗi lần chỉ một data frame được cung cấp cho export().\n\nVí dụ: khi map() lặp lại cho “Military Hospital”, thì linelist_split[[.x]] sẽ là linelist_split[[\"Military Hospital\"]], do đó trả về phần tử thứ hai của linelist_split - đó là tất cả các trường hợp từ Military Hospital.\n\nĐường dẫn tệp được cung cấp cho export() là động thông qua việc sử dụng str_glue() (xem chương Ký tự và chuỗi):\n\nhere() được sử dụng để lấy cơ sở của đường dẫn tệp và chỉ định thư mục “data” (lưu ý dấu nháy đơn để không làm gián đoạn dấu ngoặc kép str_glue())\n\n\nSau đó là dấu gạch chéo /, rồi lại .x in tên bệnh viện hiện tại để làm cho tệp có thể nhận dạng được\n\nCuối cùng là phần mở rộng “.csv” mà export() sử dụng để tạo tệp CSV\n\n\nnames(linelist_split) %&gt;%\n     map(.f = ~export(linelist_split[[.x]], file = str_glue(\"{here('data')}/{.x}.csv\")))\n\nBây giờ bạn có thể thấy rằng mỗi tệp được lưu trong thư mục “data” của Dự án R “Epi_R_handbook”!\n\n\n\n\n\n\n\n\n\n\n\n\nHàm tùy chỉnh\nBạn có thể muốn tạo một hàm của riêng mình để đưa vào map().\nGiả sử chúng ta muốn tạo đường cong dịch bệnh cho từng trường hợp của bệnh viện. Để thực hiện việc này với purrr, hàm .f của chúng ta có thể là ggplot() và các phần mở rộng bằng + như bình thường. Vì đầu ra của map() luôn là một danh sách nên các biểu đồ được lưu trữ trong một danh sách. Bởi vì chúng là các biểu đồ, chúng có thể được trích xuất và vẽ bằng hàm ggarrange() từ package ggpubr (documentation).\n\n# load package for plotting elements from list\npacman::p_load(ggpubr)\n\n# map across the vector of 6 hospital \"names\" (created earlier)\n# use the ggplot function specified\n# output is a list with 6 ggplots\n\nhospital_names &lt;- unique(linelist$hospital)\n\nmy_plots &lt;- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %&gt;% filter(hospital == .x)) +\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# print the ggplots (they are stored in a list)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\n\n\n\n\n\nNếu code map() này trông quá lộn xộn, bạn có thể đạt được kết quả tương tự bằng cách lưu lệnh ggplot() cụ thể của mình dưới dạng một hàm tùy chỉnh do người dùng xác định, ví dụ, chúng ta có thể đặt tên nó là make_epicurve(). Hàm này sau đó được sử dụng trong map(). .x sẽ được thay thế lặp lại bằng tên bệnh viện và được sử dụng làm hosp_name trong hàm make_epicurve(). Xem chương về Viết hàm.\n\n# Create function\nmake_epicurve &lt;- function(hosp_name){\n  \n  ggplot(data = linelist %&gt;% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n\n\n# mapping\nmy_plots &lt;- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# print the ggplots (they are stored in a list)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\nÁp dụng một hàm qua nhiều cột\nMột trường hợp sử dụng phổ biến khác là áp dụng một hàm trên nhiều cột. Dưới đây, chúng tôi map() hàm t.test() qua các cột số trong data frame linelist, so sánh các giá trị số theo giới tính.\nNhớ lại từ chương về Các kiểm định thống kê cơ bản rằng t.test() có thể nhận đầu vào ở định dạng công thức, chẳng hạn như t.test(numeric column ~ binary column). Trong ví dụ này, chúng tôi làm như sau:\n\nCác cột số được chọn từ linelist - những cột này trở thành đầu vào .x cho map()\n\nHàm t.test() được cung cấp dưới dạng hàm .f, được áp dụng cho mỗi cột số\n\nTrong dấu ngoặc đơn của t.test():\n\ndấu ~ đầu tiên đứng trước .f mà map() sẽ lặp qua.x\n\n.x đại diện cho cột hiện tại được cung cấp cho hàm t.test()\n\ndấu ~ thứ hai là một phần của phương trình t-test được mô tả ở trên\n\nhàm t.test() yêu cầu một cột nhị phân ở phía bên phải của phương trình. Chúng tôi đưa vector linelist$gender một cách độc lập và có ý nghĩa thống kê (lưu ý rằng nó không được bao gồm trong select()).\n\n\nmap() trả về một danh sách, vì vậy đầu ra là một danh sách các kết quả t-test - một danh sách phần tử cho mỗi cột số được phân tích.\n\n# Results are saved as a list\nt.test_results &lt;- linelist %&gt;% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %&gt;%  # keep only some numeric columns to map across\n  map(.f = ~t.test(.x ~ linelist$gender))        # t.test function, with equation NUMERIC ~ CATEGORICAL\n\nĐây là danh sách t.test_results trông như thế nào khi được mở (Cửa sổ Viewer) trong RStudio. Chúng tôi đã đánh dấu các phần quan trọng đối với các ví dụ trong trang này.\n\nỞ trên cùng, bạn có thể thấy toàn bộ danh sách được đặt tên là t.test_results và có năm phần tử. Năm phần tử đó được đặt tên là age, wt_km, ht_cm, ct_blood, temp theo mỗi biến được sử dụng trong t-test với gender từ linelist.\n\nMỗi phần tử trong số năm phần tử đó đều là danh sách, với các phần tử bên trong chúng, chẳng hạn như p.value và conf.int. Một số phần tử như p.value là các số đơn lẻ, trong khi một số phần tử như estimate bao gồm hai hoặc nhiều phần tử (mean in group f và mean in group m).\n\n\n\n\n\n\n\n\n\n\nLưu ý: Hãy nhớ rằng nếu bạn chỉ muốn áp dụng một hàm cho một số cột nhất định trong data frame, bạn cũng có thể chỉ cần sử dụng mutate() và across(), như được giải thích trong chương Làm sạch số liệu và các hàm quan trọng. Dưới đây là một ví dụ về việc áp dụng as.character() cho chỉ các cột “age”. Lưu ý vị trí của dấu ngoặc đơn và dấu phẩy.\n\n# convert columns with column name containing \"age\" to class Character\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  \n\n\n\nTrích xuất từ danh sách\nKhi map() tạo ra một đầu ra của lớp danh sách, chúng ta sẽ dành một chút thời gian thảo luận về cách trích xuất dữ liệu từ danh sách bằng cách sử dụng các hàm purrr đi kèm. Để minh họa điều này, chúng tôi sẽ sử dụng danh sách t.test_results từ phần trước. Đây là danh sách gồm 5 danh sách - mỗi danh sách trong số 5 danh sách chứa kết quả của t-test giữa một cột từ data frame linelist và cột nhị phân gender của nó. Xem hình ảnh trong phần trên để có hình ảnh về cấu trúc danh sách.\n\nTên của các phần tử\nĐể trích xuất tên của chính các phần tử, chỉ cần sử dụng names() từ base R. Trong trường hợp này, chúng tôi sử dụng names() trên t.test_results để trả về tên của mỗi danh sách con, là tên của 5 biến đã thực hiện t-tests.\n\nnames(t.test_results)\n\n[1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\"    \n\n\n\n\nCác phần tử theo tên hoặc vị trí\nĐể trích xuất các phần tử danh sách theo tên hoặc theo vị trí, bạn có thể sử dụng dấu ngoặc [[ ]] như được mô tả trong chương R cơ bản. Dưới đây chúng tôi sử dụng dấu ngoặc kép để lập chỉ mục danh sách t.tests_results và hiển thị phần tử đầu tiên là kết quả của t-test trên age.\n\nt.test_results[[1]] # first element by position\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\nt.test_results[[1]][\"p.value\"] # return element named \"p.value\" from first element  \n\n$p.value\n[1] 2.350374e-96\n\n\nTuy nhiên, dưới đây chúng tôi sẽ trình bày việc sử dụng các hàm map() và pluck() của purrr đơn giản và linh hoạt để đạt được kết quả tương tự.\n\n\npluck()\npluck() kéo ra các phần tử theo tên hoặc theo vị trí. Ví dụ - để trích xuất kết quả t-test cho độ tuổi, bạn có thể sử dụng pluck() như thế này:\n\nt.test_results %&gt;% \n  pluck(\"age\")        # alternatively, use pluck(1)\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\n\nLập chỉ mục các cấp độ sâu hơn bằng cách chỉ định các cấp độ cao hơn bằng dấu phẩy. Dưới đây trích xuất phần tử có tên “p.value” từ danh sách age trong danh sách t.test_results. Bạn cũng có thể sử dụng số thay vì tên ký tự.\n\nt.test_results %&gt;% \n  pluck(\"age\", \"p.value\")\n\n[1] 2.350374e-96\n\n\nBạn có thể trích xuất các phần tử bên trong như vậy từ tất cả các phần tử cấp một bằng cách sử dụng map() để chạy hàm pluck() trên từng phần tử cấp một. Ví dụ, đoạn mã dưới đây trích xuất các phần tử “p.value” từ tất cả các danh sách trong t.test_results. Danh sách các kết quả t-test là .x được lặp qua,pluck() là hàm .f đang được lặp và giá trị “p-value” được cung cấp cho hàm.\n\nt.test_results %&gt;%\n  map(pluck, \"p.value\")   # return every p-value\n\n$age\n[1] 2.350374e-96\n\n$wt_kg\n[1] 2.664367e-182\n\n$ht_cm\n[1] 3.515713e-144\n\n$ct_blood\n[1] 0.4473498\n\n$temp\n[1] 0.5735923\n\n\nMột cách thay thế khác là map() viết tắt tên phần tử trong dấu ngoặc kép và nó sẽ ngắt nó ra. Nếu bạn sử dụng map(), đầu ra sẽ là một danh sách, trong khi nếu bạn sử dụng map_chr() thì nó sẽ là một vectơ ký tự được đặt tên và nếu bạn sử dụng map_dbl() nó sẽ là một vector số được đặt tên.\n\nt.test_results %&gt;% \n  map_dbl(\"p.value\")   # return p-values as a named numeric vector\n\n          age         wt_kg         ht_cm      ct_blood          temp \n 2.350374e-96 2.664367e-182 3.515713e-144  4.473498e-01  5.735923e-01 \n\n\nBạn có thể đọc thêm về pluck() trong tài liệu về purrr. Nó có một hàm tương tự là chuck() sẽ trả về lỗi thay vì NULL nếu một phần tử không tồn tại.\n\n\n\nChuyển đổi danh sách thành data frame\nĐây là một nội dung phức tạp - hãy xem phần Tài nguyên học liệu để có các hướng dẫn đầy đủ hơn. Tuy nhiên, chúng tôi sẽ minh họa việc chuyển đổi danh sách các kết quả t-test thành một data frame. Chúng tôi sẽ tạo một data frame với các cột cho biến, p-value của nó và giá trị trung bình từ hai nhóm (nam và nữ).\nDưới đây là một số phương pháp và hàm mới sẽ được sử dụng:\n\nHàm tibble() sẽ được sử dụng để tạo một tibble (giống như một data frame)\n\nChúng tôi bao quanh hàm tibble() bằng dấu ngoặc nhọn { } để ngăn toàn bộ t.test_results được lưu trữ dưới dạng cột nhỏ đầu tiên\n\n\nTrong tibble(), mỗi cột được tạo một cách rõ ràng, tương tự như cú pháp của mutate():\n\nDấu . đại diện cho t.test_results\n\nĐể tạo một cột với các tên biến t-test (tên của mỗi phần tử danh sách), chúng tôi sử dụng names() như đã mô tả ở trên\n\nĐể tạo một cột với các p-values, chúng tôi sử dụng map_dbl() như được mô tả ở trên để kéo các phần tử p.value và chuyển đổi chúng thành một vector số\n\n\n\nt.test_results %&gt;% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }\n\n# A tibble: 5 × 2\n  variables         p\n  &lt;chr&gt;         &lt;dbl&gt;\n1 age       2.35e- 96\n2 wt_kg     2.66e-182\n3 ht_cm     3.52e-144\n4 ct_blood  4.47e-  1\n5 temp      5.74e-  1\n\n\nNhưng bây giờ hãy thêm các cột chứa trung bình cho mỗi nhóm (nam và nữ).\nChúng tôi sẽ cần trích xuất phần tử estimate, nhưng điều này thực sự chứa hai phần tử bên trong nó (mean in group f và mean in group m). Vì vậy, nó không thể được đơn giản hóa thành một vector với map_chr() hoặc map_dbl(). Thay vào đó, chúng tôi sử dụng map(), được sử dụng trong tibble(), sẽ tạo một cột lớp danh sách trong tibble! Vâng, điều này là có thể!\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}\n\n# A tibble: 5 × 3\n  variables         p means       \n  &lt;chr&gt;         &lt;dbl&gt; &lt;named list&gt;\n1 age       2.35e- 96 &lt;dbl [2]&gt;   \n2 wt_kg     2.66e-182 &lt;dbl [2]&gt;   \n3 ht_cm     3.52e-144 &lt;dbl [2]&gt;   \n4 ct_blood  4.47e-  1 &lt;dbl [2]&gt;   \n5 temp      5.74e-  1 &lt;dbl [2]&gt;   \n\n\nSau khi bạn có cột danh sách này, có một số hàm tidyr (một phần của tidyverse) giúp bạn “gỡ rối” hoặc “gỡ bỏ” các cột “danh sách lồng nhau” này. Đọc thêm về chúng tại đây hoặc bằng cách chạy vignette(\"rectangle\"). Tóm lại:\n\nunnest_wider() - đưa mỗi phần tử của mỗi danh sách cột một cột riêng của nó\n\nunnest_longer() - đưa mỗi phần tử của mỗi danh sách cột một hàng riêng của nó\n\nhoist() - hoạt động giống như unnest_wider() nhưng bạn chỉ định phần tử nào cần gỡ bỏ\n\nDưới đây, chúng tôi chuyển tibble sang unnest_wider() để chỉ định cột means của tibble (là một danh sách lồng nhau). Kết quả là means được thay thế bằng hai cột mới, mỗi cột phản ánh hai phần tử trước đó trong mỗi ô means.\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %&gt;% \n  unnest_wider(means)\n\n# A tibble: 5 × 4\n  variables         p `mean in group f` `mean in group m`\n  &lt;chr&gt;         &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;\n1 age       2.35e- 96              12.7              19.6\n2 wt_kg     2.66e-182              45.8              59.6\n3 ht_cm     3.52e-144             109.              142. \n4 ct_blood  4.47e-  1              21.2              21.2\n5 temp      5.74e-  1              38.6              38.6\n\n\n\n\nLoại bỏ, giữ lại và thu gọn danh sách\nVì làm việc với purrr nên thường liên quan đến danh sách, chúng ta sẽ khám phá ngắn gọn một số hàm purrr để sửa đổi danh sách. Xem phần Tài nguyên học liệu để có hướng dẫn đầy đủ hơn về các hàm purrr.\n\nlist_modify() có nhiều cách sử dụng, một trong số đó có thể là xóa một phần tử danh sách\n\nkeep() giữ lại các phần tử được chỉ định cho .p = hoặc trong đó một hàm được cung cấp cho .p = đánh giá là TRUE\n\ndiscard() loại bỏ các phần tử được chỉ định cho .p hoặc trong đó một hàm được cung cấp cho .p = đánh giá là TRUE\n\ncompact() loại bỏ tất cả các phần tử trống\n\nDưới đây là một số ví dụ sử dụng danh sách combined được tạo trong phần trên về sử dụng map() để nhập và kết hợp nhiều tệp (nó chứa 6 trường hợp linelist thuộc data frames):\nCác phần tử có thể được xóa bằng tên với list_modify() và đặt tên bằng NULL.\n\ncombined %&gt;% \n  list_modify(\"Central Hospital\" = NULL)   # remove list element by name\n\nBạn cũng có thể loại bỏ các phần tử theo tiêu chí, bằng cách cung cấp phương trình “định trước” cho .p = (một phương trình đánh giá là TRUE hoặc FALSE). Đặt dấu ngã ~ trước hàm và sử dụng .x để đại diện cho phần tử danh sách. Sử dụng keep(), các phần tử danh sách đánh giá là TRUE sẽ được giữ lại. Ngược lại, nếu sử dụng discard(), các phần tử danh sách đánh giá là TRUE sẽ bị loại bỏ.\n\n# keep only list elements with more than 500 rows\ncombined %&gt;% \n  keep(.p = ~nrow(.x) &gt; 500)  \n\nTrong ví dụ dưới đây, các phần tử danh sách bị loại bỏ nếu lớp của chúng không phải là data frames.\n\n# Discard list elements that are not data frames\ncombined %&gt;% \n  discard(.p = ~class(.x) != \"data.frame\")\n\nHàm định trước của bạn cũng có thể tham chiếu các phần tử/cột trong mỗi mục danh sách. Ví dụ, bên dưới, liệt kê các phần tử có giá trị trung bình của cột ct_blood trên 25 sẽ bị loại bỏ.\n\n# keep only list elements where ct_blood column mean is over 25\ncombined %&gt;% \n  discard(.p = ~mean(.x$ct_blood) &gt; 25)  \n\nLệnh này sẽ xóa tất cả các phần tử danh sách trống:\n\n# Remove all empty list elements\ncombined %&gt;% \n  compact()\n\n\n\npmap()\nPHẦN NÀY ĐANG ĐƯỢC XÂY DỰNG",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#các-hàm-apply",
    "href": "new_pages/iteration.vn.html#các-hàm-apply",
    "title": "8  Lặp, vòng lặp, và danh sách",
    "section": "8.4 Các hàm apply",
    "text": "8.4 Các hàm apply\nNhóm hàm “apply” là một hàm R base thay thế cho purrr với các thao tác lặp lại. Bạn có thể đọc thêm về chúng tại đây.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/iteration.vn.html#tài-nguyên-học-liệu",
    "title": "8  Lặp, vòng lặp, và danh sách",
    "section": "8.5 Tài nguyên học liệu",
    "text": "8.5 Tài nguyên học liệu\nfor loops with Data Carpentry\nThe R for Data Science page on iteration\nVignette on write/read Excel files\nA purrr tutorial by jennybc\nAnother purrr tutorial by Rebecca Barter\nA purrr tutorial on map, pmap, and imap\npurrr cheatsheet\npurrr tips and tricks\nkeep and discard",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html",
    "href": "new_pages/combination_analysis.vn.html",
    "title": "9  Biểu đồ kết hợp",
    "section": "",
    "text": "9.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html#chuẩn-bị",
    "href": "new_pages/combination_analysis.vn.html#chuẩn-bị",
    "title": "9  Biểu đồ kết hợp",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị việc gọi các gói cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package nếu cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(\n  tidyverse,     # data management and visualization\n  UpSetR,        # special package for combination plots\n  ggupset)       # special package for combination plots\n\n\n\n\nNhập dữ liệu\nĐể bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết.\n\n# import case linelist \nlinelist_sym &lt;- import(\"linelist_cleaned.rds\")\n\nBộ số liệu linelist bao gồm năm biến “có/không” về các triệu chứng được ghi nhận. Chúng ta sẽ cần phải biến đổi các biến số này một chút trước khi sử dụng package ggupset để tạo biểu đồ. Xem dữ liệu (cuộn sang phải để xem các biến triệu chứng).\n\n\n\n\n\n\n\n\n\nĐịnh dạng lại giá trị\nĐể tương đồng với định dạng của package ggupset, chúng ta cần đổi giá trị “yes” và “no” thành tên các triệu chứng thực tế, sử dụng hàm case_when() từ package dplyr. Nếu giá trị là “no”, chúng ta sẽ bỏ trống, nghĩa là biến mới sẽ có giá trị hoặc là NA hoặc là triệu chứng.\n\n# create column with the symptoms named, separated by semicolons\nlinelist_sym_1 &lt;- linelist_sym %&gt;% \n  \n  # convert the \"yes\" and \"no\" values into the symptom name itself\n  mutate(\n    fever = case_when(\n      fever == \"yes\" ~ \"fever\",          # if old value is \"yes\", new value is \"fever\"\n      TRUE           ~ NA_character_),   # if old value is anything other than \"yes\", the new value is NA\n         \n    chills = case_when(\n       chills == \"yes\" ~ \"chills\",\n       TRUE           ~ NA_character_),\n    \n    cough = case_when(\n      cough == \"yes\" ~ \"cough\",\n      TRUE           ~ NA_character_),\n         \n    aches = case_when(\n      aches == \"yes\" ~ \"aches\",\n      TRUE           ~ NA_character_),\n         \n    vomit = case_when(\n      vomit == \"yes\" ~ \"vomit\",\n      TRUE           ~ NA_character_)\n    )\n\nBây giờ chúng ta tạo hai cột cuối cùng:\n\nKết hợp (ghép lại với nhau) tất cả các triệu chứng của bệnh nhân (thành một cột ký tự)\n\nChuyển đổi định dạng cột bên trên thành kiểu danh sách để được chấp nhận bởi package ggupset khi vẽ biểu đồ\n\nXem thêm chương Ký tự và chuỗi để biết thêm về hàm unite() trong package stringr\n\nlinelist_sym_1 &lt;- linelist_sym_1 %&gt;% \n  unite(col = \"all_symptoms\",\n        c(fever, chills, cough, aches, vomit), \n        sep = \"; \",\n        remove = TRUE,\n        na.rm = TRUE) %&gt;% \n  mutate(\n    # make a copy of all_symptoms column, but of class \"list\" (which is required to use ggupset() in next step)\n    all_symptoms_list = as.list(strsplit(all_symptoms, \"; \"))\n    )\n\nBây giờ chúng ta cùng xem dữ liệu mới. Lưu ý hai cột ở cuối bên phải - các giá trị kết hợp được ghép và danh sách",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html#ggupset",
    "href": "new_pages/combination_analysis.vn.html#ggupset",
    "title": "9  Biểu đồ kết hợp",
    "section": "9.2 ggupset",
    "text": "9.2 ggupset\nGọi package\n\npacman::p_load(ggupset)\n\nVẽ biểu đồ. Chúng ta bắt đầu bằng hàm ggplot() và geom_bar(), nhưng sau đó chúng ta thêm hàm đặc biệt scale_x_upset() từ package ggupset.\n\nggplot(\n  data = linelist_sym_1,\n  mapping = aes(x = all_symptoms_list)) +\ngeom_bar() +\nscale_x_upset(\n  reverse = FALSE,\n  n_intersections = 10,\n  sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"))+\nlabs(\n  title = \"Signs & symptoms\",\n  subtitle = \"10 most frequent combinations of signs and symptoms\",\n  caption = \"Caption here.\",\n  x = \"Symptom combination\",\n  y = \"Frequency in dataset\")\n\n\n\n\n\n\n\n\nBạn có thể đọc thêm về package ggupset ở tài liệu online này hoặc trong tài liệu trợ giúp của package bằng cách gõ vào cửa RStudio Help lệnh ?ggupset.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html#upsetr",
    "href": "new_pages/combination_analysis.vn.html#upsetr",
    "title": "9  Biểu đồ kết hợp",
    "section": "9.3 UpSetR",
    "text": "9.3 UpSetR\nPackage UpSetR cho phép tùy chỉnh biểu đồ sâu hơn, nhưng nó cũng khó thực hiện hơn:\nGọi package\n\npacman::p_load(UpSetR)\n\nLàm sạch dữ liệu\nChúng ta phải chuyển đổi các triệu chứng trong bộ dữ liệu linelist thành các giá trị 1 / 0.\n\n# Make using upSetR\n\nlinelist_sym_2 &lt;- linelist_sym %&gt;% \n  \n  # convert the \"yes\" and \"no\" values into the symptom name itself\n  mutate(\n    fever = case_when(\n      fever == \"yes\" ~ 1,    # if old value is \"yes\", new value is 1\n      TRUE           ~ 0),   # if old value is anything other than \"yes\", the new value is 0\n         \n    chills = case_when(\n      chills == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    cough = case_when(\n      cough == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    aches = case_when(\n      aches == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    vomit = case_when(\n      vomit == \"yes\" ~ 1,\n      TRUE           ~ 0)\n    )\n\nBạn có thể tham khảo hàm +() được dùng kết hợp với hàm across() để thực hiện thay đổi trên nhiều cột cùng lúc (đọc thêm tại chương Các hàm làm sạch dữ liệu).\n\n# Efficiently convert \"yes\" to 1 and 0\nlinelist_sym_2 &lt;- linelist_sym %&gt;% \n  \n  # convert the \"yes\" and \"no\" values into 1s and 0s\n  mutate(across(c(fever, chills, cough, aches, vomit), .fns = ~+(.x == \"yes\")))\n\nBây giờ chúng ta hãy vẽ biểu đồ bằng hàm tùy chỉnh upset() - chỉ sử dụng các cột triệu chứng. Bạn phải chỉ định “bộ” nào để so sánh (tên của các cột triệu chứng). Một cách khác, sử dụng nsets = và order.by = \"freq\" để chỉ hiện thị X các sự kết hợp nhiều nhất.\n\n# Make the plot\nUpSetR::upset(\n  select(linelist_sym_2, fever, chills, cough, aches, vomit),\n  sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"),\n  order.by = \"freq\",\n  sets.bar.color = c(\"blue\", \"red\", \"yellow\", \"darkgreen\", \"orange\"), # optional colors\n  empty.intersections = \"on\",\n  # nsets = 3,\n  number.angles = 0,\n  point.size = 3.5,\n  line.size = 2, \n  mainbar.y.label = \"Symptoms Combinations\",\n  sets.x.label = \"Patients with Symptom\")",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html#nguồn",
    "href": "new_pages/combination_analysis.vn.html#nguồn",
    "title": "9  Biểu đồ kết hợp",
    "section": "9.4 Nguồn",
    "text": "9.4 Nguồn\nThe github page on UpSetR\nA Shiny App version - you can upload your own data\n*documentation - difficult to interpret",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html",
    "href": "new_pages/transmission_chains.vn.html",
    "title": "10  Chuỗi lây nhiễm",
    "section": "",
    "text": "10.1 Tổng quan\nCông cụ chính để xử lý, phân tích và trực quan hóa chuỗi lây nhiễm và dữ liệu theo dõi tiếp xúc là package epicontacts, được phát triển bởi những chuyên gia làm việc tại RECON. Hãy thử biểu đồ tương tác bên dưới bằng cách di chuột qua các nút để biết thêm thông tin, kéo-thả để di chuyển chúng và nhấp vào chúng để đánh dấu các trường hợp phía dưới.\nWarning in epicontacts::make_epicontacts(linelist = linelist, contacts =\ncontacts, : Cycle(s) detected in the contact network: this may be unwanted",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#chuẩn-bị",
    "href": "new_pages/transmission_chains.vn.html#chuẩn-bị",
    "title": "10  Chuỗi lây nhiễm",
    "section": "10.2 Chuẩn bị",
    "text": "10.2 Chuẩn bị\n\nGọi packages\nĐầu tiên hãy tải các package tiêu chuẩn cần thiết để nhập và xử lý dữ liệu. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, sẽ cài đặt package nếu cần và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các package bằng hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\n\npacman::p_load(\n   rio,          # File import\n   here,         # File locator\n   tidyverse,    # Data management + ggplot2 graphics\n   remotes       # Package installation from github\n)\n\nBạn sẽ sử dụng phiên bản phát triển của epicontacts, có thể được cài đặt từ github bằng cách sử dụng hàm p_install_github() từ package pacman. Bạn chỉ cần chạy lệnh này dưới đây một lần, không phải bất cứ khi nào bạn sử dụng package (sau đó, bạn có thể sử dụng hàm p_load() như bình thường).\n\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n\n\nNhập dữ liệu\nChúng ta nhập bộ dữ liệu về các trường hợp bệnh từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải xuống dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương Tải sách và dữ liệu. Bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau.\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\n50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị bên dưới. Mối quan tâm đặc biệt là các cột case_id, generation, infector, và source.\n\n\n\n\n\n\n\n\nTạo đối tượng epicontacts\nSau đó, chúng ta cần tạo một đối tượng epicontacts, với yêu cầu hai kiểu dữ liệu như sau:\n\nMột bộ dữ liệu linelist ghi lại các trường hợp trong đó các cột là các biến và các hàng tương ứng với các trường hợp duy nhất\nMột danh sách các cạnh (edge) thể hiện liên kết giữa các quan sát trên ID duy nhất (có thể là liên hệ, sự kiện lây nhiễm, v.v.)\n\nBởi vì chúng ta đã có sẵn bộ dữ liệu linelist, chúng ta chỉ cần tạo một danh sách các đường liên kết giữa các trường hợp, cụ thể hơn là giữa các ID. Chúng ta có thể trích xuất các đường liên kết lây nhiễm từ bộ số liệu linelist bằng cách liên kết cột infector với cột case_id. Tại đây, chúng ta cũng có thể thêm các “thuộc tính cạnh - edge properties”, nghĩa là bất kỳ biến nào mô tả mối liên kết giữa hai trường hợp, không phải bản thân các trường hợp đó. Để minh họa, chúng ta sẽ thêm một biến location mô tả vị trí của sự kiện truyền nhiễm và một biến mô tả khoảng thời gian tiếp xúc tính bằng ngày.\nTrong đoạn code dưới đây, hàm transmute thuộc package dplyr tương tự như hàm mutate, ngoại trừ nó chỉ giữ các cột mà chúng ta đã chỉ định trong hàm. Hàm drop_na sẽ lọc ra bất kỳ hàng nào mà các cột được chỉ định có giá trị NA ; trong trường hợp này, chúng ta chỉ muốn giữ lại các hàng mà tác nhân lây nhiễm đã biết.\n\n## generate contacts\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %&gt;%\n  drop_na(infector)\n\nBây giờ chúng ta có thể tạo đối tượng epicontacts bằng cách sử dụng hàm make_epicontacts. Chúng ta cần chỉ định cột trong bộ dữ liệu linelist trỏ đến mã định danh trường hợp duy nhất (ID), cũng như cột trong điểm tiếp xúc tới mã định danh duy nhất của các trường hợp có liên quan trong mỗi liên kết. Các liên kết này có tính định hướng, nghĩa là việc lây nhiễm sẽ đi từ người lây nhiễm đến ca bệnh, vì vậy chúng ta cần chỉ định các đối số from và to cho phù hợp. Chúng ta cũng đặt đối số directed thành TRUE, điều này sẽ ảnh hưởng đến các hoạt động về sau.\n\n## generate epicontacts object\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n\nWarning in make_epicontacts(linelist = linelist, contacts = contacts, id =\n\"case_id\", : Cycle(s) detected in the contact network: this may be unwanted\n\n\nSau khi kiểm tra các đối tượng epicontacts, chúng ta có thể thấy rằng cột case_id trong bộ dữ liệu linelist đã được đổi tên thành id và các cột case_id và cột infector trong liên hệ đã được đổi tên thành from và to. Điều này đảm bảo tính nhất quán trong các hoạt động xử lý, trực quan và phân tích tiếp theo.\n\n## view epicontacts object\nepic\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 5,888 cases in linelist; 3,800 contacts; directed \n\n  // linelist\n\n# A tibble: 5,888 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 8689b7          4 NA             2014-05-13 2014-05-14           2014-05-18  \n 3 11f8ea          2 NA             2014-05-16 2014-05-18           2014-05-30  \n 4 b8812a          3 2014-05-04     2014-05-18 2014-05-20           NA          \n 5 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 be99c8          3 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 07e3e8          4 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 369449          4 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 f393b4          4 NA             2014-06-05 2014-06-06           2014-06-18  \n10 1389ca          4 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 3,800 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 f547d6 5fe599 Community         7\n 2 f90f5f b8812a Community         2\n 3 11f8ea 893f25 Nosocomial        2\n 4 aec8ec be99c8 Community         2\n 5 893f25 07e3e8 Nosocomial        5\n 6 133ee7 369449 Community         5\n 7 996f3a 2978ac Community         1\n 8 133ee7 57a565 Community         2\n 9 37a6f6 fc15ef Nosocomial        4\n10 9f6884 2eaa9a Nosocomial       10\n# ℹ 3,790 more rows",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#xử-lý",
    "href": "new_pages/transmission_chains.vn.html#xử-lý",
    "title": "10  Chuỗi lây nhiễm",
    "section": "10.3 Xử lý",
    "text": "10.3 Xử lý\n\nChia nhỏ bộ dữ liệu\nPhương thức subset() cho các đối tượng epicontacts cho phép lọc các mạng lưới dựa trên các thuộc tính của bộ dữ liệu linelist (“thuộc tính nút”) và cơ sở dữ liệu tiếp xýc (“thuộc tính cạnh”). Các giá trị này phải được chuyển đổi dưới dạng danh sách đã đặt tên cho đối số tương ứng. Ví dụ: trong đoạn code bên dưới, chúng tôi chỉ giữ lại các trường hợp nam giới trong bộ số liệu linelist có ngày lây nhiễm từ tháng 4 đến tháng 7 năm 2014 (ngày tháng được chỉ định dưới dạng khoảng) và các liên kết lây nhiễm xảy ra trong bệnh viện.\n\nsub_attributes &lt;- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ), \n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 69 cases in linelist; 1,923 contacts; directed \n\n  // linelist\n\n# A tibble: 69 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 3 2978ac          4 2014-05-30     2014-06-06 2014-06-08           2014-06-15  \n 4 57a565          4 2014-05-28     2014-06-13 2014-06-15           NA          \n 5 fc15ef          6 2014-06-14     2014-06-16 2014-06-17           2014-07-09  \n 6 99e8fa          7 2014-06-24     2014-06-28 2014-06-29           2014-07-09  \n 7 f327be          6 2014-06-14     2014-07-12 2014-07-13           2014-07-14  \n 8 90e5fe          5 2014-06-18     2014-07-13 2014-07-14           2014-07-16  \n 9 a47529          5 2014-06-13     2014-07-17 2014-07-18           2014-07-26  \n10 da8ecb          5 2014-06-20     2014-07-18 2014-07-20           2014-08-01  \n# ℹ 59 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 1,923 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 11f8ea 893f25 Nosocomial        2\n 2 893f25 07e3e8 Nosocomial        5\n 3 37a6f6 fc15ef Nosocomial        4\n 4 9f6884 2eaa9a Nosocomial       10\n 5 4802b1 bbfa93 Nosocomial        6\n 6 a75c7f 7f5a01 Nosocomial        4\n 7 8e104d ddddee Nosocomial        2\n 8 ab634e 99e8fa Nosocomial        9\n 9 a15e13 f327be Nosocomial        5\n10 beb26e 959170 Nosocomial        7\n# ℹ 1,913 more rows\n\n\nChúng ta có thể sử dụng hàm thin để lọc trong bộ số liệu linelist để bao gồm các trường hợp được tìm thấy trong danh sách “contacts” bằng cách đặt đối số what = \"linelist\", hoặc lọc trong danh sách “contacts” để bao gồm các trường hợp được tìm thấy trong bộ số liệu linelist bằng cách đặt đối số what = \"contacts\". Trong đoạn code dưới đây, chúng ta đang lọc thêm từ đối tượng epicontacts để chỉ giữ lại các đường liên kết lây nhiễm có liên quan đến các trường hợp nam giới bị lây nhiễm giữa tháng 4 và tháng 7 mà chúng ta đã lọc ở trên. Chúng ta có thể thấy rằng chỉ có hai liên kết lây nhiễm đã biết phù hợp với đặc điểm đó.\n\nsub_attributes &lt;- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)\n\n[1] 4\n\n\nBên cạnh việc subset theo thuộc tính nút (node) và cạnh (edge), các mạng liên kết có thể được cắt tỉa để chỉ bao gồm các thành phần được kết nối với một số nút nhất định. Đối số cluster_id sẽ lấy một vectơ chứa ID các ca bệnh và trả về danh sách của các cá nhân được liên kết một cách trực tiếp hoặc gián tiếp tới các ID đó. Trong đoạn code dưới đây, chúng ta có thể thấy rằng tổng cộng 13 trường hợp trong bộ số liệu linelist có liên quan đến các cụm chứa 2ae019 và 71577a.\n\nsub_id &lt;- subset(epic, cluster_id = c(\"2ae019\",\"71577a\"))\nnrow(sub_id$linelist)\n\n[1] 13\n\n\nPhương pháo subset() cho các đối tượng epicontacts cũng cho phép lọc theo kích thước cụm bằng cách sử dụng các đối số cs, cs_min và cs_max. Trong đoạn code bên dưới, chúng ta chỉ giữ lại các trường hợp được liên kết với các cụm 10 trường hợp hoặc lớn hơn và có thể thấy rằng 271 trường hợp trong trong bộ số liệu linelist có liên quan đến các cụm đó.\n\nsub_cs &lt;- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)\n\n[1] 271\n\n\n\n\nTruy cập thông tin ID\nHàm get_id() truy xuất thông tin về ID ca bệnh trong bộ dữ liệu và có thể được tham số hóa như sau:\n\nlinelist: ID trong bộ dữ liệu linelist\ncontacts: ID trong bộ dữ liệu contact (kết hợp “from” và “to”)\nfrom: ID trong cột “from” của bộ dữ liệu contact\nto: ID trong cột “to” của bộ dữ liệu contact\nall: các ID xuất hiện ở bất kỳ một trong hai bộ dữ liệu\ncommon: các ID xuất hiện trong cả bộ dữ liệu contact và bộ dữ liệu linelist\n\nVí dụ: xem 10 ID đầu tiên trong bộ dữ liệu contact?\n\ncontacts_ids &lt;- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)\n\n [1] \"f547d6\" \"f90f5f\" \"11f8ea\" \"aec8ec\" \"893f25\" \"133ee7\" \"996f3a\" \"37a6f6\"\n [9] \"9f6884\" \"4802b1\"\n\n\nCó bao nhiêu ID được tìm thấy trong cả hai bộ dữ liệu tiếp xúc và linelist?\n\nlength(get_id(epic, \"common\"))\n\n[1] 4352",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#trực-quan-hóa",
    "href": "new_pages/transmission_chains.vn.html#trực-quan-hóa",
    "title": "10  Chuỗi lây nhiễm",
    "section": "10.4 Trực quan hóa",
    "text": "10.4 Trực quan hóa\n\nBiểu đồ cơ bản\nTất cả các hình ảnh trực quan của các đối tượng epicontacts được xử lý bởi hàm plot. Trước tiên, chúng ta sẽ lọc đối tượng epicontacts để chỉ bao gồm các trường hợp có ngày bắt đầu vào tháng 6 năm 2014 bằng cách sử dụng hàm subset, và chỉ bao gồm các tiếp xúc được liên kết với các trường hợp đó bằng cách sử dụng hàm thin.\n\n## subset epicontacts object\nsub &lt;- epic %&gt;%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %&gt;%\n thin(\"contacts\")\n\nSau đó, chúng ta có thể tạo biểu đồ cơ bản, có tính tương tác rất đơn giản như sau:\n\n## plot epicontacts object\nplot(\n  sub,\n  width = 700,\n  height = 700\n)\n\n\n\n\n\nBạn có thể di chuyển các nút xung quanh bằng cách kéo chúng, di chuột qua chúng để biết thêm thông tin và nhấp vào chúng để đánh dấu các trường hợp được kết nối.\nCó một số lượng lớn các đối số để tùy chỉnh biểu đồ này. Chúng ta sẽ trình bày những vấn đề chính ở đây, nhưng bạn có thể xem thêm tài liệu thông qua lệnh ?vis_epicontacts (hàm được gọi khi sử dụng biểu đồ trên đối tượng epicontacts) để có được mô tả đầy đủ về các đối số của hàm.\n\nTrực quan hóa các thuộc tính của nút\nMàu nút, hình dạng nút và kích thước nút có thể được ánh xạ tới một cột nhất định trong bộ số liệu linelist bằng cách sử dụng các đối số node_color, node_shape và node_size. Điều này tương tự với cú pháp aes mà bạn có thể thấy trong ggplot2.\nMàu sắc, hình dạng và kích thước cụ thể của các nút có thể được chỉ định như sau:\n\nMàu sắc thông qua đối số col_pal, bằng cách cung cấp một danh sách tên được chỉ định cho từng màu cụ thể như được thực hiện bên dưới hoặc bằng cách cung cấp một hàm bảng màu như colorRampPalette(c(\"black\", \"red\", \"orange\")), mà sẽ giúp cung cấp một dải màu giữa các màu được chỉ định.\nHình dạng bằng cách chuyển một danh sách đã đặt tên đến đối số shapes, chỉ định một hình dạng cho mỗi phần tử duy nhất trong cột bộ số liệu linelist được chỉ định bởi đối số node_shape. Xem codeawesome để biết các hình dạng có sẵn.\nKích thước bằng cách chuyển một phạm vi kích thước của các nút tới đối số size_range.\n\nDưới đây là một ví dụ, trong đó màu sắc thể hiện cho outcome, hình dạng thể hiện cho giới tính và kích thước thể hiện cho độ tuổi:\n\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\nTrực quan hóa các thuộc tính cạnh\nMàu, độ dày và kiểu đường có thể được ánh xạ tới một cột nhất định trong bộ dữ liệu tiếp xúc bằng cách sử dụng các đối số edge_color, edge_width và edge_linetype. Các màu cụ và độ dày của các cạnh có thể được chỉ định như sau:\n\nMàu sắc thông qua đối số edge_col_pal, theo cách tương tự được sử dụng cho col_pal.\nĐộ rộng bằng cách chuyển phạm vi kích thước của các nút tới đối số width_range.\n\nDưới đây là ví dụ:\n\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = 'age',\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = 'location',\n  edge_linetype = 'location',\n  edge_width = 'duration',\n  edge_col_pal = c(Community = \"orange\", Nosocomial = \"purple\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\n\nTrục thời gian\nChúng ta cũng có thể trực quan hóa mạng lây nhiễm dọc theo trục thời gian bằng cách ánh xạ đối số x_axis vào một cột trong bộ số liệu linelist. Trong ví dụ dưới đây, trục x biểu thị ngày bắt đầu triệu chứng. Chúng ta cũng đã chỉ định đối số arrow_size để đảm bảo các mũi tên không quá lớn và đặt label = FALSE để làm cho hình bớt lộn xộn.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nCó một số lượng lớn các đối số bổ sung để cụ thể hơn cách mà mạng lưới này được hiển thị dọc theo trục thời gian, bạn có thể kiểm tra thông qua lệnh ?vis_temporal_interactive (hàm được gọi khi sử dụng hàm plot trên đối tượng epicontacts với đối số x_axis được chỉ định). Chúng tôi sẽ mô tả kỹ hơn ở bên dưới.\n\nChỉ định hình dạng cây lây nhiễm\nCó hai hình dạng chính mà cây lây nhiễm có thể giả định, được chỉ định bằng cách sử dụng đối số network_shape. Đầu tiên là hình dạng nhánh branching như hình trên, trong đó một cạnh thẳng nối hai nút bất kỳ. Đây là cách trình bày trực quan nhất, tuy nhiên có thể dẫn đến các cạnh chồng lên nhau trong một mạng kết nối dày đặc. Kiểu hình thứ hai là rectangle, sẽ tạo ra một cái cây giống như cây phát sinh loài. Ví dụ:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nMỗi nút có thể được gán một vị trí dọc duy nhất bằng cách chuyển đổi đối số position_dodge. Vị trí của các trường hợp không được kết nối (tức là không có lây nhiễm được báo cáo) được xác định bằng cách sử dụng đối số unlinked_pos.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nVị trí của nút “mẹ” so với các nút “con” có thể được xác định bằng cách sử dụng đối số parent_pos. Tùy chọn mặc định là đặt nút “mẹ” ở giữa, tuy nhiên nó có thể được đặt ở dưới cùng (parent_pos = 'bottom') hoặc ở trên cùng (parent_pos = 'top').\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\nLưu biểu đồ\nBạn có thể lưu một biểu đồ dưới dạng tệp tin html tương tác, độc lập với hàm visSave từ package VisNetwork:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n) %&gt;%\n  visNetwork::visSave(\"network.html\")\n\nRất tiếc, việc lưu các kết quả đầu ra mạng lưới lây nhiễm này dưới dạng hình ảnh trở nên khó khăn và bạn cần lưu dưới dạng tệp tin html và sau đó chụp ảnh màn hình của tệp tin này bằng backage webshot. Trong đoạn code dưới đây, chúng ta đang chuyển đổi tệp tin html được lưu ở trên thành dạng file ảnh PNG:\n\nwebshot(url = \"network.html\", file = \"network.png\")\n\n\n\n\nDòng thời gian\nBạn cũng có thể thêm dòng thời gian cho mạng lưới truyền nhiễm, được biểu diễn trên trục x của mỗi trường hợp. Nó có thể được sử dụng để trực quan hóa các vị trí ca bệnh, hoặc thời gian dẫn đến outcome. Để tạo dòng thời gian, chúng ta cần tạo một data.frame gồm ít nhất ba cột bao gồm ID, ngày bắt đầu của “sự kiện” và ngày kết thúc của “sự kiện”. Bạn cũng có thể thêm bất kỳ cột giá trị nào khác mà sau đó có thể được ánh xạ tới các thuộc tính nút và cạnh của dòng thời gian. Trong đoạn code dưới đây, chúng ta tạo một dòng thời gian từ ngày bắt đầu có triệu chứng đến ngày có outcome và giữ các biến outcome và bệnh viện mà chúng ta đã sử dụng để xác định hình dạng và màu sắc của nút. Lưu ý rằng bạn có thể có nhiều hơn một dòng thời gian hàng/sự kiện cho mỗi trường hợp, ví dụ: nếu một trường hợp được chuyển viện giữa nhiều bệnh viện.\n\n## generate timeline\ntimeline &lt;- linelist %&gt;%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n\nSau đó, chúng ta chuyển phần tử dòng thời gian vào đối số timeline. Chúng ta có thể ánh xạ các thuộc tính dòng thời gian với màu sắc, hình dạng và kích thước của nút dòng thời gian theo cùng một cách đã xác định trong các phần trước, ngoại trừ việc chúng ta có hai nút: nút bắt đầu và nút kết thúc của mỗi dòng thời gian, có các đối số riêng biệt. Ví dụ: tl_start_node_color xác định cột dòng thời gian nào được ánh xạ với màu của nút bắt đầu, trong khi tl_end_node_shape xác định cột dòng thời gian nào được ánh xạ tới hình dạng của nút kết thúc. Chúng ta cũng có thể ánh xạ màu, độ dày, kiểu đường kẻ và nhãn vào cạnh dòng thời gian thông qua các đối số tl_edge_.\nXem ?vis_temporal_interactive (hàm được gọi khi vẽ biểu đồ một đối tượng epicontacts) để biết tài liệu chi tiết về các đối số. Mỗi đối số cũng được chú thích trong đoạn code bên dưới:\n\n## define shapes\nshapes &lt;- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## define colours\ncolours &lt;- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## make plot\nplot(\n  sub,\n  ## max x coordinate to date of onset\n  x_axis = \"date_onset\",\n  ## use rectangular network shape\n  network_shape = \"rectangle\",\n  ## mape case node shapes to gender column\n  node_shape = \"gender\",\n  ## we don't want to map node colour to any columns - this is important as the\n  ## default value is to map to node id, which will mess up the colour scheme\n  node_color = NULL,\n  ## set case node size to 30 (as this is not a character, node_size is not\n  ## mapped to a column but instead interpreted as the actual node size)\n  node_size = 30,\n  ## set transmission link width to 4 (as this is not a character, edge_width is\n  ## not mapped to a column but instead interpreted as the actual edge width)\n  edge_width = 4,\n  ## provide the timeline object\n  timeline = timeline,\n  ## map the shape of the end node to the outcome column in the timeline object\n  tl_end_node_shape = \"outcome\",\n  ## set the size of the end node to 15 (as this is not a character, this\n  ## argument is not mapped to a column but instead interpreted as the actual\n  ## node size)\n  tl_end_node_size = 15,\n  ## map the colour of the timeline edge to the hospital column\n  tl_edge_color = \"hospital\",\n  ## set the width of the timeline edge to 2 (as this is not a character, this\n  ## argument is not mapped to a column but instead interpreted as the actual\n  ## edge width)\n  tl_edge_width = 2,\n  ## map edge labels to the hospital variable\n  tl_edge_label = \"hospital\",\n  ## specify the shape for everyone node attribute (defined above)\n  shapes = shapes,\n  ## specify the colour palette (defined above)\n  col_pal = colours,\n  ## set the size of the arrow to 0.5\n  arrow_size = 0.5,\n  ## use two columns in the legend\n  legend_ncol = 2,\n  ## set font size\n  font_size = 15,\n  ## define formatting for dates\n  date_labels = c(\"%d %b %Y\"),\n  ## don't plot the ID labels below nodes\n  label = FALSE,\n  ## specify height\n  height = 1000,\n  ## specify width\n  width = 1200,\n  ## ensure each case node has a unique y-coordinate - this is very important\n  ## when using timelines, otherwise you will have overlapping timelines from\n  ## different cases\n  position_dodge = TRUE\n)\n\nWarning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed\nas ID not found in linelist or start/end date is NA",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#phân-tích",
    "href": "new_pages/transmission_chains.vn.html#phân-tích",
    "title": "10  Chuỗi lây nhiễm",
    "section": "10.5 Phân tích",
    "text": "10.5 Phân tích\n\nTổng hợp\nChúng ta có thể xem tổng quan về một số thuộc tính mạng lưới bằng cách sử dụng hàm summary.\n\n## summarise epicontacts object\nsummary(epic)\n\n\n/// Overview //\n  // number of unique IDs in linelist: 5888\n  // number of unique IDs in contacts: 5511\n  // number of unique IDs in both: 4352\n  // number of contacts: 3800\n  // contacts with both cases in linelist: 56.868 %\n\n/// Degrees of the network //\n  // in-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  1.0000  0.5392  1.0000  1.0000 \n\n  // out-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  0.0000  0.5392  1.0000  6.0000 \n\n  // in and out degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   1.000   1.000   1.078   1.000   7.000 \n\n/// Attributes //\n  // attributes in linelist:\n generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp\n\n  // attributes in contacts:\n location duration\n\n\nVí dụ, chúng ta có thể thấy rằng chỉ có 57% các tiếp xúc có cả hai trường hợp trong bộ số liệu linelist; điều này có nghĩa là chúng ta không có dữ liệu trong bộ số liệu linelist về một số lượng đáng kể các trường hợp liên quan đến các chuỗi lây nhiễm này.\n\n\nĐặc điểm ghép cặp\nHàm get_pairwise() cho phép xử lý (các) biến trong bộ số liệu linelist theo từng cặp trong bộ dữ liệu tiếp xúc. Ở ví dụ dưới đây, ngày khởi phát bệnh được trích xuất từ bộ số liệu linelist để tính toán sự khác biệt giữa ngày khởi phát bệnh cho từng cặp. Giá trị được tạo ra từ phép so sánh này đại diện cho khoảng nối tiếp (serial interval - si).\n\nsi &lt;- get_pairwise(epic, \"date_onset\")   \nsummary(si)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    5.00    9.00   11.01   15.00   99.00    1820 \n\ntibble(si = si) %&gt;%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Serial interval\",\n    y = \"Frequency\"\n  )\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 1820 rows containing non-finite values (`stat_bin()`).\n\n\n\n\n\n\n\n\n\nget_pairwise() sẽ diễn giải phân lớp của cột đang được sử dụng để so sánh và sẽ điều chỉnh phương pháp so sánh các giá trị của nó cho phù hợp. Đối với số và ngày (như ví dụ si ở trên), hàm sẽ trừ các giá trị. Khi được áp dụng cho các cột là ký tự hoặc phân loại, get_pairwise() sẽ gán các giá trị lại với nhau. Bởi vì hàm cũng cho phép xử lý tùy ý (xem đối số “f”), các kết hợp rời rạc này có thể dễ dàng được mô tả và phân tích.\n\nhead(get_pairwise(epic, \"gender\"), n = 10)\n\n [1] \"f -&gt; m\" NA       \"m -&gt; m\" NA       \"m -&gt; f\" \"f -&gt; f\" NA       \"f -&gt; m\"\n [9] NA       \"m -&gt; f\"\n\nget_pairwise(epic, \"gender\", f = table)\n\n           values.to\nvalues.from   f   m\n          f 464 516\n          m 510 468\n\nfisher.test(get_pairwise(epic, \"gender\", f = table))\n\n\n    Fisher's Exact Test for Count Data\n\ndata:  get_pairwise(epic, \"gender\", f = table)\np-value = 0.03758\nalternative hypothesis: true odds ratio is not equal to 1\n95 percent confidence interval:\n 0.6882761 0.9892811\nsample estimates:\nodds ratio \n 0.8252575 \n\n\nỞ đây, chúng ta thấy có một mối liên hệ lớn giữa các liên kết lây nhiễm và giới tính.\n\n\nXác định cụm\nHàm get_clusters() có thể được sử dụng để xác định các thành phần được kết nối trong một đối tượng epicontacts. Đầu tiên, chúng ta sử dụng nó để truy xuất data.frame chứa thông tin cụm:\n\nclust &lt;- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)\n\n\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14 \n1536 1680 1182  784  545  342  308  208  171  100   99   24   26   42 \n\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Cluster size\",\n    y = \"Frequency\"\n  )\n\n\n\n\n\n\n\n\nGiờ chúng ta hãy xem xét các cụm lớn nhất. Đối với điều này, chúng ta thêm thông tin cụm vào đối tượng epicontacts và sau đó subset nó để chỉ giữ lại các cụm lớn nhất:\n\nepic &lt;- get_clusters(epic)\nmax_size &lt;- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))\n\n\n\n\n\n\n\nTính toán mức độ\nMức độ của một nút tương ứng với số cạnh hoặc kết nối của nó với các nút khác. get_degree() cung cấp một phương pháp dễ dàng để tính toán giá trị này cho các mạng lưới epicontacts. Mức độ cao trong ngữ cảnh này cho biết một cá nhân đã tiếp xúc với nhiều người khác. Đối sôs type chỉ ra rằng chúng ta muốn đếm cả mức độ trong và ngoài, đối số only_linelist chỉ ra rằng chúng ta chỉ muốn tính mức độ cho các trường hợp trong bộ số liệu linelist.\n\ndeg_both &lt;- get_degree(epic, type = \"both\", only_linelist = TRUE)\n\nNhững cá nhân nào có 10 tiếp xúc?\n\nhead(sort(deg_both, decreasing = TRUE), 10)\n\n916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd \n     7      6      6      6      5      5      5      5      5      5 \n\n\nSố lượng lây nhiễm trung bình là bao nhiêu?\n\nmean(deg_both)\n\n[1] 1.078473",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#tham-khảo",
    "href": "new_pages/transmission_chains.vn.html#tham-khảo",
    "title": "10  Chuỗi lây nhiễm",
    "section": "10.6 Tham khảo",
    "text": "10.6 Tham khảo\nEpicontacts page cung cấp tổng quan về các hàm và package bao gồm một số thông tin chi tiết chuyên sâu hơn.\nGithub page có thể được sử dụng để nêu vấn đề và yêu cầu chỉnh sửa.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  }
]